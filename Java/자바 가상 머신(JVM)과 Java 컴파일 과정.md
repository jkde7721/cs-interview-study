## 자바 가상 머신(JVM)과 Java 컴파일 과정

### Java 특징

> 자바는 썬에서 제작 당시, **'Write Once, Run Anywhere'** 이란 슬로건을 내세웠다. 즉 '한 번 작성하면, JVM이 설치된 어느 기계에서든 동작할 수 있다' 라는 의미로, 기존 다른 언어들은 고급언어(High-Level Language)를 컴파일한 후 생성되는 실행 파일이 OS 별로 달라야 하는 반면, 자바는 컴파일러로 바이트 코드를 만들고 이 바이트 코드를 JVM을 통해 기계어로 번역하기 때문에 JVM만 있으면 같은 바이트 코드를 어떤 OS에서든 실행 가능하다. 따라서 자바는 바이트 코드와 JVM만 있으면 어떤 하드웨어, 운영체제에서든 실행이 가능한 특징, 즉 이식성(Portability)이 높은 특징을 가진다.

<br/>

### JVM(Java Virtual Machine)이란?

> 컴파일된 코드(바이트 코드)를 실행시켜주는 가상의 컴퓨터, 즉 자바 프로그램 실행환경을 만들어 주는 소프트웨어

- JVM을 사용하면 하나의 바이트 코드로 모든 플랫폼에서 동작할 수 있다.

  예를 들어 C언어로 작성된 `Test.c`를 윈도우 컴파일러를 사용해서 컴파일하면 `Test.exe`가 생성된다. 이 `Test.exe`는 윈도우 컴파일러로 컴파일되었기 때문에 리눅스 운영체제에서는 실행할 수 없고 윈도우에서만 실행 가능하다. 즉 C/C++에서는 컴파일 플랫폼과 타겟 플랫폼이 다를 경우에는 프로그램이 동작하지 않는다. 따라서 만약 이 `Test.exe` 파일을 리눅스 운영체제에서 실행하려면 리눅스 환경을 타겟으로 크로스 컴파일을 해서 리눅스 운영체제에 맞는 실행 파일을 새로 만들어야 한다.

  반면 Java의 경우 각자의 플랫폼에 설치되어 있는 자바 가상 머신(JVM)이 하나의 바이트 코드를 운영체제에 맞는 실행 파일로 바꿔준다. 즉 하나의 바이트 코드가 JVM이 설치되어 있는 모든 플랫폼에서 실행이 가능하다는 것이다. (Java는 플랫폼에 종속적이지 않지만 JVM은 플랫폼에 종속적, 즉 리눅스의 JVM과 윈도우의 JVM은 서로 다름)

- JRE(Java Runtime Environment): JVM과 Java API(Library)로 구성, Java 애플리케이션을 실행할 수 있도록 하는 것으로 javac(자바 컴파일러)과 같은 개발 관련 도구는 JDK에서 제공 → 최종 사용자를 위한 기능 제공
- JDK(Java Development Kit): JRE와 자바 개발에 필요한 툴을 제공, 오라클은 Java11부터 JDK만을 제공 → 개발자를 위한 기능 제공

**JVM의 역할 정리**

1. 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하는 것
2. 프로그램 메모리를 관리하고 최적화하는 것

<br/>
<br/>

### Java 컴파일 과정

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/fd69b823-2f4a-4e6e-b383-d42b668d9906" width="60%"/>

<br/>

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/c2b484eb-c77f-4d9a-afea-64751f01fd38" width="60%">

1. 자바 프로그램 실행 시 JVM은 OS로부터 메모리 할당
2. 자바 컴파일러(javac)가 .java 파일을 컴파일하여 .class 바이트 코드 생성
3. 바이트 코드를 전달받은 Class Loader는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area) 즉 JVM의 메모리에 올림
4. JVM의 Excution Engine은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행 (2가지 방식: 인터프리터 방식, JIT 컴파일러 방식)
5. 실행 중 JVM은 필요에 따라 Thread Synchronization과 GC 같은 관리 작업 수행

<br/>

### 바이트 코드 변환

> 자바 파일(.java)을 자바 컴파일러(javac.exe)를 통해 JVM이 이해할 수 있는 중간 단계의 언어인 바이트 코드(.class)로 바꿔주는 과정, 런타임 시 바이트 코드를 기계어로 바꿔주는 역할은 JVM에서 수행

- **바이트 코드(Byte Code)**: 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법 (즉 컴퓨터가 아닌 JVM에서 돌아가는 실행 프로그램을 위한 이진 표현법)
- `javac source.java(자바 파일 이름)` 명령어 실행 시 `source.class` 파일 생성
- 바이트 코드의 각 명령어는 1바이트 크기의 명령코드(Opcode)와 추가 피연산자(Operand)로 구성

<br/>

### 클래스 로더(Class Loader)

> 바이트 코드 변환 단계에서 생성된 .class 파일은 클래스 로더를 통해 JVM 영역으로 들어감, 즉 런타임 시 처음으로 클래스를 참조할 때 해당 클래스를 로드하고 JVM의 메모리 영역에 배치시키는 역할

- 런타임 시 필요한 클래스만 로딩하는 동적 로딩(Dynamic Loading)으로 여러 클래스 파일들을 링크하고 JVM 위에 적재
- 클래스 로더 세부 동작: **로딩** → **링크**(검증, 준비, 분석) → **초기화**

**로딩(Loading)**

- 바이트 코드를 읽어와 각종 정보들을 Runtime Data Area의 메소드 영역에 저장
- 로딩이 끝나면 해당 클래스 타입의 `Class` 객체를 생성하여 Runtime Data Area의 힙 영역에 저장

**링크(Linking)**

> 바이트 코드를 검증하고 메모리를 할당하는 과정

- 검증(Verify): 바이트 코드가 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사 (클래스 로드 전 과정 중 가장 까다로운 검사를 수행, 가장 복잡하며 시간이 많이 걸림)
- 준비(Prepare): 클래스가 필요로 하는 메모리를 할당 (클래스에 정의된 필드, 메서드 등)
- 분석(Resolve): 심볼릭 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 변경

  \*심볼릭 레퍼런스: 명시적인 메모리 주소가 아닌 이름을 통한 참조

**초기화(Initialization)**

- 링크 과정에서 확보한 메모리 영역의 클래스 변수(`static` 변수)들을 초기화

**클래스 로더 위임 모델**

> 클래스 로더는 하나만 존재하는 것이 아닌 계층적으로 존재하여, 상위 클래스 로더가 가져온 내용을 먼저 확인하고 찾지 못한 경우에는 하위 클래스 로더가 클래스를 로드함

- Bootstrap Class Loader: JVM을 기동할 때 생성, 가장 기본적인 자바 API를 로드
- Extension Class Loader: 기본 자바 API를 제외한 나머지 확장 클래스를 로드
- System Class Loader: 애플리케이션의 클래스들을 로드
- User-Defined Class Loader: 사용자가 직접 생성해서 사용하는 클래스 로더

<br/>

### 실행 엔진(Execution Engine)

> JVM에 적재된 바이트 코드를 자바 실행엔진이 명령어 단위로 하나씩 읽어가며 실행

**실행 엔진이 바이트 코드를 실행하는 2가지 방식**

- **인터프리터 방식**: 바이트 코드를 한 줄씩 읽어서 해석하며 실행하는 방식 → 상대적으로 속도 느림
- **JIT(Just In Time) 컴파일러 방식**: 바이트 코드 전체를 컴파일하여 바이너리 코드(기계어)로 변경한 후 캐싱, 해당 바이트 코드는 더 이상 인터프리팅하지 않고 캐싱된 바이너리 코드로 직접 실행하는 방식 → 인터프리터 방식의 단점을 보완하기 위해 도입

➡️ JVM은 기본적으로 인터프리터 방식을 사용, 내부적으로 특정 메서드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넘을 때에만 JIT 컴파일러 방식 사용 (실제로는 JVM을 만드는 곳에 따라 다양한 방식으로 실행 엔진 최적화)

<br/>

### 런타임 데이터 영역(Runtime Data Area)

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/1dce46f1-0eff-45e8-8f80-96f42e5b4ba7" width="35%"/>

> 런타임 데이터 영역은 JVM이 운영체제로부터 할당받는 메모리 영역으로, PC Register, JVM Stack, Native Method Stack은 쓰레드마다 하나씩 생성되며, Heap, Method는 모든 쓰레드가 공유

**메서드(Method)**

- 클래스 로더의 로딩 과정을 통해 불러온 클래스 저장
- 클래스와 인터페이스에 대한 필드 및 메서드 정보, static 변수, 메서드의 바이트 코드 등이 저장
- **런타임 상수 풀(Runtime Constant Pool)** 포함: 각 클래스와 인터페이스의 상수(`final`), 메서드와 필드에 대한 모든 레퍼런스를 담고 있는 일종의 테이블 → JVM은 런타임 상수 풀에서 특정 메서드나 필드의 실제 메모리 상의 주소를 찾아서 참조
- 메서드 영역에 저장되는 정보
  - Field Information: 멤버 변수의 이름, 데이터 타입, 접근 제어자에 대한 정보
  - Method Information: 메소드의 이름, 반환 타입, 매개변수, 접근 제어자에 대한 정보
  - Type Information: Class/Interface 여부 저장, Type의 속성, 전체 이름, Super Class의 전체 이름

**힙(Heap)**

- `new` 키워드로 런타임에 생성된 객체 인스턴스 저장
- 실행 엔진의 가비지 컬렉터는 보통 힙 영역의 메모리가 부족할 때 작동

➡️ 메소드 영역은 클래스 데이터를 위한 공간, 힙 영역은 객체를 위한 공간으로 모두 GC의 관리 대상

**JVM 스택(Stack)**

- 컴파일 시에 JVM 스택 영역의 크기가 결정됨
- 지역 변수, 파라미터, 반환값, 연산에 사용되는 임시값 등이 저장되는 영역
- 메서드가 실행될 때 마다 하나의 스택 프레임이 생성되어 JVM 스택에 Push되고, 메서드가 종료되면 JVM 스택에서 해당 스택 프레임이 Pop됨

**PC 레지스터(Register)**

- 현재 쓰레드가 수행 중인 명령어의 주소값 저장, 즉 실행할 스택 프레임을 가리키는 포인터를 저장
- ex. 멀티 쓰레드 프로그래밍 환경에서 한 쓰레드가 작업을 하다가 다른 쓰레드로 잠시 CPU 점유를 넘겨주고 다시 돌아왔을 때 어떤 명령어부터 실행을 재개하면 되는지를 기억하기 위해 사용

**네이티브 메서드 스택(Native Method Stack)**

- 자바 이외의 언어(C, C++, 어셈블리 등)로 작성된 네이티브 코드를 실행할 때 사용되는 메모리 영역
- 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 수행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역

<br/>

### 참고

[참고 1](https://ssocoit.tistory.com/270)

[참고 2](https://jaebins.tistory.com/4)

[참고 3](https://ttuk-ttak.tistory.com/38)

[참고 4](https://jungeu1509.github.io/interview/JAVA_Compile/)

[참고 5](https://coding-factory.tistory.com/827)

[참고 6](https://annajinee.tistory.com/42)

[참고 7](https://www.youtube.com/watch?v=VvVruEDCSSY)
