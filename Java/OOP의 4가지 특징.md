# 객체 지향 프로그래밍 (OOP)

> 프로그래밍 패러다임 중 하나로, 상태(state)와 행위(behave)로 이루어진 객체들 간의 상호작용을 통해 프로그램을 설계, 개발하는 것

> 객체 지향 프로그래밍에서 모든 객체는 그 내부에 자료형(Field)과 함수(Method)가 존재한다 → 함수와 자료형을 묶어서 관리할 수 있음

**객체**란?
:point_right: **현실에 존재하는 대상** <br/>
⇒ 우리 주변에 있는 사람, 사물, 동물 모두 객체(object)라 할 수 있음

<br/>

### 장점

1. **코드 재사용 용이**
   &rarr; 모듈화된 객체, 그리고 상속을 통해 코드의 재사용을 높일 수 있다.
   <br/>
2. **유지보수 용이**
   &rarr; 캡슐화로 인해 프로그램 수정, 추가 시에도 주변 코드에 영향이 덜 가기 때문에 유지보수가 용이하다.
   <br/>
3. **생산성 향상**
   &rarr; 독립적인 객체를 사용함으로써 개발의 생산성을 향상시킬 수 있다.
   <br/>
4. **자연적인 모델링 가능**
   &rarr; 현실세계에서 사용하는 개념을 대입하여 생각한 것을 그대로 구현할 수 있다.

<br/>

### 단점

1. **실행 속도가 느림**
   &rarr; 캡슐화와 격리구조 때문에 절차 지향 프로그래밍보다 실행 속도가 느리다.
   <br/>
2. **프로그램 용량이 커질 수 있음**
   &rarr; 객체 단위로 만들다보면 불필요한 정보들이 들어갈 수 있어 프로그램의 용량이 증가될 수 있다.
   <br/>
3. **설계에 많은 시간 소요**
   &rarr; 초기에 클래스별, 객체별, 상속 등의 구조들을 모두 설계해야 하기 때문에 설계 시간이 많이 든다.

<br/>

## OOP의 특징 4가지

![oop.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1841b458-ab4f-4dda-8da4-d008a100027a/oop.png)

1. **추상화 (Abstraction)**

- 객체들의 공통적인 특징(기능, 속성)을 추출해서 정의하는 것 (클래스를 정의하는 것)

&rarr; 실제로 존재하는 객체들을 프로그램으로 만들기 위해 공통적인 특성을 파악한 후, 필요없는 특성을 제거해 하나의 묶음으로 만들어내는 과정
<br/> 2. **캡슐화 (Encapsulation)**

- 관련있는 변수와 함수를 하나의 클래스로 묶고, 외부에서 쉽게 접근할 수 없도록 은닉하는 것

&rarr; 지정자를 private으로 두어 접근에 제한을 둘 수 있다.
&rarr; 캡슐화는 높은 응집도와 낮은 결합도를 유지한다. ⇒ 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 함
<br/> 3. **상속성 (Inheritance)**

- 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

&rarr; 기존 코드를 재활용해서 사용함으로써 코드의 생산성을 높여준다.
but 클래스 간 결합도가 과도하게 높아져 유지보수가 어려움 ⇒ 반드시 기능의 확장 관점으로써 ‘포함 관계(is-a)’ 일 때에만 사용해야 함

① is-a : 부모-자식 클래스 관계처럼 포함 관계를 의미
② has-a : 한 객체가 다른 객체에 속하는 구성 관계(Composition)
⇒ 상속은 자식 클래스를 외부로부터 은닉하는 캡슐화의 개념을 가지고 있음
<br/> 4. **다형성 (Polymorphism)**

- 하나의 변수 또는 함수(클래스의 객체)가 명령을 받았을 때, 상황에 따라 서로 다른 방식으로 동작하는 것

① 오버라이딩 (Overriding) : 부모 클래스의 메소드와 같은 이름을 사용하며 매개변수 개수, 타입이 같아야 함, 내부 소스를 재정의하는 것
② 오버로딩 (Overloading) : 같은 이름의 함수를 여러 개 정의한 후 매개변수를 다르게 하여 같은 이름을 경우에 따라 호출하여 사용하는 것

<br/>

④ **프로세스 독립성** : 각각의 프로세스는 독립된 가상 주소 공간을 가지므로 서로의 메모리에 영향을 미치지 않음. 이는 보안과 안정성 측면에서 중요<br/>
⑤ **유연한 메모리 할당** : 요구페이징은 페이지 단위로 메모리를 할당하므로 메모리 공간을 유연하게 할당할 수 있음<br/>
⑥ **높은 처리량** : 요구페이징은 필요한 페이지만 로드하기 때문에 디스크 I/O작업이 줄어들어 전반적인 처리량이 높아짐

<br/>

### 참고

[[Java] 객체 지향 4가지 특징과 5가지 원칙](https://xangmin.tistory.com/152)
[[Java] OOP(객체 지향 프로그래밍)의 개념과 특징 알아보기](https://only-wanna.tistory.com/entry/OOP%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%8A%B9%EC%A7%95-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)
