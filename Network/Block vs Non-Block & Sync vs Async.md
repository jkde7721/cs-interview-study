<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/f2f18d85-f50e-4e1c-92ff-b6d4df8b51a8" width="80%"/>

<br/>

> 웹 서버 혹은 입출력(I/O) 작업의 수행 방식을 설명하는 개념으로, 블로킹(Block)/논블로킹(Non-Block)은 전체 작업의 흐름 자체에 대한 block 여부, 동기(Sync)/비동기(Async)는 전체 작업에 대한 순차적인 흐름의 유무

## Blocking vs Non-Blocking

- 호출된 함수가 호출한 함수에게 제어권을 건네주는가에 따라 구분
- 다른 요청 작업을 처리하기 위해 현재 작업에 대한 block(차단, 대기) 여부를 나타내는 프로세스의 실행 방식

  _제어권: 함수의 코드나 프로세스의 실행 흐름을 제어할 수 있는 권리_

**Blocking**

- 현재 작업을 모두 중지하고 요청한 작업이 완료되기만을 계속해서 기다림
- 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않아 대기하게 만듦

**Non-Blocking**

- 요청한 작업 실행 중에도 다른 작업 수행 가능
- 호출된 함수가 호출한 함수에게 바로 제어권을 넘겨주어 호출한 함수는 다른 작업 수행 가능

## Synchronous vs Asynchronous

- 호출된 함수의 작업 완료 여부를 누가 신경쓰는가에 따라 구분, 즉 요청한 작업의 완료 여부를 신경 써서 작업을 순차적으로 수행할지 말지에 따라 구분
- 여러 요청 작업을 순차적으로 처리하는가 / 동시적으로 처리하는가에 따라 구분
- 동기는 현재 작업이 완료되어야 다음 작업을 순차적으로 수행하고, 비동기는 현재 작업의 완료 여부를 따지지 않고 바로 다음 작업 수행
- 동기는 요청한 작업에 대해 순서가 지켜지는 반면, 비동기는 무작위 순서로 작업을 실행하여 순서가 지켜지지 않을 수 있음 → 여러 개의 작업을 요청했는데 응답에서 요청 순서가 지켜진다면 동기, 어떤 작업이 먼저 완료될지 모른다면 비동기

**Synchronous**

- 작업에 대한 후속 처리를 내가 직접 하는 경우 (다음 작업 순차적으로 수행)
- 호출된 함수의 작업 완료 여부를 호출한 함수가 계속 확인하며 신경씀

**Asynchronous**

- 작업에 대한 후속 처리를 내가 직접 하지 않고 누군가에게 시키는 경우
- 호출된 함수에게 callback을 전달하여 호출한 함수는 작업 완료 여부를 신경쓰지 않음 (호출된 함수는 작업 완료 후 전달받은 callback을 실행하여 작업 결과 후처리)
- 성능상 이점: 요청한 작업의 완료 여부를 신경쓰지 않고 바로 다음 작업 수행 가능 → I/O 작업과 같이 느린 작업 실행 시 작업 완료를 기다리지 않고 다른 작업을 동시 처리함으로써 전반적인 시스템 성능 향상

<br/>

### Synchronous & Blocking

- 호출된 함수가 작업 완료 시까지 제어권을 넘겨주지 않아 호출한 함수는 다른 작업을 수행하지 못하고 대기하며, 호출된 함수의 작업 완료 후 결과를 반환 받아 처리
- 요청한 작업이 진행되는 동안 자신의 작업을 처리하지 않고(Blocking), 요청한 작업의 완료 여부를 바로 받아 순차적으로 처리하는(Synchronous) 방식
- 요청한 작업의 결과가 현재 작업에 영향을 주는 경우에 활용
- 코드가 순차적으로 실행되는 특성 → 일반적으로 작업이 간단하거나 작업량이 적은 경우에 사용
- 작업량이 많거나 시간이 오래 걸리는 작업을 처리하는 경우 이 방식을 사용하면 한 작업이 끝날 때까지 다른 작업들은 처리가 불가능하여 비효율적
- 실생활 예시

  ```
  팀장이 개발자 1, 2, 3에게 업무 A, B, C를 지시하는 경우
  1. 팀장이 개발자1에게 업무 A 지시 → 개발자1 개발 중
  2. 다른 개발자들은 아무것도 하지 않으면서 대기
  3. 개발자1 개발 완료
  4. 팀장이 개발자2에게 업무 B 지시 → 개발자2 개발 중
  5. 다른 개발자들은 아무것도 하지 않으면서 대기
  6. 개발자2 개발 완료
  7. 팀장이 개발자3에게 업무 C 지시 → 개발자3 개발 중
  8. 다른 개발자들은 아무것도 하지 않으면서 대기
  9. 개발자3 개발 완료
  ```

### Synchronous & Non-Blocking

- 호출된 함수는 바로 제어권을 넘겨주어 호출한 함수는 다른 작업을 수행할 수 있지만, 호출된 함수의 작업 결과 처리를 위해 완료 여부를 계속해서 물어봄
- 요청한 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non-Blocking), 요청한 작업의 결과를 바로 처리하여 작업을 순차적으로 수행하는(Synchronous) 방식
- 자신의 작업을 계속하고 있지만 요청한 작업과의 동기화를 위해 계속해서 요청한 작업의 완료 여부를 조회
- 실생활 예시

  ```
  팀장이 개발자 1, 2, 3에게 업무 A, B, C를 지시하는 경우 (업무 특성상 업무 A, B, C는 순차적으로 처리되어야 함)
  1. 팀장이 개발자1에게 업무 A 지시 → 개발자1 개발 중
  2. 다른 개발자들은 다른 업무를 보고 팀장은 개발자1에게 업무 완료 여부 계속해서 물음
  3. 개발자1 개발 완료 → 팀장에게 보고
  4. 팀장이 개발자2에게 업무 B 지시 → 개발자2 개발 중
  5. 다른 개발자들은 다른 업무를 보고 팀장은 개발자2에게 업무 완료 여부 계속해서 물음
  6. 개발자2 개발 완료 → 팀장에게 보고
  7. 팀장이 개발자3에게 업무 C 지시 → 개발자3 개발 중
  8. 다른 개발자들은 다른 업무를 보고 팀장은 개발자3에게 업무 완료 여부 계속해서 물음
  9. 개발자3 개발 완료 → 팀장에게 보고
  ```

### Asynchronous & Blocking

- 호출된 함수가 작업 완료 시까지 제어권을 넘겨주지 않아 호출한 함수는 다른 작업을 수행하지 못하고 대기하며 호출된 함수의 작업 완료 여부는 신경쓰지 않음
- 요청한 작업이 진행되는 동안 자신의 작업을 멈추고 기다리며(Blocking), 요청한 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는(Asynchronous) 방식
- Blocking으로 다른 작업을 수행하지 못하고 대기하는 마당에 호출된 함수의 작업 결과를 반환 받아 딱히 처리하지도 않음
- Synchronous & Blocking 방식과 성능적으로 거의 차이가 나지 않아 굳이 사용하지 않지만, Asynchronous & Non-Blocking을 구현하다가 의도치 않게 Asynchronous & Blocking으로 동작할 수 있음 (처리하는 작업 중 Blocking으로 동작하는 것이 하나라도 있다면)

### Asynchronous & Non-Blocking

- 호출한 함수는 호출된 함수의 작업 완료 여부를 신경쓰지 않고, 호출된 함수는 바로 제어권을 넘겨주어 호출한 함수는 독립적으로 다른 작업을 수행
- 요청한 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non-Blocking), 요청한 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는(Asynchronous) 방식
- 요청한 작업의 결과가 현재 작업에 영향을 주지 않는 경우에 활용
- 작업량이 많거나 시간이 오래 걸리는 작업을 처리해야 하는 경우에 적합
- 요청한 작업의 완료 여부나 결과에 대한 후처리를 위해 콜백 함수 사용 (비동기 논블로킹을 구현하기 위해 콜백 함수 이외에도 여러 방법 존재 ex. `Promise` 객체, 이벤트 리스너)
- 대용량 데이터나 많은 요청을 처리하는 서비스에서 사용 → 한 작업이 처리되는 동안 다른 작업을 처리할 수 있어 어플리케이션 처리 성능 향상
- 실생활 예시

  ```
  팀장이 개발자 1, 2, 3에게 업무 A, B, C를 지시하는 경우 (업무 A, B, C의 처리 순서는 중요하지 않음)
  1. 팀장이 개발자1, 2, 3에게 각각 업무 A, B, C를 지시
  2. 개발자1, 2, 3은 개발 중
  3. 팀장은 다른 업무 수행 중
  4. 개발자3 개발 완료 → 팀장에게 보고
  5. 개발자1 개발 완료 → 팀장에게 보고
  6. 개발자2 개발 완료 → 팀장에게 보고
  ```

➡️ 성능과 자원의 효율적 사용 관점에서 가장 유리한 모델은 `Asyncronous & Non-Blocking` 방식

<br/>

### 참고

[읽어보기 추천](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)

[Block vs Non-Block & Sync vs Async 1](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/index.html)

[Block vs Non-Block & Sync vs Async 2](https://gyoogle.dev/blog/computer-science/network/Blocking,Non-blocking%20&%20Synchronous,Asynchronous.html)

[Block vs Non-Block & Sync vs Async 3](https://mgyo.tistory.com/825)

### Advanced

[Async & Spring](https://www.youtube.com/watch?v=HKlUvCv9hvA)
