## 대칭키 & 공개키

### 대칭키 (Symmetric Key)

> 암호화와 복호화에 **같은 암호키(대칭키)** 를 사용하는 알고리즘, 오직 1개의 키만 사용

![enter image description here](https://velog.velcdn.com/images/yanghl98/post/9234af28-eccf-47ff-81fe-9b5903181be8/image.png)

- Session Key, Secret Key, Shared Key 라고도 함
- 대표적 알고리즘 : DES, 3DES, AES, SEED, ARIA 등
- 기밀성을 제공하나 무결성, 인증, 부인 방지를 보장하지 않음

- 장점

  ① 공개키 암호화 방식에 비해 암호화 및 복호화 속도가 빠르다

  ② 비교적 간단하고 암호화에 필요한 키의 길이가 짧다

  ③ 대용량 Data 암호화에 적합하다

- 단점

  ① 암호화 통신을 하는 사용자끼리 같은 대칭키를 공유해야 한다 (키 교환 문제)

  ② 키를 교환하는 과정에서 키가 탈취될 수 있다 => 해킹의 위험에 노출될 수 있다

  ③ 관리해야 할 키의 개수가 방대해진다

-> 해당 단점을 해결하기 위한 방법으로 키의 사전 공유, 키 배포 센터 사용, Diffie-Hellman 키 교환, 공개키 암호화 방식 등이 있다.

<br/>

### 공개키 (Public Key)

> 암호화와 복호화에 사용하는 **암호키를 분리**한 알고리즘, 대중에게 공개하는 **공개키**와 암호화된 데이터를 복호화하는 **비밀키** 두 개가 존재함

![enter image description here](https://velog.velcdn.com/images/yanghl98/post/ab98a5ad-ff59-4c66-b85c-c37440146b52/image.png)

- 비대칭키라고도 함
- 대표적 알고리즘 : Diffie-Hellman, RSA, DSA, ECC 등
- 기밀성을 제공하나 무결성, 인증, 부인 방지를 보장하지 않음

  - Diffie-Hellman : 최초의 공개키 알고리즘, 위조에 취약
  - RSA : 대표적 공개키 알고리즘
  - DSA : 전자 서명 알고리즘 표준
  - ECC : 짧은 키로 높은 암호 강도, 빠른 구현 가능 PDA, 스마트폰 등에 사용

- 장점

  ① 수신자의 비밀키(개인키)로만 해독할 수 있으므로 안전하다

  ② 기밀성 / 인증 / 부인 방지 기능 제공

  ③ 대칭키 암호화보다 키 분배 및 관리가 쉽다

  ④ 대칭키 암호화보다 확장 가능성이 더 높다

- 단점

  ① 대칭키 암호화 방식에 비행 속도가 느리다

  ② 암호화에 필요한 키의 길이가 길다

  ③ 암호화 / 복호화 연산이 매우 복잡하다

- 방식

  ① **암호 모드** : 송신자 공개키로 암호화 -> 송신자 개인키(비밀키)로 복호화

  ➡️ 소량의 메시지 암호화 목적, 주로 키 교환의 용도로 사용

  ② **인증 모드** : 송신자 개인키(비밀키)로 암호화 -> 송신자 공개키로 복호화

  ➡️ 메시지를 인증(부인방지)하는 것이 목적

<br/>

### 암호화/복호화 시나리오

#### **대칭키 (Symmetric Key) 암호화 시나리오**

① A는 사전에 공유된 대칭키로 데이터를 암호화하여 B에게 전송한다.

② B는 같은 대칭키로 데이터를 복호화한다.

<br/>

#### **공개키 (Public Key) 암호화 시나리오**

① A가 웹 상에 공개된 B의 공개키를 이용하여 평문을 암호화한다.

② 이 암호문 (CiperText)는 B가 개인적으로 가지고 있는 B의 비밀키로만 복호화가 가능하다. B는 자신의 비밀키로 복호화한 평문을 확인하고 A의 공개키로 응답을 암호화하여 A에게 보낸다.

③ A는 A의 비밀키로 암호화된 응답문을 복호화한다.

<br/>

#### **이론적으로 완벽한 암호화 시나리오 (대칭키+공개키)**

> 대칭키를 주고 받을 때만 공개키 암호화 방식을 사용하고, 이후에는 계속 대칭키 암호화 방식으로 통신하는 것

① A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하여 B에게 보낸다.

② B는 암호문을 받아 자신(B)의 비밀키로 복호화한다.

③ B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보낸다.

④ A는 자신의 대칭키로 암호문을 복호화한다.

⑤ 계속 대칭키로 암호화 통신을 한다.

=> 이 방식이 바로 SSL(Secure Socket Layer)의 시초가 되었음

<br/>

### 참고

[[Network] 대칭키/공개키](https://velog.io/@yanghl98/Network-%EB%8C%80%EC%B9%AD%ED%82%A4%EA%B3%B5%EA%B0%9C%ED%82%A4-Symmetric-KeyPublic-Key)

[[Network] 대칭키vs공개키 암호화](https://imjeongwoo.tistory.com/83)
