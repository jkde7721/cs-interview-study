## WEB 면접 질문 리스트

<details>
    <summary>GET/POST 또는 POST/PUT 메소드의 차이점을 메소드 속성(안전, 멱등성, 캐시 가능)을 중심으로 설명해주세요.</summary>
    <br/>
<div markdown="1">       
GET 메소드는 CRUD연산 중 Read에 해당하고 URI가 가진 정보를 검색하기 위한 요청을 하기 위해 사용합니다. 요청을 전송할 때 필요한 데이터를 Body에 담지 않고 쿼리스트링을 통해 전송합니다. 또 GET은 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있습니다. css, 이미지 같은 정적 컨텐츠는 데이터양이 크고, 변경될 일이 적어서 반복해서 동일한 요청을 보낼 필요가 없기 때문에 GET을 많이 사용합니다. 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해두고, 동일한 요청이 발생할 때 서버로 요청을 보내지 않고 캐시된 데이터를 사용할 수 있기 때문입니다. 따라서 POST와 달리 여러 번 요청하더라도 응답값이 똑같은 멱등성을 가지고 있습니다.
</div>
<br/>
<div markdown="1">       
POST 메소드는 CRUD 연산 중 Create에 해당하고 클라이언트가 정보를 입력하여 서버로 해당 정보를 전달할 때 사용합니다. POST 방식은 리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 전송해야 할 데이터를 HTTP 메세지의 Body에 담아 전송합니다. 이처럼 POST는 데이터가 Body로 전송되고 내용이 눈에 보이지 않아 GET보다는 보안적인 면에서 안전합니다. 또 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 하고 리소스를 새로 생성하거나 업데이트할 때 사용되기 때문에 멱등성을 가지고 있지 않습니다.
</div>
</details>

<br/>
<details>
    <summary>동일 출처 정책이나 CORS에서의 출처란 무엇인지 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
POST 메소드는 CRUD 연산 중 Create에 해당하고 클라이언트가 정보를 입력하여 서버로 해당 정보를 전달할 때 사용합니다. POST 방식은 리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 전송해야 할 데이터를 HTTP 메세지의 Body에 담아 전송합니다. 이처럼 POST는 데이터가 Body로 전송되고 내용이 눈에 보이지 않아 GET보다는 보안적인 면에서 안전합니다. 또 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 하고 리소스를 새로 생성하거나 업데이트할 때 사용되기 때문에 멱등성을 가지고 있지 않습니다.
</div>
</details>

<br/>
<details>
    <summary>브라우저의 기본 동작 과정에 대해 말씀해주시고 CORS 작동 방식 3가지 시나리오 중 1가지에 대해 자세히 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
브라우저의 CORS 기본 동작에 대해 말씀드리겠습니다. 우선 웹 클라이언트는 HTTP 프로토콜을 이용하여 서버에 요청을 보내게 됩니다. 이때 브라우저는 HTTP 요청 헤더에 Origin이라는 필드에 자신의 출처를 함께 담아 보냅니다. 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더에 Access-Control-Allow-Origin이라는 필드를 추가하고 해당 필드의 값으로 이 리소스를 접근하는 것이 허용된 출처 URL을 넣어 보냅니다. 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해 본 후 차단할지 말지를 결정합니다. 값이 다르다면 해당 응답을 사용하지 않고 버립니다. 이때 CORS에러가 발생합니다. 값이 같다면 유효하기 때문에 다른 출처의 리소스를 문제없이 가져올 수 있습니다.
</div>
<br/>
<div markdown="1">       
CORS 작동 방식에는 예비 요청, 단순 요청, 인증된 요청 3가지 시나리오가 있습니다. 저는 그중에서 예비 요청에 대해 자세히 말씀드리겠습니다. 예비 요청 방식은 브라우저에서 요청을 보낼 때 한 번에 바로 보내지 않고 먼저 예비 요청을 보내 서버와 잘 통신되는지 확인한 후 본 요청을 보내는 것을 의미합니다. 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 미리 확인하는 것입니다. 이때 예비요청의 HTTP 메소드를 GET이나 POST가 아닌 OPTIONS라는 요청이 사용된다는 특징을 가지고 있습니다. 이 예비 요청은 실제 요청에 걸리는 시간이 늘어나게 되어 어플리케이션 성능에 영향을 미치는 단점을 가지고 있습니다. 또한 수행하는 API 호출 수가 많으면 많을수록 예비 요청으로 인해 서버 요청을 배로 보내게 되어 비용적 측면에서도 부담이 됩니다. 이는 브라우저 캐시를 이용해 서버 응답의 Access-Control-Max-Age 헤더에 캐시될 시간을 명시해주면 이 예비 요청을 캐싱시켜 최적화시키는 것으로 어느정도 해결할 수 있습니다.
</div>
</details>

<br/>
<details>
    <summary>웹소켓과 HTTP의 차이점은 무엇인가요?</summary>
    <br/>
<div markdown="1">       
웹 소켓은 서버와 클라이언트 간의 메시지 교환을 위한 통신 규약입니다. 웹 소켓은 Socket Connection을 유지한 채로 실시간으로 양방향 통신 및 데이터 전송이 가능합니다. 또한 서버와 클라이언트가 한 번 연결되면 계속 같은 라인으로 통신하여 상태를 유지할 수 있고 TCP Connection 비용을 아낄 수 있습니다. HTTP 또한 클라이언트와 서버 간 통신을 위한 통신 규칙 세트 또는 프로토콜을 의미합니다. 하지만 웹 소켓과 달리 단방향 통신이고 기본적으로 무상태 (stateless)이므로 상태를 저장하지 않습니다. 클라이언트에서 서버로 Request를 보내면 서버는 클라이언트로 Response를 보내는 방식으로 동작합니다.
</div>
</details>

<br/>
<details>
    <summary>REST에서 URI가 무엇인지 설명해주세요.</summary>
    <br/>
<div markdown="1">       
REST에서의 URI는 Uniform Resource Identifier의 약자로 인터넷 상의 자원을 식별하기 위한 문자열의 구성을 의미합니다. URI는 인터넷 상 자원의 위치를 의미하는 URL을 포함합니다.
</div>
</details>

<br/>
<details>
    <summary>REST의 설계 규칙에 대해 간단하게 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
< REST API 설계 기본 규칙 >

1.  URI는 명사를 사용한다.
2.  슬래시 구분자(/ )는 계층 관계를 나타내는데 사용한다.
3.  URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.
4.  밑줄( \_ )을 사용하지 않고, URI 가독성을 높일 수 있는 하이픈( - )을 사용한다.
5.  URI 경로는 소문자로만 구성한다.
6.  HTTP 응답 상태 코드 사용한다.
7.  파일확장자는 URI에 포함하지 않는다.
</div>

</details>

<br/>
<details>
    <summary>REST API 와 RESTful API의 차이점과 궁극적으로 RESTful API의 목적이 무엇인지에 대해 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
REST API는 자원을 이름으로 구분해 해당 자원의 상태 및 정보를 주고 받는 모든 것을 의미하는 REST를 기반으로 만들어진 API입니다. 최근 OpenAPI, 마이크로 서비스 등은 모두 REST API 형태로 제공되고 있습니다. RESTful API는 REST의 원리를 따르는 시스템을 의미합니다. 하지만 REST를 사용하였다고 하여 모두 RESTful한 것이 아니라 REST API의 설계 규칙을 잘 지켜서 설계된 API만이 RESTful API입니다.
</div>
<br/>
<div markdown="1">       
이를 바탕으로 궁극적인 RESTful API의 목적은 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것입니다. 근본적인 목적은 성능 향상이 아니라 일관적인 컨벤션을 통해 API의 이해도 및 호환성을 높이는 것입니다.
</div>
</details>

<br/>
<details>
    <summary>JWT Process에서 Refresh Token의 역할과 JWT의 어떤 단점을 어떻게 보완하는 지에 대해 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
JWT란 JSON Web Token의 약자로 JSON 데이터 구조로 표현한 Token에 인증에 필요한 정보들을 담은 후 암호화하여 사용하는 서명된 토큰입니다. 서버와 클라이언트 간 정보를 주고 받을 때, HTTP 리퀘스트 헤더에 JSON 토큰을 넣은 후에 서버는 별도의 인증 과정 없이 헤더에 포함되어 있는 JWT 정보를 통해 인증합니다.
</div>
<br/>
<div markdown="1">       
이러한 JWT 과정에서 Refresh Token은 기존에 발급한 Access Token이 만료 시 해당 토큰의 유효 기간을 연장하기 위한 토큰 역할을 합니다. 해당 Refresh token으로 Access Token을 새로 발급할 수 있기 때문에 토큰을 탈취당할 수 있는 JWT 단점을 보완할 수 있습니다. 토큰을 탈취당했을 경우 만료될 때까지 대처가 불가능합니다. 이를 해결하기 위해 token의 만료 시간을 짧게 설정하고 JWT를 처음 발급할 때 Access Token과 함께 Refresh Token을 발급하여 탈취 위험과 짧은 만료 시간 또한 해결할 수 있습니다. 
</div>
</details>

<br/>
<details>
    <summary>JWT를 활용한 적이 있다면 활용했던 경험에 대해 말씀해주시고 없다면 어떤 경우에 사용하는 것이 좋은 지 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
저는 앱 개발을 하면서 JWT를 활용한 경험이 있습니다. 사용자가 id와 password를 입력하여 로그인 시도 시 해당 요청을 서버에게 보내줍니다. 서버는 Access token을 발급하고 JWT 토큰을 클라이언트 측인 저에게 넘겨줍니다. 저는 해당 토큰을 API 요청 시 Authourization header에 담아서 보냅니다. 이렇게 JWT를 활용하여 별도의 인증 과정없이 수월하게 데이터를 주고받을 수 있었습니다. 
</div>
</details>

<br/>
<details>
    <summary>CSR이 무엇인지 그리고 장단점에 대해 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
CSR은 Client Side Rendering의 약자로 최초 로딩시 서버에서 HTML파일을 보내주고 HTML에 링크된 CSS, JavaScript 등 각종 리소스들을 받아와 프론트에서 동적으로 렌더링하는 것입니다. 이는 서버측에서 렌더링을 하는 SSR과 달리 클라이언트 측에서 렌더링을 합니다. CSR의 장점은 최초 로딩을 오래 걸리지만 그 이후는 빠른 페이지 전화이 가능하다는 것입니다. 또 매 페이지 이동마다 새롭게 서버에게 완성된 HTML을 요청하는 것이 아니라 필요한 데이터만 요청하여 서버의 부담을 줄이고 효율성을 높일 수 있습니다. CSR의 단점은 최초 로딩 시 모든 리소스들을 받아와 렌더링하기 때문에 초기 로딩 속도가 느리다는 것입니다. 또한 초기에 받아온 HTML파일에는 어플리케이션에 필요한 JS링크만 들어있고 데이터는 비어있기 때문에 검색엔진이 웹페이지를 분석하기 어렵습니다.
</div>
</details>

<br/>
<details>
    <summary>CSR과 SSR에 대해 서버 자원 사용과 SEO 관점에서 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
CSR은 매 페이지 이동마다 새롭게 서버에게 완성된 HTML을 요청하는 것이 아니라 필요한 데이터만 요청하여 서버의 부담이 적지만, SSR은 페이지를 이동할 때마다 서버에게 요청을 하여 전체적인 웹 사이트를 가져오기 때문에 깜빡임 현상이 발생하고 서버의 부하가 증가합니다.
</div>
<br/>
<div markdown="1">       
SEO는 Search Engine Optimization의 약자로 웹 사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정입니다. SEO를 위해서는 서버에서 클라이언트로 완전한 HTML 페이지를 내려줘야 하기 때문에 SSR에서는 SEO가 가능하지만 CSR에서는 SEO가 불가능합니다. 
</div>
</details>

<br/>
<details>
    <summary>Cookie와 Session이 각각 무엇인지와 둘의 차이점에 대해 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
Cookie는 HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. Session은 방문자가 서버에 접속해 있는 상태를 하나의 단위로 보고 이를 세션이라고 합니다. 쿠키와 세션에는 4가지 큰 차이점이 있습니다. 첫번째는 라이프 사이클입니다. 쿠키는 파일로 저장되기 때문에 브라우저를 종료해도 정보가 유지될 수 있습니다. 또한 만료 기간을 따로 지정해 쿠키를 삭제할 때까지 유지할 수 있습니다. 하지만 세션은 만료 기간을 정할 수는 있지만, 브라우저가 종료되면 만료 기간에 상관없이 삭제가 됩니다. 두번째는 사용자의 정보가 저장되는 위치입니다. 쿠키는 서버의 자원을 전혀 사용하지 않지만, 세션은 서버의 자원을 사용합니다. 세번째는 보안입니다. 쿠키는 클라이언트 로컬에 저장되기 때문에 변질될 수 있고 Request할 때 스니핑 당할 우려가 있어서 보안에 취약합니다. 하지만 세션은 쿠키를 이용해서 Session ID만 저장하고 그것으로 구분하여 서버에서 처리하기 때문에 비교적 보안성이 높습니다. 마지막으로 속도차이가 있습니다. 쿠키는 쿠키에 정보가 있기 때문에 서버에게 요청 시 속도가 빠릅니다. 하지만 세션은 정보가 서버에 있기 때문에 요청 처리가 요구되어 비교적 속도가 느립니다.
</div>
</details>

<br/>
<details>
    <summary>Cookie의 동작 순서에 대해 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
① 클라이언트가 페이지를 요청 (사용자가 웹사이트에 접근)<br/>

② 서버는 쿠키를 생성

③ HTTP 헤더에 쿠키를 포함시켜 응답

④ 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음

⑤ 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄

⑥ 서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때 쿠키를 업데이트하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

</div>
</details>

<br/>
<details>
    <summary>Web Server와 WAS의 차이점에 대해 간략히 설명해주세요.</summary>
    <br/>
<div markdown="1">       
Web Server는 HTTP 프로토콜을 기반으로 클라이언트가 요청한 정적 리소스를 제공하는 서버입니다. 정적 리소스 제공이 주요 기능이고 애플리케이션 로직 같은 동적인 처리가 필요한 경우에는 웹 애플리케이션을 호출합니다. 이에 반면 WAS는 DB 조회 혹은 다양한 로직 처리를 요구하는 동적 컨텐츠를 제공하기 위한 서버입니다. 요청에 따라 DB에서 데이터를 조회하거나 비즈니스 로직을 수행하여 결과를 만들어 응답하기에 자원의 효율적인 사용이 가능합니다. 간단하게 차이점에 대해 정리한다면 웹 서버는 정적인 데이터를 처리하는 서버이고 WAS는 동적인 데이터를 위주로 처리하는 서버입니다. 
</div>
</details>

<br/>
<details>
    <summary>WAS가 Web Server의 역할을 할 수 있음에도 불구하고 Web Server와 WAS를 조합하여 시스템을 구축하는 이유와 이러한 시스템의 장점에 대해 설명해주세요.</summary>
    <br/>
<div markdown="1">       
WAS가 Web Server의 역할까지 수행할 수 있지만, WAS가 정적 콘텐츠 요청까지 처리하게 된다면, 부하가 커지고 동적 컨텐츠 처리가 지연되면서 수행 속도가 느려지게 될 것입니다. 이에 따라 페이지 노출 시간이 늘어나는 문제가 발생하여 효율성 또한 크게 떨어지게 됩니다. 따라서 WAS는 DB 조회 및 다양한 로직을 처리하는데 집중을 해야 하는 만큼 단순한 정적 콘텐츠는 웹 서버에게 맡기면 기능을 분리하여 서버 부하를 방지해주어야 합니다. 이를 통해 효율적인 리소스 관리가 가능해지고 물리적으로 분리하여 보안을 강화할 수 있는 장점을 가질 수 있습니다. 또한 장애 극복 및 대응에도 유리합니다. 
</div>
</details>
