## Operating System 면접 질문 리스트

<details>
    <summary>프로세스의 주소공간은 어떻게 구성되어있는지 설명해주세요.</summary>
    <br/>
<div markdown="1">       
프로세스의 주소 공간은 크게 stack 영역, heap 영역, data 영역, text(code)영역으로 구성되어 있습니다.(높은 주소 → 낮은 주소)
</div>
<br/>
<div markdown="1">
→ stack 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다. stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다. 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.<br/>

→ heap 영역은 런타임의 크기가 결정되는 영역입니다. 사용자에 의해 공간이 동적으로 할당 및 해제됩니다. 주로 참조형 데이터의 데이터가 할당되고 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.<br/>

→ data 영역은 전역 변수나 static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역입니다. 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다. (어떤 프로그램에 전역/static 변수를 참조하는 코드가 존재한다면, 이 프로그램은 컴파일 된 후에 data 영역을 참조하게 합니다.)<br/>

→ text영역은 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간으로 프로그램이 수정되면 안되므로 ReadOnly 상태로 저장되어 있습니다.<br/>

</div>
</details>

<br/>
<details>
    <summary>프로세스의 주소공간에서 왜 Stack 부분과 Data 부분을 나누어서 구성했는지 설명해주세요.</summary>
    <br/>
<div markdown="1">       
Stack 영역과 Data 영역을 구분한 가장 큰 이유는 역할의 분배를 위해서 입니다. Stack 영역을 통해 함수의 흐름을 관리하고, Data 영역을 통해 전역 변수, static 변수를 관리합니다. 또 다른 이유는 Data 영역의 데이터 공유를 위해서입니다. 한 프로세스가 여러 개의 스레드를 갖는다면, 각각의 스레드는 스레드 내에서 수행되는 함수의 흐름을 각각 관리하기 위해 자신만의 stack 영역을 갖습니다. 이때 Data 영역의 동일한 내용은 공유함으로써 똑같은 공간을 여러 개 만들지 않고 메모리를 절약할 수 있기 때문에 Stack과 Data를 나눠서 구성하였습니다.
</div>
</details>

<br/>
<details>
    <summary>PCB가 Context Switching 과정에서 왜 필요한지 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
Context Switching은 CPU가 현재 작업 중인 프로세스에서 다른 프로세스로 넘어갈 때, 이전의 프로세스 정보를 PCB에 저장하고 새롭게 실행할 프로세스의 정보를 PCB에서 읽어와 레지스터에 적재하는 과정입니다. 이처럼 Context Switching은 기존 프로세스의 상태를 어딘가에 저장해둬야 다음에 똑같은 작업을 이어서 할 수 있고 새로 해야 할 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결정할 수 있어야 합니다. 이는 프로세스에 관한 모든 정보를 저장하는 임시 저장소 PCB를 사용하여 실행중인 프로세스 상태를 저장하고 앞으로 실행할 프로세스 상태를 저장하며 수월하게 진행할 수 있기 때문에 PCB가 Context Switching 과정에 필요합니다. 
</div>
</details>

<br/>
<details>
    <summary>Context Switching은 언제 발생하는지 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
Context Switching은 CPU가 동시에 수행하는 것처럼 보이게 하기 위해 여러 개의 프로세스를 바꿔가며 실행하기 위해서 필요합니다. 그렇기 때문에 CPU 스케줄링에 의해 할당된 작업 시간이 끝나 timeout이 발생했을 때나 프로세스의 작업이 끝났을 때 발생합니다. 또 실행 중이던 프로세스가 입출력 요청을 할 때 발생합니다. 
</div>
</details>

<br/>
<details>
    <summary>CPU 스케줄링이 발생하는 시기에 대해 CPU 반납 방식과 관련하여 설명해주세요.</summary>
    <br/>
<div markdown="1">       
CPU 스케줄링은 여러 프로세스들의 실행 순서를 어떻게 정하고 얼만큼의 시간을 할당할 것인가를 결정하는 과정입니다.

⇒ CPU 스케줄링은 프로세스가 입/출력을 요구할 때나 프로세스가 종료를 요구할 때 발생합니다. 해당 경우들은 프로세스 스스로의 요구에 의해 이루어지는 자율적 CPU 반납입니다. 또한 높은 우선순위의 프로세스가 나타났을 때나 한 프로세스가 연속해서 CPU를 사용할 수 있는 최대 시간을 초과한 경우에서도 CPU 스케줄리이 발생합니다. 이러한 경우들은 외부 상황에 따라 CPU를 강제로 회수당하는 타율적 CPU 반납에 속합니다.

</div>
</details>

<br/>
<details>
    <summary>여러 CPU 스케줄링 알고리즘 중 1개를 선택하여 자세히 설명해주세요.</summary>
    <br/>
<div markdown="1">       
CPU 스케줄링은 CPU 반납 방식의 자율성 및 타율성 여부에 따라 어떤 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 없는 방식인 비선점형 스케줄링과 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 이를 강제로 뺏을 수 있는 방식인 선점형 스케줄링으로 나눌 수 있습니다. 이중 선점형 스케줄링에 해당하는 라운드 로빈에 대해 말씀드리겠습니다. 라운드 로빈은 현대 컴퓨터가 사용하는 우선순위 스케줄링으로 모든 프로세스에 동일한 최대 CPU 점유 시간을 설정하고, 처리 중인 프로세스의 CPU 실행 시간이 타임 퀀텀(프로세스에 CPU가 할당되는 일정한 시간)을 초과하면 CPU를 강제로 회수하여 다음 프로세스에 할당하는 방식으로 진행됩니다. 모든 프로세스들에게 CPU가 할당될 기회가 동일하게 주어지므로 대화형 시스템 환경에 적합하고 응답 시간을 빠르게 할 수 있다는 장점을 가지고 있습니다. 하지만 할당 시간이 길면 FCFS처럼 작동하고 반대로 할당 시간이 너무 짧으면 context switching이 자주 발생하여 시스템 오버헤드 증가하여 전체적인 처리율 감소합니다. 해당 스케줄링은 평균 대기 시간을 줄일 수 있지만 다음 프로세스의 CPU burst time을 예측하는 것이 어렵다는 문제가 존재합니다.
</div>
</details>

<br/>
<details>
    <summary>인터럽트가 무엇인지, 왜 사용하는지 설명해주세요.</summary>
    <br/>
<div markdown="1">       
인터럽트는 프로그램의 실행 중 CPU의 현재 처리 순서를 중단시키고 다른 동작을 수행하도록 요구하는 기능입니다. 즉, 현재 실행 중인 일보다 더 중요한 일이 발생하면 해당 일을 우선적으로 수행할 수 있도록 해줍니다. 또한 고속 CPU와 저속 Device 간 처리 효율을 향상하여 시스템 효율성을 개선하고 비정상 상태 발생 시 수행 결과 저장 및 복구를 수행하여 시스템 안정성을 개선할 수 있기에 사용합니다.
</div>
</details>

<br/>
<details>
    <summary>인터럽트의 발생 시 수행 과정을 말씀해주세요.</summary>
    <br/>
<div markdown="1">       
인터럽트 수행 과정은 요청, 중단, 보관, 인터럽트 처리, 재개 순으로 진행됩니다. 우선 장치가 인터럽트 시그널을 CPU로 보냅니다. CPU는 현재 수행 중인 명령어까지는 완료하고 그 후 대기 중인 인터럽트 요청이 있는지 확인하고 있을 경우 제어를 인터럽트 루틴으로 넘기기 위한 준비를 합니다. 그리고 처리하던 작업에 대한 정보를 PCB에 저장하고 인터럽트 벡터를 읽어 ISR 주소값을 얻습니다. 해당 주소로 가서 인터럽트 서비스 루틴을 실행합니다. 처리가 완료되면 PCB를 참고하여 인터럽트 발생 이전으로 복구시킨 후 하던 일을 마무리합니다.
</div>
</details>

<br/>
<details>
    <summary>시스템 콜이 필요한 이유는 무엇인가요?</summary>
    <br/>
<div markdown="1">       
시스템 콜은 운영 체제의 커널이 제공하는 서비스에 대해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스입니다. 저희가 일반적으로 사용하는 프로그램은 응용 프로그램입니다. 유저레벨의 프로그램은 유저레벨의 함수들만으로는 많은 기능을 구현하기 어렵기 때문에 커널의 도움을 반드시 받아야 합니다. 이러한 작업은 응용프로그램으로 대표되는 유저 프로세스의 유저 모드에서는 수행할 수 없습니다. 따라서 반드시 커널에 관련된 것은 커널 모드로 전환 후에야 해당 작업을 수행할 권한이 생기기 때문에 시스템 콜이 필요합니다.
</div>
</details>

<br/>
<details>
    <summary>CPU모드의 2가지 종류인 커널 모드와 사용자 모드에 대해 설명해주세요..</summary>
    <br/>
<div markdown="1">       
CPU는 사용자 어플리케이션이 시스템을 손상시키는 것을 방지하기 위해 2가지 모드를 제공합니다. CPU에 있는 Mode bit로 모드를 구분하여 0은 커널 모드, 1은 사용자 모드로 나뉘어서 구동됩니다. 커널 모드는 드라이버, 메모리, CPU 등의 모든 자원에 접근 및 명령을 할 수 있는 모드입니다. 즉, 운영체제가 CPU를 사용하는 모드입니다. 시스템 콜을 통해 커널 모드로 전환되면 운영체제는 하드웨어를 제어하는 명령어를 실행합니다. 사용자 모드는 사용자가 접근할 수 있는 영역을 제한적으로 두고 프로그램의 자원에 함부로 침범하지 못하는 모드입니다. 해당 모드에서 애플리케이션 코드가 실행되고 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 디스크, I/O 등의 하드웨어에 직접적으로 접근할 수 없습니다. 접근을 위해서는 시스템 콜을 사용해야 합니다.

→ 사용자 프로세스는 사용자 모드에서 실행되다가 시스템 자원을 사용해야 할 때 시스템 콜을 호출하여 커널 모드로 전환되어 작업을 수행하고 완료 시 다시 사용자 모드로 전환된다.

</div>
</details>
