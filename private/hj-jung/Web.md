## Web 면접 질문 리스트
- **SSL handshake 단계에서 서버와 클라이언트가 같은 세션키를 공유하게 되는 과정을 키 암호화를 중심으로 설명해주세요. <br/>
(클라이언트가 어떻게 서버를 신뢰할 수 있을까? 클라이언트가 어떻게 서버의 공개키를 얻을 수 있을까? 생각해보기)**
  - SSL 인증서를 통해 클라이언트와 서버 간 통신 보증
  1. 클라이언트가 서버에 요청
  2. 서버는 클라이언트의 요청에 대해 응답
    - 이 때, 클라이언트와 서버 간 정보 교환 시 사용할 암호화 방식 선택
    - 서버가 클라이언트에게 인증서 전달 이를 활용해 클라는 서버의 공개키 획득
  3. 클라이언트는 서버의 인증서가 공인된 CA에 의해 발급된 것인지 확인하여 신뢰성 획득
    - 클라이언트에 내장된 해당 CA의 공개키로 복호화하여 인증서가 해당 CA에 의해 발급된 것인지 확인
    - 클라는 서버데이터+자기데이터 조합하여 대칭키를 만드는데 사용되는 pre master secret키 생성
    - 인증서에 포함된 서버 공개키로 pre master secret값을 암호화하여 서버로 전달 -> 서버 비밀키로만 공개키 암호화를 안전하게 복호화 가능
  4. 서버는 클라가 전송한 암호화된 pre master secret 값을 자신(서버)의 비밀키로 복호화
    - 서버와 클라는 (pre master secret -> master secret -> session key) 과정 거쳐 대칭키인 같은 세션키 공유
  - 1-1. 클라이언트에 내장된 해당 CA의 공개키를 이용해 복호화 성공 시, 해당 인증서가 믿을 수 있는 인증 기관에 의해서 발급되었음을 보증
  - 1-2. 클라이언트는 서버의 공개키가 포함된 SSL 인증서를 통해 공개키 획득
<br/>

- **GET/POST 또는 POST/PUT 메소드의 차이점을 메소드 속성(안전, 멱등성, 캐시 가능)을 중심으로 설명해주세요.**
  - GET
    - 안전O : 호출해도 리소스를 변경하지 않음
    - 멱등성O : 여러 번 조회해도 같은 결과가 조회됨
    - 캐시 가능O : 응답 결과를 클라이언트에서 캐시해서 사용해도 되는 특성 - 실무에서 주로 활용됨
  - POST
    - 안전X : 호출하면 리소스가 변경함
    - 멱등성X : 두 번 호출하면 리소스가 중복 생성. (ex. 같은 결제 중복 생성)
    - 캐시 가능O : 응답 결과를 클라이언트에서 캐시해서 사용해도 되는 특성 - 구현 어려워서 실무에서 주로 활용X
  - PUT
    - 안전X : 호출하면 리소스가 변경함
    - 멱등성O : 같은 요청을 여러 번해도 최종 결과 동일 - 기존 요청 결과에 계속해서 덮어씀
    - 캐시 가능X : 응답 결과를 클라이언트에서 캐시해서 사용해도 되는 특성 - 구현 어려워서 실무에서 주로 활용X
<br/>

- **동일 출처 정책이나 CORS에서의 출처란 무엇인지 말씀해주세요.**
  - 출처 = Protocol + Host + Port까지 모두 합친 URL
  - 동일 출처 정책 : 동일한 출처에서만 리소스를 공유할 수 있다. 에서의 동일 기준. 다른 출처 공격 예방
  - 교차 출처 리소스 공유(CORS) : 다른 출처의 리소스도 허용. 이 때, 출처 비교와 차단은 클라가!
<br/>

- **브라우저의 기본 동작 과정에 대해 말씀해주시고 CORS 작동 방식 3가지 시나리오 중 1가지에 대해 자세히 말씀해주세요.**
  - 단순 요청
    - 예비 요청을 생략하고 바로 서버에 직행으로 본 요청을 보낸 후, 서버가 이에 대한 응답의 헤더에 'Access-Control-Allow-Oirgin' 헤더를 보내주면 그 때, 브라우저가 CORS 정책 위반 여부를 검사하는 방식
    - 간단한 만큼 특정 조건을 만족하는 경우에만 이 시나리오 사용 가능
    > - 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다
      - Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width 헤더일 경우에만 적용된다.
      - Content-Type 헤더가 application/x-www-form-urlencoded, multipart/form-data, text/plain중 하나여야 한다.
    - 위 조건 불충족 시, 예비 요청으로 동작됨!! -> 이게 드물어. 그래서 대부분의 API요청은 보통 걍 예비 요청을 이루어짐ㅇㅇ
<br/>

- **웹소켓과 HTTP의 차이점은 무엇인가요?**
  - 웹소켓
    - = 서버와 클라 간의 메시지 교환을 위한 프로토콜(통신 규약)
    - 접속까지는 HTTP 프로토콜 이용하고 그 이후 통신은 자체적인 WebSocket 프로토콜로 통신
    - 양방향 통신(서버와 클라 간의) - 데이터 송수신 동시 처리 가능
    - 서버와 클라가 계속 같은 라인으로 통신되서 TCP/IP 연결 트래픽 줄일 수 있음ㅇㅇ
  - HTTP
    - = 웹소켓 이전의 실시간성 보장 기법
    - 클라가 요청을 보내는 경우에만 서버가 응답을 하는(서버에서 클라) 단방향 통신 - 클라에서 서버로 데이터 전송이 어려움
    - 통신 연결이 길어질수록 TCP/IP 연결 트래픽 발생 다수
<br/>

- **REST에서 URI가 무엇인지 설명해주세요.**
  - URI란 Uniform Resource Identifier로 인터넷 상의 자원을 식별하기 위한 문자열의 구성이다.
  - 자원을 구별하는 ID
  - 클라는 URI를 이용해 자원을 지정하고 해당 자원에 대한 정보에 대한 조작을 서버에 요청
  - HTTP URI를 통해 HTTP 메소드를 통해 요청을 보내 해당 자원에 대한 CRUD 연산 가능케 ㅇㅇ
  - + HTTP URI 통해 자원을 특정 형태로 명시
<br/>

- **REST의 설계 규칙에 대해 간단하게 말씀해주세요.**
  - 서버-클라이언트 구조 : 자원 요청 쪽이 클라 자원 있는 쪽이 서버
  - 무상태 : HTTP프로토콜을 그대로 사용하므로 HTTP 프로토콜이 Stateless Protocol이므로 REST 역시 Stateless 무상태성을 가짐. 서버는 각 요청에 대해 별개의 것으로 처리
  - 캐시 처리 가능 : 대량의 요청을 효율적으로 처리하기 위해 캐시를 사용해 전체 응답 시간, 성능, 서버의 자원 이용률 향상
  - 계층화 : 클라는 REST API Server만 호출. 구조 상의 유연성 부여 + 확장성 및 보안성 향상
  - 인터페이스 일관성 : 특정 언어나 기술에 종속X
  - 자체 표현 : 요청 메시지만 보고도 쉽게 이해 가넝
  - 선택사항 : Code-On-Demand : 서버로부터 스크립트 받아 클라에서 실행
<br/>

- **REST API 와 RESTful API의 차이점과 궁극적으로 RESTful API의 목적이 무엇인지에 대해 말씀해주세요.**
  - REST 원리를 따르는 시스템이 RESTful이란 용어로 지칭되는거로 RESTful API란 REST의 6가지 설계 규칙을 잘 지켜서 설계뙨 API
  - 목적
    - 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
    - 근본적인 목적이 일관적인 컨벤션을 통해 API의 이해도 및 호환성을 높이는 것임 -> 성능이 중요할 땐 굳이 RESTful API 구현할 필요X
<br/>

- **JWT Process에서 Refresh Token의 역할과 JWT의 어떤 단점을 어떻게 보완하는 지에 대해 말씀해주세요.**
  - JWT Process 중에 클라가 스스로 혹은 서버로부터 Access Token 만료 사실을 알게 되었을 때, Refresh Token으로 서버에게 새로운 Access Token을 발급하도록 할 수 있다. 이를 통해 Access Token의 유효 기간을 연장시켜 계속하여 API를 사용할 수 있게 하는 토큰.       
  - JWT Process에서 Access Token은 토큰 탈취 방지를 위해 짧은 exp를 가지고 있어 짧은 시간마다 재로그인을 하는 사용자의 불편함을 초래한다. 이러한 단점을 보완하는 역할
  - (Access Token의 짧은 만료시간(exp)를 해결하는 방법으로) 7일, 30일 등의 비교적 긴 exp을 가지고 있어 Access Token을 Refresh해주는 것을 보장하는 토큰
  - Refresh Token 역시 사용자가 초기 로그인을 할 때(JWT를 처음 발급할 때) Access Token과 함께 발급받은 토큰이므로 요청의 Refresh Token이 유효하면 해당 사용자임을 간주할 수 있다.
<br/>

- **JWT를 활용한 적이 있다면 활용했던 경험에 대해 말씀해주시고 없다면 어떤 경우에 사용하는 것이 좋은 지 말씀해주세요.**
  - 사용자 개개인의 계정이 필요한 어플들을 개발할 때 사용해봤음 - 로그인 과정에서
    - 사용자 로그인 시, 서버에서 사용자의 정보를 기반으로 한 토큰을 발급하고 사용자는 서버에 요청할 때마다 JWT를 포함하여 전달하게 한다. 그 후 서버는 클라에서 요청을 받을 때마다 해당 토큰이 유효하고 인증되었는지를 검증하고 사용자가 해당 요청 작업에 대해 권한이 있는 지 확인하여 로그인 작업을 처리했다. - 사용자가 요청을 했을 때, 토큰만 확인하면 되므로 서버의 자원과 비용이 절감되었음
  - 정보 교류
    - 두 개체 사이에서 안정성 있게 정보를 교환할 때 써도 GOOD
    - 정보가 서명되어있기 때문에 정보를 보낸 이가 바뀌진 않았는지, 정보가 도중에 조작되지는 않았는지를 검증 가능
<br/>

- **CSR이 무엇인지 그리고 장단점에 대해 말씀해주세요.**
  - 정의
    - = Client Side Rendering
    - 최초 로딩 시, 서버에서 보내준 HTML파일과 HTML에 링크된 CSS, JavaScript 등 각종 리소스들을 받아와 프론트에서 동적으로 랜더링하는 것. 그 이후, 필요에 따라 서버에 요청해 받아온 데이터를 기반으로 HTML을 동적으로 생성해 사용자에게 보여주는 것
  - 단점
    - 최초 로딩 시, 모든 리소스들을 받아와 랜더링하기 때문에 초기 로딩 속도가 느리다.
    - 초기에 받아온 HTML 파일에 어플리케이션 관련 JS링크만 들어있고 데이터는 비어있어 검색 엔진이 웹페이지를 분석하기 어렵다.
  - 장점
    - 최초 로딩은 오래 걸리지만 그 이후엔 빠른 페이지 전환 가능
    - 매 페이지 이동마다 새롭게 서버한테 완성된 HTML을 요청하는 것이 아니라 필요한 데이터만 요청하기 때문에 서버의 부담이 적다.
<br/>  

- **CSR과 SSR에 대해 서버 자원 사용과 SEO 관점에서 말씀해주세요.**
  - 서버 자원 사용
    - CSR은 최초 로딩 시, 서버에서 HTML파일 외의 모든 리소스들을 한 번에 받아옴. 그 후 랜더링은 프론트(클라)에서 동적으로 한다. SSR은 페이지를 이동할 때마다 서버에 요청을 하고 요청을 할 때마다 서버로부터 이미 랜더링이 완료된 HTML파일을 받아온다.
  - SEO(Search Engine Optimization)
    - CSR은 SEO가 좋지 않다. HTML의 바디가 대부분 텅텅 비어있어 검색 엔진들이 CSR로 작성된 웹페이지를 분석하는데 어려움을 겪음. SSR은 모든 컨텐츠가 HTML에 담겨져있어서 SEO가 좀 더 효율적이다. 
    - but, SSR도 문제점 ㅇㅇ 페이지 로딩 시 깜박임 이슈 + 서버 과부화 쉬움 + 사용자가 동적으로 데이터를 처리하는 자바스크립트를 아직 다운받지 못해서 클릭 시에도 반응이 없을 수 있음(CSR : TTV = TTI / SSR : TTV != TTI .. V=View & I=Interact)
<br/>

- **Cookie와 Session이 각각 무엇인지와 둘의 차이점에 대해 말씀해주세요.**
  - Cookie(쿠키)
    - = HTTP의 일종으로 사용자가 어떠한 웹사이트 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일
    - HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요 시 정보를 창조하거나 재사용할 수 있다.
  - Session(세션)
    - = 방문자가 서버에 접속해 있는 상태를 하나의 단위로 지칭하는데 이를 세션이라 부름
    - 일정시간(방문자의 웹브라우저 접속~종료)동안 같은 사용자로부터 들어오는 일련의 요구들을 하나의 상태로 보고, 그 상태를 유지하느 기술
  - 차이점
    - 사용자의 정보가 저장되는 위치 : 쿠키는 서버의 자원 사용 X / 세션은 서버의 자원 사용 O
    - 보안 : 쿠키는 보안에 취약 / 세션은 보안 비교적 좋음
      - 쿠키는 클라이언트 로컬에 저장하기 때문에 변질되거나 요청 시 스피닝 당할 우려 ㅇㅇ
      - 세션은 쿠키를 통해 Session ID만 저장하고 서버에서 그 ID를 기반으로 구분하여 처리하기 때문
    - 속도(서버에 요청 시): 쿠키는 속도 빠름-정보가 쿠키에 있음 / 세션은 속도 느림-정보가 서버에 있어 처리가 요구됨
    - 라이프 사이클 : 쿠키는 브라우저 종료해도 정보 유지 / 세션은 브라우저 종료 시 삭제
      - 쿠키는 파일로 저장되기 때문에. 만료기간 따로 지정해 쿠키를 따로 삭제할 때까지 유지
      - 세션도 만료기간을 정할 수 있지만 브라우저 종료 시 만료 기간이랑 상관없이 삭제됨
<br/>

- **Cookie의 동작 순서에 대해 말씀해주세요.**
  1. 사용자가 웹사이트에 접근하여 클라이언트가 페이지를 요청
  2. 서버는 쿠키를 생성
  3. HTTP헤더에 쿠키를 포함시켜 응답
  4. 브라우저가 종료되어도 쿠키 만료 기간때까지 클라이언트에서 보관
  5. 같은 요청을 할 경우, HTTP헤더에 쿠키를 함께 보냄
  6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때, 쿠키를 업데이트하고 변경된 쿠키를 HTTP 헤더에 포함시켜 응답
<br/>  

- **Web Server와 WAS의 차이점에 대해 간략히 설명해주세요.**
  - Web Server는 HTTP 프로토콜을 기반으로 클라이언트가 요청한 정적 리소스를 제공하는 서버
  - WAS는 Web Application Server로 Web Server로부터 오는 동적인 요청을 처리하는 서버(웹서버+컨테이너)
  - 차이점
    - 웹서버는 정적 리소스 WAS는 동적 요청 처리
    - 웹서버는 사용 시 모든 요청에 대한 결과 값을 미리 만들어 놓고 서비스를 하는 반면 WAS는 각 요청에 따라 DB에서 데이터를 조회하거나 비즈니스 로직을 수행하여 그때 결과를 만들어서 응답하여 웹서버보다 WAS가 자원을 효율적으로 사용한다.
    - 근데 실제로 둘의 경계가 모호하긴 함. 걍 WAS가 Web Server 기능 + 특화된 애플리케이션 코드 실행 능력
  - => 결론적으론 동적과 정적 중 어떤 타입의 컨텐츠를 주로 제공하느냐에 따라 구분하면 됨
<br/>

- **WAS가 Web Server의 역할을 할 수 있음에도 불구하고 Web Server와 WAS를 조합하여 시스템을 구축하는 이유와 이러한 시스템의 장점에 대해 설명해주세요.**
  - : 각각 웹서버는 정적리소스를 WAS는 애플리케이션 로직을 맡아, 역할을 나누면 좀 더 효율적인 수행이 가능하며 여러 방면에서 장점이 많다. 
  - 기능을 분리하여 서버 부하를 방지할 수 있다.
    - 단순한 정적 컨텐츠는 웹서버에서 빠르게 클라에게 제공+WAS는 DB조회, 비즈니스 로직 처리에 집중
  - 효율적인 리소스 관리가 가능하다.
    - 정적 리소스 多 : Web Server 증설 / 애플리케이션 리소스 多 : WAS 증설
  - 물리적으로 분리하여 보안을 강화시킬 수 있다.
    - Web Server가 SSL에 대한 암호화 및 복호화 처리와 접근 허용 IP를 관리
  - 장애 극복 및 대응에 유리하다.
    - 무중단 운영 중 발생하는 장애에 쉽게 대응 가능
    - 단순 파일 조회와 같은 정적 리소스만 제공하는 Web Server는 잘 죽지 않음 but, 애플리케이션 로직이 동작하는 WAS는 잘 죽음
    - WAS와 DB 장애 시에도 Web Server가 오류 화면을 제공 + 특정 WAS에 오류 발생해도 사용자는 서비스 이용 가능
<br/>


