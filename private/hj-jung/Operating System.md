## Operating System 면접 질문 리스트
- **프로그램, 프로세스, 스레드의 차이에 대해 설명해주세요**
  - 프로그램 = 어떤 작엄을 하기 위해 실행할 수 있는 코드 파일이 저장 장치엔 존재하지만, 메모리에는 존재하지 않는 정적인 상태
  - 프로세스 = 운영체제로부터 자원을 할당받은 작업의 단위. 프로그램 실행 상태란 할당받은 CPU 프로세스들이 실행되고 있는 상태
  - 스레드 = 하나의 프로세스 내에서 진행되는 흐름의 단위
  - 스레드 < 프로세스 < 프로그램
<br/>

- **멀티프로세스와 멀티스레드의 특징에 대해 설명해주세요**
  - 멀티 프로세스
    - = 하나의 프로그램에서 여러 개의 프로세스들이 실행되고 있는 것
    - 여러 개의 자식 프로세스 중 하나에 문제가 발생해도 그 아이만 죽는 것 이외의 다른 영향은 없다
    - but, Context Switching에서 오버헤드 발생. - 프로세스는 각각의 독립된 메모리 영역을 할당받았기에 프로세스 간 공유하는 메모리가 없! -> Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 리셋하고 다시 캐쉬 정보를 불러와야함
  - 멀티 스레드
    - 하나의 프로세스 안에 여러 개의 스레드가 실행되고 있는 것 -> 하나의 프로그램에서 2가지 이상의 작업 동시 처리 가능하게 하는ㅇㅇ
    - 많은 운영체제들이 멀티 스레딩을 기본으로 함. 대표적으로 웹서버가 멀티스레드 응용프로그램
    - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 시스템 자원 소모가 줄어 자원을 효율적으로 관리할 수 있다
    - 스레드 간 데이터 교환이 간단해지고 작업량이 작아 Context Switching이 빨라 시스템 처리량이 증가한다.
    - 프로세스 내 Stack제외한 모든 메모리를 공유하기 때문에 통신 횟수가 적어 프로그램 응답 시간이 단축된다.
    - but, 주의 깊은 설계가 필요하며, 자원 공유 및 동기화 문제가 발생할 가능성이 있으며 하나의 스레드에 문제가 발생할 경우, 전체 프로세스가 영향을 받는다.
  - 여튼 그래도 멀티프로세스보단 멀티스레드가 조은 이유는 프로그램 여러 개 키는 것보단 하나의 프로그램 안에서 여러 작업을 해결하는 게 나음 -> 자원 효율성 증가 & 처리 비용 감소 & 응답 시간 단축
<br/>

- **프로세스의 주소공간은 어떻게 구성되어있는지 설명해주세요**
  - 코드 영역 : 실행할 프로그램의 코드들이 위치. read-only. 
  - 데이터 영역 : 전역 변수&정적 변수가 위치. 한 프로세스 내 여러 스레드가 공통으로 공유하는 영역. read-write
  - 힙 영역 : 사용자에 의한 동적 할당을 하는 영역. 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됨. 런타임에 크기가 정해짐. 주로 객체 저장
  - 스택 영역 : 지역 변수&매개변수가 위치. 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됨. 함수 호출과 함께 할당되고 호출 완료 시 소멸. 
<br/>

- **프로세스의 주소공간에서 왜 Stack 부분과 Data 부분을 나누어서 구성했는지 설명해주세요**
  - Stack은 하단부가 막혀있고 상단부만 뚫려있어 한 쪽으로만 데이터를 집어 넣을 수 있고 꺼낼 땐 최근에 집어넣었던 것부터 꺼낼 수 밖에 없는 구조이다. 예를 들어 C언어에서는 함수의 호출이 stack구조로 되어있다. 이때, 전역 변수는 어떤 함수에서도 접근을 할 수 있어야하기 때문에 Data 부분으로 빼내어 따로 관리해준다.
<br/>

- **PCB가 Context Switching 과정에서 왜 필요한지 말씀해주세요.**
  - PCB란 OS가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로 프로세스의 상태 정보를 저장하는 구조체이다. 그리고 Context Switching과정(여러 프로세스들을 번갈아가며 실행하기 위한)에서 기존 프로세스의 상태를 어딘가에 저장해둬야 다음에 이 똑같은 작업을 이어서 할 수 있으며, 새로운 작업 또한 상태를 알아야 어디서부터 작업을 시작할 지 결정할 수 있다. 이러한 프로세스 스케줄링을 하기 위해선 위와 같이 프로세스에 관한 모든 정보를 저장하는 임시저장소, 즉 PCB가 필요하다. (그리고 프로세스 생성 시 PCB도 생성되고 프로세스 완료 시 PCB도 제거됨)
<br/>

- **Context Switching은 언제 발생하는지 말씀해주세요.**
  - 스케줄링에 의해 할당된 작업 시간이 끝나 timeout이 발생했을 때 발생
  - 프로세스의 작업이 끝났을 때 발생
  - 실행 중이던 프로세스가 입출력 요청을 할 때 발생
<br/>

- **CPU 스케줄링이 발생하는 시기에 대해 CPU 반납 방식과 관련하여 설명해주세요.**
  - 프로세스가 입/출력을 요구할 때
    - I/O 버스트가 시작되면 운영체제는 CPU를 다른 프로세스에게 할당해주기 위해 CPU 스케줄링
    - 자율적 CPU 반납 (비선점형 스케줄링)
  - 프로세스가 종료를 요구할 때
    - 운영체제는 CPU를 할당할 새로운 프로세스를 찾기 위해 CPU 스케줄링
    - 자율적 CPU 반납 (비선점형 스케줄링)
  - 높은 우선순위의 프로세스가 나타났을 때
    - 준비 상태의 새로운 프로세스의 우선순위가 이전의 실행중이던 프로세스보다 높다면 CPU 스케줄링에 따라 CPU 할당을 즉시 교체
    - 타율적 CPU 반납 (선점형 스케줄링)
  - 주어진 CPU 실행 시간을 초과했을 때
    - 어느 한 프로세스가 CPU 타임 퀸텀을 초과한 경우 CPU를 다른 프로세스에게 할당
    - 타율적 CPU 반납 (선점형 스케줄링)
<br/>

- **여러 CPU 스케줄링 알고리즘 중 1개를 선택하여 자세히 설명해주세요.**
  - 라운드 로빈 스케줄링
    - = 전형적인 선점형 스케줄링 전략으로, 모든 프로세스에 동일한 최대 CPU 점유 시간(타임 퀀텀)을 설정하고, 처리 중인 프로세스의 CPU 실행 시간이 타임 퀀텀을 초과하면 CPU를 강제로 회수하여 다음 프로세스에 할당하는 전략
    - 모든 프로세스들에게 CPU가 할당될 기회가 동일하게 주어지므로 대화형 시스템 환경에 적합
    - 적절한 타임 퀀텀 설정이 매우 중요
      - 타임 퀀텀 값이 0에 가까워질 수록 context switching이 자주 발생하여 시스템 오버헤드 증가, 전체적인 처리율 감소
      - (타임 퀀텀 값이 무한대에 가까워질 수록 FCFS와 동일)
<br/>

- **인터럽트가 무엇인지, 왜 사용하는지 설명해주세요.**
  - = CPU가 프로그램을 실행하는 도중에 예외 상황이 발생하여 처리가 필요할 경우 CPU에게 알려 처리할 수 있도록 하는 것
  - OS가 한 번에 여러 작업을 처리하게 하여 처리기의 처리율을 향상시키는 것을 가능케하기 위해 사용
  - 지금 실행중인 일보다 더 중요한 일이 발생하면 그 일을 먼저 처리해준 후에 하던 일을 계속하게 함
<br/>

- **인터럽트의 발생 시 수행 과정을 말씀해주세요.**
  - 요청 -> 중단 -> 보관 -> 인터럽트 처리 -> 재개
  1. 장치가 인터럽트 시그널을 CPU로 보낸다.
  2. 인터럽트에 응답하기 전 CPU는 우선 현재 수행 중인 명령어까지는 완료한다.
  3. 그 후 대기 중인 인터럽트 요청이 있는지 확인하고, 있을 경우 이제 CPU가 제어를 인터럽트 루틴으로 넘기기 위한 준비를 한다. 처리하던 작업에 대한 정보를 PCB에 저장한다.
  4. PC에 다음에 실행할 명령의 주소 저장한다.
  5. 인터럽트 벡터를 읽고 ISR주소 값을 얻어서
  6. 해당 주소로 가서 코드를 실행한다.
  7. 처리가 완료되면, 저장한 PCB와 PC 값을 인터럽트 발생 이전으로 복구 시킨 후 하던 일을 한다.
<br/>

- **시스템 콜이 필요한 이유는 무엇인가요?**
  - 유저 프로세스인 응용프로그램에서 유저 레벨 함수들 이외의 다양한 기능 및 커널 관련 사항들을 수행하기 위해서는 커널모드로 전환해야 작업을 수행할 권한이 생긴다. 이러케 응용프로그램이 시스템 콜을 통해 원하는 기능을 수행 가능케 해주는게 시스템 콜.
<br/>

- **CPU모드의 2가지 종류인 커널 모드와 사용자 모드에 대해 설명해주세요.**
  - 커널 모드(Kernel Mode)
    - '0' Mode bit
    - OS가 CPU를 사용하는 모드
    - PC 레지스터가 운영체제가 존재하는 부분을 가리키고 있을 때
    - 운영체제의 코드가 실행되는 모드
    - 특권 명령 : 보안이 필요한 명령, 입출력 장치, 타이머 등 각종 장치에 접근하는 명령
    - 파일 읽기, 파일 쓰기, 메세지 화면 출력 등 많은 부분이 커널모드 사용
    - 시스템 콜을 통해 커널모드로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어(Privileged Instructions) 실행
  - 사용자 모드(User Mode)
    - '1' Mode bit
    - PC 래지스터가 사용자 프로그램이 올라가 있는 메모리 위치를 가리키고 있을 때
    - 사용자 프로그램을 수행하는 모드
    - 일반 명령 : 메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 명령들, 모든 프로그램 수행 가능
    - 사용자가 접근할 수 있는 영역에 제한이 있기에 해당 모드에서는 하드웨어 접근 불가
    - -> 이 때, 접근하려면 시스템 콜 사용해야 함!
<br/>
