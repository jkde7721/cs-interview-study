- **TCP의 흐름제어/혼잡제어에 대해 간단하게 설명해주세요.**
  - 흐름제어
    - = 송/수신측의 데이터 처리(전송) 속도 차이를 해결하기 위한 기법
    - 수신측이 너무 많은 패킷을 수신받지 않게 하려구!
    - CP에선 흐름제어 기법을 사용하며 송신측의 처리 속도가 더 빠를 경우를 제어함(수신측이 송신측에게 자신의 상태를 계속해서 알리는 것이 베이스 ㅇㅇ)
  - 혼잡제어
    - = 네트워크 내에 패킷의 수가 과도하게 증가하는 혼잡 현상을 방지하고 제거하기 위한 기법
    - 라우터를 포함한 넓은 범위의 전송 문제를 다룸
<br/>

- **TCP와 IP의 차이에 대해 설명해주세요.**
  - TCP는 정확한 전송이 목적 /  IP는 빠른 전송이 목적.
    - TCP : 패킷 전송 속도는 느리지만 패킷 전달 여부 보증O & 패킷을 송신 순서대로 받게 해줌
    - IP : 패킷 전달 여부 및 순서 보증X & 패킷을 보낸 속도와 받는 속도가 다를 수 있음
    - TCP는 데이터의 정확성을 확인하고 IP는 패킷을 목적지까지 전송하는 일을 담당
    - TCP는 패킷의 추적 및 관리를, IP는 배달을.
<br/>

- **OSI 7계층과 TCP/IP 4계층의 차이점과 TCP/IP 4계층에서의 캡슐화와 역캡슐화에 대해 설명해주세요**
  - 차이점
    - 네트워크 통신의 발생 과정을 나눠놓은 OSI 7계층을 TCP/IP프로토콜 통신 과정에 맞춰 단순화한게 TCP/IP 4계층
    - 네트워크 전송 시의 데이터 표준을 정리한 것 OSI 7계층, 이 이론을 실제 사용하는 인터넷 표준에 맞게 정리한 것 TCP/IP 4계층
  - 캡슐화 & 역캡슐화 : TCP/IP 4계층에서 일어나는 데이터 처리 과정으로
    - 캡슐화 = 데이터 전송 시, 데이터가 상위 계층->하위 계층으로 이동. 계층 간 데이터 이동마다 필요한 정보(헤더) 추가됨
    - 역캡슐화 = 데이터 수신 시, 데이터가 하위 계층->상위 계층으로 이동. 계층 간 데이터 이동마다 추가된 헤더를 읽고 알맞은 행동 취한 후에 헤더 제거
<br/>
  
- **TCP와 UDP에 대해 설명해주세요**
  - TCP = 인터넷 상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
  - UDP = 데이터를 데이터그램(패킷) 단위로 처리하는 프로토콜. 각각의 패킷은 다른 경로로 전송되어 패킷들이 독립적인 관계를 지님
  - 공통점
    - Port 번호 이용해 주소 지정
    - 데이터 오류 검사를 위한 CheckSum 존재
  - 차이점(TCP / UDP)
    - 연결형 프로토콜 / 비연결형 프로토콜
    - 느림 / 빠름
    - 전송 순서 보장 O / 전송 순서 보장 X
    - 데이터 경계 구분 X / 데이터 경계 구분 O
    - 신뢰성 있는 데이터 전송(재전송O) - 수신 여부 확인 / 비신뢰성 있는 데이터 전송(재전송X) - 확인X
    - 일대일 통신 / 일대일, 일대다, 다대다 통신
    - use in 신뢰성 요구되는 앱 / use in 간단한 데이터를 빠른 속도로 전송하고자 하는 
  <br/>
<br/>

- **동기와 비동기(블로킹과 넌블로킹)의 차이와 장단점에 대해 설명해주세요.**
  - 가장 큰 차이 : 작업 진행 방식

  - **블로킹 vs 논블로킹** 
    - 기준 : 전체 작업 흐름에 대한 block(차단, 대기) 유무 여부 - 호출된 함수가 호출한 함수에게 제어권을 건네주는가에 따라 구분
    - 블로킹
      - 현재 작업을 모두 중지하고 요청된 작업이 완료되기만 계속하여 기다림
      - 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출된 함수에게 제어권을 넘겨주지 않아 대기하게 만듦
    - 논블로킹
      - 요청된 작업 실행 중에도 동시에 다른 작업 수행 가능
      - 호출된 함수가 호출한 함수에게 바로 제어권을 넘겨줘 호출한 함수는 다른 작업 수행 가능

  - **동기 vs 비동기**
    - 기준 : 전체 작업 흐름에 대한 순서 유무 여부 (순차적인 흐름 유무) - 여러 요청 작업을 순차적으로 or 동시적으로 처리하는가에 따라 구분
    - 동기
      - 현재 작업이 완료되어야만 다음 작업을 순차적으로 수행 : 순서대로 작업 실행
      - 작업에 대한 후속 처리를 내가 직접 하는 경우
      - 호출한 함수가 호출된 함수의 작업 완료 여부를 계속 확인하며 신경씀
    - 비동기
      - 현재 작업의 완료 여부를 따지지 않고 바로 다음 작업 수행 : 무작위로 작업 실행
      - 작업에 대한 후속 처리를 타인에게 시키는 경우
      - 호출한 함수는 호출된 함수에게 callback을 전달해 작업 완료 여부를 신경X
      - 성능상 이점 : 여러 작업들을 동시 처리함으로써 전반적인 시스템 성능 향상
<br/>
<br/>

- **Synchronous & Blocking과 Asynchronous & Non-Blocking의 동작 방식과 어떤 상황에 적절한지 이유와 함께 설명해주세요.**

  - **동기 & 블로킹**
    - = 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고(Blocking), 다른 작업의 완료 여부를 받아 순차적으로 처리하는(Sync) 방식
    - 장점
      - 코드가 순차적으로 실행되어 요청한 작업의 결과가 현재 작업에 영항을 주는 경우에 적합
      - 작업량이 적고 간단한 작업.
      - 설계 간단 & 직관적
    - 단점
      - 작업량이 많거나 시간이 오래 걸리는 작업 처리의 경우에 한 작업이 끝날 때까지 다른 작업들 처리가 불가능해 비효율적
      - 요청에 대한 결과가 반환될 때까지 대기해야 함

  - **비동기 & 논블로킹**
    - = 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non Blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는(Async) 방식
    - 장점
      - 작업량이 많거나 시간이 오래 걸리는 작업 처리의 경우에 동시에 여러 작업 진행이 가능해 처리 시간 감소&효율적
      - 대용량 데이터나 많은 요청을 처리하는 서비스에서 사용 - 동시작업가능해 어플리케이션 처리 성능 향상
      - 요청에 대한 결과 반환되기 전에도 다른 작업 수행이 가능해 자원을 효율적으로 사용
    - 단점
      - 요청한 작업의 완료 여부나 결과에 대한 후처리를 위해선 Callback함수를 사용해야함
      - 설계 복잡
<br/>
<br/>

- **비동기 프로그래밍 관련 트러블 슈팅 경험 (있다면)**
  - 비동기 프로그래밍 : 순서에 상관 없이 처리를 할때 스레드를 여러개 생성하여 해당 프로세스들을 처리하게 되기 때문에, 일반적으로 멀티 스레드 프로그래밍에 대한 지식이 있는 상태로 프로그램을 짜야한다.
  - 그리고 비동기 로직을 사용하려는 클래스에서 @EnableAsync 애노테이션을 달아주고, 비동기를 사용하려는 로직에 @Annotation 애노테이션을 달아주면 된다고 했다.
  - .. 잘모르겠고 우선 멀티스레드를 사용해야하는듯
<br/>
<br/>

- **대규모 트래픽에 대처할 수 있는 방법에 대해 설명해주세요.**
  - : 서버의 성능 높이기
  - Scale-up : 기존 서버의 사양을 높이는 방법
  - Scale-out : 서버의 개수를 늘리는 방법 -> 로드 밸런싱
    - 로드 밸런서 = 서버의 부하를 분산시키는 하드웨어 or 소프트웨어
      - 네트워크 트래픽 또는 클라이언트의 요청을 여러 서버에 적절하게 분배 - 특정 서버의 부하를 덜어줌
      - Active한 서버에게만 요청 전송&서버 다운 시, 리다이렉션 - 높은 가용성과 신뢰성
      - 서비스 중단 없이 서버 추가 및 제거 가능케 함 - 유연성
    - 로드 밸런싱 = 로드 밸런서를 이용해 네트워크에 가해지는 대규모의 네트워크 트래픽(부하)을 여러 서버들을 이요해 분산 처리시키는 기술
<br/>
<br/>

- **L4와 L7이 대표적인 로드밸런서로 많이 활용되는 이유에 대해 설명해주세요.**
  - L4
    - 포트 정보를 바탕으로 분산하는 것이 가능해서! (한 대의 서버에 각가 다른 포트 번호를 부여하여 다수의 서버 프로그램 운영)
    - : 네트워크 계층(IP, IPX)이나 트랜스포트 계층(TCP, UDP)의 정보를 바탕으로 부하를 분산
    - IP 주소나 포트 번호, MAC 주소, 전송 프로토콜 등에 따라 트래픽을 나누고 분산 처리하는 것이 가능
    - 라운드 로빈 / 가중 라운드 로빈 / IP해시 / 최소 연결 / 최소 응답 시간
  - L7
    - = HTTP 헤더, 쿠기 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능해서!
    - : 애플리케이션 계층 (HTTP, SMTP, FTP)의 정보를 바탕으로도 분산 처리 가능
    - 특정한 패턴을 지닌 바이러스를 감지해 네트워크 보호 가능 & 비정상적인 트래픽(Dos, DDos) 필터링 가능
    - URL 스위칭 방식 / 컨텍스트 스위칭 방식 / 쿠키 지속성
<br/>
<br/>

- **대칭키 암호화 기법과 공개키 암호화 기법에 대한 각각의 설명과 장단점에 대해 말씀해주세요.**
  - **대칭키 암호화**
    - 클라이언트와 서버가 동일한 암호키를 사용하는 알고리즘. 오직 1개의 키만 사용
    - 장점
      - 비교적 빠른 속도
      - 기밀성 제공
    - 단점
      - 키 교환 문제 : 암호화 통신을 하는 사용자들끼리 같은 대칭키를 공유해야 함
      - 키 교환 중 키 탈취 가능성 존재 - 해킹의 위험성O
      - 관리해야 할 키의 개수 방대

  - **공개키 암호화 기법**
    - 1개의 쌍으로 구성된 공개키와 개인키(비밀키)를 사용하여 암호화를 진행하는 알고리즘
    - 공개키로 암호화 시, 개인키로만 복호화 가능
    - 장점
      - 높은 안전성 - 수신자의 비밀키로만 해독 가능
      - 키 분배 및 관리가 쉬움
      - 높은 확장 가능성
    - 단점
      - 암호화 연산이 매우 복잡함
      - 연산 속도 느림
<br/>
<br/>

- **대칭키와 공개키 각각 어떤 경우에 사용하면 좋을지 말씀해주세요.**
  - 비대칭키(공개키)
    - HTTPS 연결 과정에서 처음 연결을 성립한 후에 안전하게 세션키를 공유하기 위해 비대칭키 사용
  - 대칭키
    - 대용량 데이터 암호화
    - HTTPS 연결 과정에서 세션키 공유 이후, 데이터 교환 과정에서 빠른 연산 속도를 위해 대칭키 사용
<br/>
<br/>

- **HTTP와 HTTPS의 차이점과 각각 어떤 경우에 사용하는 것이 적절한 지 설명해주세요.**
   - HTTP 
    - 데이터 보안 취약 : 일반 텍스트 형태로 데이터 교환
    - 검색 엔진에서의 낮은 신뢰성
    - 오늘날에는 큰 차이 없지만 비교적 빠른 속도
    - WHEN ? 노출되어도 괜찮은 단순한 정보 조회 등 만을 처리하는 경우
  - HTTPS
    - 데이터 보안 강화 : 암호화된 형태로 모든 데이터 교환
    - 암호화와 복호화 과정 필요
    - 인증서 발급 및 유지 위한 추가 비용 발생 - 요즘은 무료 SSL인증서를 획득할 수 있는 출저 다양
    - WHEN ? 개인 및 금융 정보와 같은 민감한 데이터를 주고 받는 경우

  - HTTPS 선택 이유
    - 보안 : 사용자가 민감한 데이터를 제출할 때, 제3자가 네트워크를 통해 해당 데이터 가로채기 불가능
    - 권위 : 검색 엔진에서 신뢰성이 더 높아 웹사이트 콘텐츠 순위가 더 높으며 사용자도 더 선호(URL옆 자물쇠 아이콘)
    - 성능 및 분석 : 더 빠른 로드 속도 / 우월한 참조 링크 추적 능력 / 정확한 트래픽 소스 식별 가능
<br/>
<br/>

- **비대칭키 암호화에 대하여 설명해주세요.**
  - 1개의 쌍으로 구성된 공개키와 개인키를 사용하여 암호화와 복호화 진행
  - 공개키 암호화 : 공개키(=모두에게 공개 가능한 키)로 암호화 시, 개인키로만 복호화 가능 -> 개인키는 나만 보기 가능
  - 개인키 암호화 : 개인키(=나만 가지고 알고 있는 키)로 암호화 시, 공개키로만 복호화 가능 -> 공개키는 모두에게 공개되어 있어, 내가 인증한 정보임을 알려 신뢰성 보장
  - 키가 노출되어도 비교적 안전 && 연산 속도 느림
<br/>
<br/>
