## 데이터베이스 면접 질문 리스트

- **Index의 자료구조 대표적 예시 2가지를 설명하고 각각의 장단점을 말씀해주세요**
  - 해시테이블
    - : Key, Value로 데이터를 저장하는 자료구조
    - 컬럼의 값으로 생성된 해시를 통해 인덱스 구현
    - 장점 : 매우 빠른 검색 가능
    - 단점 : 부등호 연산(>,<)이 주된 DB검색에선 부적합 - 일부 부분에 대한 검색이 불가
  - B-Tree
    - : 이진 트리를 확장하여 N개의 자식을 가질 수 있는 균형 트리
    - 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱스 구현
    - 장점 : 범위 탐색(일부 부분에 대한 검색) 가능
    - 단점 : 리프 노드에 방문하려면 루트 노드와 모든 브랜치 노드를 방문해야함
  <br/>
  
- **RDBMS와 NoSQL은 각각 어느 경우에 사용하기 적합한지에 대해 설명해주세요**
  - RDBMS : 대량의 구조화된 데이터 관리에 사용하기 적합
  - NoSQL : 테이블 간 관계를 정의하지 않으며 비구조화 데이터들 처리하므로<br/>
            방대한 양의 데이터 변경을 저장하거나 다양한 구조의 데이터를 처리하는 애플리케이션에 적합
  <br/>
  
- **정규화 과정에서 사용되는 함수 종속성이 무엇이며, 함수 종속성의 종류에 대해 설명해주세요**
  - = 어떤 테이블의 속성 X,Y에 대해 함수적으로 Y값에 의해 X값이 유일하게 결정되는 관계
  - 완전 함수 종속 (Full Fuctional Dependency)
    - X -> Y 일 때, 속성 집합 X의 일부분에는 Y가 종속되어 있지 않음. 가장 일반적
  - 부분 함수 종속 (Partial Functional Dependency)
    - X -> Y 일 때, 속성 집합 X의 부분 집합에도 Y가 종속되어 있음
  - 이행적 함수 종속 (Transitive Fuctional Dependency)
    - X -> Y, Y -> Z 일 때 X -> Z 성립 == Z가 X에 이행적으로 함수 종속되어 있음
  <br/>
  
- **인덱스 알고리즘 중 B-Tree와 B+Tree의 차이점을 설명해주세요**
  - B-Tree는 모든 노드에 데이터를 저장하는 반면 B+Tree는 리프 노드에만 데이터 저장(나머지 노드에는 인덱스만 저장)
  - B+Tree는 리프 노드들이 LinkedList로 연결되어 있어 순차 검색에 용이함
  - B-Tree는 모든 리프 노드에 방문하려면 루트 노드와 모든 브랜치 노드를 방문해야했지만 B+Tree는 리프 노드들이 서로 연결되어 있기 때문에 모든 브랜치 노드를 방문하지 않고도 바로 모든 리프 노드에 방문이 가능하다!
  <br/>
  
- **SQL vs NoSQL의 차이점과 어떤 상황에 어떤 데이터베이스가 적합한지 이유와 함께 설명해주세요.**
  - 차이점 : 데이터 저장 및 구성 방식(SQL은 관계형 데이터베이스, NoSQL은 비관계형 데이터베이스)
  - SQL
    - 구조화된 데이터 다룰 때
    - 변경될 여지가 적고 명확한 스키마가 사용자와 데이터에게 중요한 경우
    - 데이터 변경이 자주 발생하는 경우
    - 중요한 트렌젝션처리(금융)이 요구되는 경우
  - NoSQL
    - 비구조화 및 비정형화 데이터 다를 때
    - 명확한 데이터 구조를 알 수 없거나 변경될 가능성이 높은 경우
    - 빠른 데이터 조회가 중요한 경우 & 데이터변경보다 조회 요청이 훨 많은 경우
    - 대량의 데이터를 처리하는 경우(DB의 수평적 확장)
  <br/>
  
- **정규화는 무엇인지, 데이터베이스가 제1,2,3정규형에 속하기 위해 어떤 제약조건을 만족해야 하는지 간략히 설명해주세요.**
  - = 속성 간의 종속성으로 인해 이상 현상이 발생하는 릴레이션을 분해하고 재디자인하여 함수적 종속성을 바탕으로 DB를 올바르게 설계해 나가는 과정
  - 제 1정규형 : 모든 속성의 도메인이 더 이상 분해되지 않는 원자 값으로만 구성.. RDB의 릴레이션은 기본적으로 만족ㅇㅇ
  - 제 2정규형 : 제 1정규형에 속하고, 기본 키 제외의 모든 속성이 기본 키에 완전 함수 종속O
  - 제 3정규형 : 제 2정규형에 속하고, 기본 키 제외의 모든 속성이 기본 키에 이행적 함수 종속X
  <br/>
  
- **인덱스에 대해서 설명해주시고, 장단점에 대해 말해주세요.**
  - DB 테이블에서 검색 속도를 향상시키기 위한 자료구조. 책의 목차 및 색인과 동일
  - 장점
    - 테이블 전체를 비교하여 탐색하는 Full Scan 없이도 빠르게 원하는 데이터 조회 가능
    - SELECT 속도 외에도 UPDATE, DELETE 성능 함께 향상
  - 단점
    - 인덱스 관리 위해 DB의 약 10%에 해당하는 저장공간 필요
    - 인덱스 관리 위한 추가 작업이 필요함
    - CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능 오히려 저하
      
      > 크기가 비대해지는 이유 : UPDATE와 DELETE는 기존 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 하기 때문에 실제 데이터 양보다 인덱스 양이 훨많음
  <br/>
  
- **RDBS와 비교하였을 때, NoSQL의 장단점을 말해주세요.**
  - 장점
    - 데이터 구조에 대한 유연성
    - 스키마가 없어서 언제든지 저장된 데이터를 변경하거나 새로운 필드 유연하게 추가 가능
    - 데이터 조회 속도 빠름 (데이터가 조회하고자 하는 형태로 저장되기 때문)
    - 애플리케이션에서 발생시키는 모든 읽기&쓰기 요청 처리 가능
  - 단점
    - 데이터 중복될 수 있음 -> 데이터 중복을 계속 업데이트 해야 함
    - 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행
    - 명확한 데이터 구조 보장 X
  <br/>
  
- **참조 무결성 제약 조건에 대해 설명해주세요.**
  - = 외래 키는 참조 할 수 없는 값을 가질 수 없다는 규정.. 기본 키와 참조 키 간의 관계가 항상 유지됨을 보장해줌
  - 외래 키 값이 NULL이거나 참조 릴레이션의 기본 키 값과 일치해야함(외래 키와 참조하려는 테이블의 기본 키는 도메인과 속성 개수가 같아야 함)
  - 사용자의 실수로 관련 데이터가 삭제 및 수정되는 것을 방지함
  <br/>
  
- **이상현상이란 무엇인지, 어떤 종류가 있는지 말씀해주세요.**
  - = 불필요한 데이터 중복으로 인해 테이블 조작(릴레이션에 대한 연산(데이터 삽입, 수정, 삭제)) 시 발생하는 데이터 불일치 현상
    - 데이터 중복 발생 이유 : 한 릴레이션에 여러 엔티티의 속성이 혼합되어서
  - 삽입 이상 : 원치 않는 데이터가 삽입됨
  - 갱신 이상 : 일부 변경 시, 중복된 튜플이 존재하여 데이터 불일치 문제
  - 삭제 이상 : 특정 데이터만 삭제해야 하는데 튜플 전체가 삭제되어 필요한 데이터까지 같이 삭제되는 데이터 손실 문제
  <br/>
  <br/>
  
## 추가 공부
- 정규형 종류 ..!!
- 무결성 제약 조건(개체, 참조, 도메인, 데이터, 키)
- 도메인, 원자값의 의미 좀 더 자세히
- SQL(수직적 확장) VS NoSQL(수평적 확장) 비교랑 사용하는 경우 수정 좀 ..NoSQL 사용하는 경우 말 좀 바꾸자 오해의 소지 ㅇㅇ
<br/>
<br/>

***
- **트랜잭션과 ACID 원칙에 대해 간단히 설명해주세요.**
  - 트랜잭션 = 하나의 작업을 수행하는데 필요한 SQL문들의 집합. 데이터베이스의 논리적 작업 단위
    - 일반적으로 데이터베이스를 변경하는 INSERT, DELETE, UPDATE문의 실행을 관리함
  - ACID 원칙 = 데이터베이스의 무결성과 일관성을 보장하기 위한 트랜젝션의 4가지 특징
    - 원자성 : 트랜잭션을 구성하는 연산들은 모두 정상적으로 실행되거나 하나도 실행되지 않아야 함(all-or-nothing). 트랜잭션은 부분적으로 or 일부만 실행 X
    - 일관성 : 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 함
    - 격리성 : 한 트랜잭션 수행 시, 다른 트랜잭션이 끼어들 수 없. (현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들은 접근 불가. 독립적 실행. == 직렬성)
    - 지속성 : 트랜잭션이 성공적으로 완료된 후, DB에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 함. 성공적으로 커밋되었으면 트랜잭션에서 기록한 모든 데이터는 손실X. 로깅 기법
<br/>

- **SQL 표준으로 정의된 트랜잭션 격리 수준 READ COMMITED와 REPEATABLE READ의 차이점에 대해 설명해주세요.**
  - READ COMMITED은 Non-Repeatable Read 부정합 발생 / REPEATABLE READ은 Non-Repeatable Read 발생X
  - REPEATABLE READ가 READ COMMITED보다 더 높은 격리 수준으로, 데이터 변경 시, READ COMMITED은 커밋 완료된 변경된 데이터는 다른 트랜잭션에서 조회 가능한 반면 REPEATABLE READ는 변경 후의 데이터에 대해 다른 트랜젝션은 조회할 수 없음.(새 데이터 삽입 시에만 추가된 데이터 조회 가능)
<br/>

- **Redis를 캐시 서버로 사용할 때 가능한 사용 패턴 2가지와 각 패턴을 어떤 경우에 적용하는 것이 적절한지 설명해주세요.**
  1. Look Aside Cache : 데이터를 찾을 때, 캐시에 저장된 데이터가 있는지를 우선적으로 확인하는 패턴. 만약 캐시에 데이터가 없으면 DB에서 조회함
    - 애플리케이션에서 캐싱을 이용할 때, 일반적으로 사용되는 기본적인 캐시 서버 패턴
    - 반복적인 Read가 많은 경우 - 원하는 데이터만 별도로 구성하여 캐시에 저장(캐시와 DB 분리되어있)
    - 반복적으로 동일 쿼리를 수행하는 서비스의 경우
  2. Write Back : 데이터 저장 시 DB가 아닌 캐시에 먼저 저장하여 모아놓았다가 특정 시점마다 DB로 쓰는 패턴. 캐시가 일종의 Queue 역할
    - Write가 빈번하며 Read 시에 많은 양의 Resource가 소모되는 서비스 영역의 경우
    - Data Set이 큰 경우 - DB를 조회하지 않고 지속적 접근 가능
<br/>

- **Redis를 사용해본 적이 있다면 어떤 부분에 사용했는지 왜 Redis를 선택했는지 말씀해주세요.**
  - 장점을 말하는고징? 어떨 때 좋은지 + 그 어떨 때 왜 좋은지
  - 사용해본 적은 없지만 한다면 인메모리 데이터베이스로 DB, 캐시, 메시지 브로커 등으로 사용할거당
  - 이유
    - 전체 서비스 속도 향상을 위한 보조 데이터베이스로 사용
    - 기존 데이터베이스의 느린 처리 속도를 극복하고자 디스크가 아닌 주 메모리에 데이터 저장
    - -> 메모리에서 데이터를 처리하기 때문에 속도 빠름
    - Key-Value 구조로 쿼리 사용할 필요 없!
    - 영속성 지원ㅇㅇ
<br/>

- **교착상태란 무엇인지와 교착상태가 이루어지기 위한 필요조건 4가지를 말씀해주세요.**
  - = 둘 이상의 프로세스들이 이미 자원을 점유하고 있는 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며, 무한정으로 기다리는 현상. 
  - 4가지 필요조건
    - 상호 배제 : 1번에 1개의 프로세스만이 공유자원을 사용할 수 있음
    - 점유와 대기 : 자원을 최소한 1개 보유하면서, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함.
    - 비선점 : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺴앗을 수 없음
    - 환형 대기 : Hold and Wait 관계의 프로세스들이 서로를 기다림 <br/>
      > 프로세스의 자원 점유와 이미 점유된 자원에 대한 요구 관계가 원형을 이루며 대기함 -> 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 보유 
<br/>

- **SQL Injection의 종류 중 Error based SQL Injection에 대해 설명해주세요.**
  - = 잘못된 문법이나 자료형 불일치 등에 의해 웹 브라우저에 표시되는 DB 오류와 같은 논리적 에러를 이용한 가장 대중적인 SQL Injection
  - 공격자는 의도적인 오류를 통해 얻은 정보들을 바탕으로 DB명, 테이블, 컬럼 정보 등 파악 가능
  - 로그인 SQL구문에서 입력값에 대한 검증이 없음을 확인하고 악의적으로 임의의 SQL구문 주입 <br/>
    -> 그 후, Users테이블의 모든 정보를 조회하여 가장 먼저 만들어진 관리자 계정으로 로그인 <br/>
    -> 관리자의 권한을 악용하므로 또 다른 2차 피해 발생 가능성도 생김ㅜㅅㅜ!
