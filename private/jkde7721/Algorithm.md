## 알고리즘 면접 질문 리스트

<details>
    <summary>시간복잡도가 O(n^2)인 정렬 알고리즘 중 하나에 대해 설명해주세요.</summary>
    <br/><code>선택 정렬</code>, <code>삽입 정렬</code>, <code>버블 정렬</code><br/><br/>

    선택 정렬
    - 특정 범위에서 가장 작은 값을 찾아 특정 위치와 교환하는 방식의 정렬
    - 매 순서에서 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
    - 자료 이동 횟수가 미리 결정됨


    삽입 정렬
    - 정렬된 데이터 그룹을 늘려가며 추가되는 데이터는 알맞은 자리에 삽입하는 방식의 정렬
    - 매 순서마다 이미 정렬된 배열 부분에서 해당 원소를 삽입할 위치를 찾아 해당 위치에 넣는 알고리즘
    - 대부분의 원소가 이미 정렬되어 있는 경우에 매우 효율적 → O(N)의 시간복잡도
    - 비교적 많은 원소들의 이동을 포함


    버블 정렬
    - 인접한 두 수를 비교하며 정렬해나가는 방식 (작은 숫자는 왼쪽으로, 큰 숫자는 오른쪽으로 이동)
    - 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝 원소가 정렬에서 제외 → 정렬 1회전 수행 시마다 정렬에서 제외되는 데이터가 하나씩 늘어남
    - 하나의 원소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 원소들과 교환되어야 함 → 특정 원소가 이미 최종 정렬 위치에 있는 경우라도 교환 발생

</details>

<details>
    <summary>시간복잡도가 O(nlogn)인 정렬 알고리즘 중 하나에 대해 설명해주세요.</summary>
    <br/><code>퀵 정렬</code>, <code>힙 정렬</code>, <code>병합 정렬</code><br/><br/>

    퀵 정렬
    - 기준이 되는 pivot 값을 정한 후 pivot 기준으로 분할, 정렬하는 방식

    1. 리스트 안에 있는 한 원소를 선택, 이렇게 고른 원소는 피벗(pivot)
    2. 피벗을 기준으로 피벗보다 작은 원소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 원소들은 모두 피벗의 오른쪽으로 옮겨짐 (피벗을 중심으로 왼쪽: 피벗보다 작은 원소들, 오른쪽: 피벗보다 큰 원소들)
    3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 재정렬
        - 분할된 부분 리스트에 대해 재귀호출을 이용하여 정렬 반복
        - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복
    4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복
        - 리스트의 크기가 0이나 1이 될 때까지 반복

    - 시간 복잡도가 O(NlogN)인 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다. (퀵 정렬이 데이터의 불필요한 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문)
    - 추가 메모리 공간 필요X
    - 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행 시간이 더 길어짐 → 퀵 정렬의 불균형 분할을 방지하기 위해 피벗 선택 시 리스트를 균등하게 분할할 수 있는 데이터를 선택


    힙 정렬
    - 힙: 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조, 최댓값, 최솟값을 쉽게 구할 수 있는 자료구조
    - 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방식
    - 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰/작은 값 몇 개만 필요한 경우

    1. 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태) 생성 (내림차순으로 정렬하는 경우)
    2. 한 번에 하나씩 원소를 힙의 루트 노드에서 꺼내 배열의 뒤부터 저장
    3. 삭제되는 원소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬


    병합 정렬
    - 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 병합하여 정렬된 전체 리스트를 생성하는 방식
    - 병합 시 추가적인 메모리 공간이 필요

    - 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할
    - 정복(Conquer): 부분 배열을 정렬, 부분 배열의 크기가 충분히 작지 않으면 재귀호출을 이용해 다시 분할 정복 방법 적용
    - 결합(Combine): 정렬된 부분 배열들을 하나의 배열로 병합
    1. 2개의 리스트의 값들을 처음부터 하나씩 비교하여 두 개의 리스트의 값 중에서 더 작은 값을 새로운 리스트(sorted)로 옮김
    2. 둘 중 하나가 끝날 때까지 이 과정을 되풀이
    3. 만약 둘 중 하나의 리스트가 먼저 끝나게 되면 나머지 리스트의 값들을 전부 새로운 리스트(sorted)로 복사
    4. 새로운 리스트(sorted)를 원래의 리스트(list)로 복사

</details>
