## 데이터 구조 면접 질문 리스트

<details>
    <summary>해시 테이블(Hash Table)과 시간복잡도에 대해 설명해주세요.</summary>
    <br/><code>key-value 1:1 매핑</code>, <code>O(1)</code>, <code>O(N)</code><br/><br/>

    해시 테이블은 해시 함수를 사용하여 키를 해시 값으로 매핑하고, 이 해시 값을 색인 또는 주소 삼아 데이터(value)를 key와 함께 저장하는 자료구조입니다.
    해시 테이블은 key-value가 1:1로 매핑되어 있기 때문에 삽입, 삭제, 탐색 연산에 평균적으로 O(1)의 시간복잡도가 걸립니다.
    그러나 해시 충돌이 발생한 경우 버킷의 연결 리스트를 모두 탐색하거나 해시 테이블을 선형 탐색하여 해당 키를 저장하고 있는 버킷을 찾아야 하므로 시간복잡도가 O(N)까지 증가할 수 있습니다.

</details>

<details>
    <summary>해시 충돌이 발생하는 이유와 충돌 해결 전략(예: 체이닝, 개방 주소법)에 대해서 간략히 설명해주세요.</summary>
    <br/><code>해시 테이블의 크기</code>, <code>해시 함수의 단순성</code>, <code>연결 리스트</code>, <code>고정 크기의 해시 테이블</code><br/><br/>

    메모리 낭비 방지를 위해 보통의 경우 실제 사용하는 키의 개수보다 적은 버킷을 가진 해시 테이블을 사용합니다. 즉 키 당 하나의 버킷이 할당되는 것이 아니기 때문에 서로 다른 키의 해시값이 같아지는 해시 충돌 문제가 발생합니다. 이 외에도 해시 함수가 너무 단순한 경우 서로 다른 키의 해시값이 같아질 수 있습니다.
    이러한 해시 충돌은 100% 피할 수 없는 문제이기 때문에 해시 충돌을 해결하는 방법이 매우 중요해지는데요. 여기에는 크게 2가지 방법이 있습니다.
    먼저 버킷을 연결 리스트 형태로 관리하여 충돌이 난 경우 해당 버킷의 연결 리스트에 데이터를 추가하도록 하는 체이닝 방법이 있습니다. 체이닝은 연결 리스트의 특성을 그대로 지녀 데이터의 삽입, 삭제 연산에 O(1)의 시간복잡도가 걸리는 반면 탐색에는 O(N)의 시간복잡도가 걸립니다. 또한 해시 충돌을 대비해 별도의 공간을 미리 할당해둘 필요가 없어 메모리 공간을 보다 유연하게 관리할 수 있으며, 해시 테이블이 특정 수준으로 꽉 찼을 때 발생하는 테이블 확장을 늦출 수 있다는 장점이 있습니다. 그러나 하나의 버킷에만 데이터가 많이 저장되는 데이터 쏠림 현상이 발생하면 메모리 낭비와 더불어 데이터 탐색의 효율이 떨어진다는 문제점이 있습니다.
    다음으로는 해시 충돌이 발생했을 때 비어있는 다른 해시 버킷을 찾아 데이터를 저장하는 개방 주소법이 있습니다. 비어있는 버킷을 찾는 방법에 따라 선형 탐색, 제곱 탐색, 이중 해싱으로 나뉘며, 하나의 버킷에 하나의 데이터만 저장되기 때문에 체이닝에 비해 메모리 낭비가 덜하지만 테이블 확장이 자주 발생할 수 있습니다.

</details>

<details>
    <summary>힙과 시간 복잡도에 대해 설명해주세요.</summary>
    <br/><code>우선순위 큐</code>, <code>삽입/삭제 O(logN)</code><br/><br/>

    먼저 힙이란 우선순위 큐를 위해 만들어진 자료구조로, 여러 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위해 고안된 완전 이진 트리의 일종입니다. 부모의 값이 자식의 값보다 큰 가, 작은 가에 따라 최대 힙, 최소 힙으로 구분되며, 루트 노드에는 항상 전체 데이터 중 가장 큰 값 또는 가장 작은 값이 저장되기 때문에 최대값, 최소값을 O(1)의 시간복잡도로 구할 수 있습니다. 데이터의 삽입, 삭제 시에는 힙의 특징을 만족하도록 트리를 재구성하는 과정에서 O(logN)의 시간복잡도가 소요됩니다.

</details>

<details>
    <summary>(최대 힙, 최소 힙에 대한 상황이 주어지고) 삽입과 삭제 시 어떻게 진행되나요?. (그림이 있을 때 설명 가능하도록 연습하시면 좋을 것 같습니다!)(우선순위를 정하고, 트리의 부모-자식에 대한 swap이 일어나는 과정을 잘 설명할 줄 알아야 한다.)</summary>
    <br/>

    삽입
    1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입한다.
    2. 새로운 노드를 부모 노드들과 교환한다.
    3. 규칙에 맞으면 그대로 두고(최대힙: 부모 > 자식, 최소힙: 부모 < 자식>), 그렇지 않으면 부모와 교환한다. (부모 노드는 삽입된 위치의 인덱스 번호에서 /2를 하면 쉽게 구할 수 있다.)
    4. 규칙에 맞을 때까지 3번 과정을 반복한다.


    삭제
    1. 루트 노드를 제거한다.
    2. 루트 자리에 가장 마지막 노드를 삽입한다.
    3. 루트 노드와 그 자식 노드를 비교한다.
    4. 조건에 만족하면 그대로 두고, 그렇지 않으면 자식과 교환한다.

    최대 힙
    i. 부모보다 더 큰 자식이 없으면 교환하지 않고 끝낸다.
    ii. 부모보다 더 큰 자식이 하나만 있으면 그 자식과 교환한다.
    iii. 부모보다 더 큰 자식이 둘 있으면 자식들 중 큰 값과 교환한다.

    최소 힙
    i. 부모보다 더 작은 자식이 없으면 교환하지 않고 끝낸다.
    ii. 부모보다 더 작은 자식이 하나만 있으면 그 자식과 교환한다.
    iii. 부모보다 더 작은 자식이 둘 있으면 자식들 중 작은 값과 교환한다.

    5. 조건을 만족할 때까지 4의 과정을 반복한다.

</details>

<details>
    <summary>ArrayList(배열)와 LinkedList(연결 리스트)의 차이점과 둘의 장단점에 대해 설명해주시고, 어떤 상황에 각 자료구조를 사용하는 것이 적절한지 이유와 함께 설명해주세요.</summary>
    <br/><code>저장공간의 정적/동적 크기</code>, <code>저장공간의 연속성</code>, <code>탐색/삽입/삭제 연산 속도</code><br/><br/>

    배열은 저장공간의 크기가 고정되어 있어 배열 크기 확장 시 크기가 더 큰 새로운 배열을 생성하고 복사하는 과정이 필요합니다. 반면 연결 리스트는 추가적인 작업 없이 리스트의 크기를 동적으로 확장할 수 있습니다.
    배열의 저장공간은 실제 메모리 상에서 연속적으로 위치하기 때문에 인덱스를 통해 원하는 원소에 O(1)의 시간복잡도로 탐색할 수 있는 반면, 연결 리스트는 각 원소들이 메모리 상에 불연속적으로 위치하여 리스트의 맨 앞 원소부터 원하는 원소까지 순차적으로 탐색해야 하므로 탐색 연산에 O(N)의 시간복잡도가 걸립니다.
    배열의 중간에 삽입, 삭제 연산 시 빈 공간을 확보하거나 제거하기 위해 일련의 원소들의 위치를 옮기는 추가 작업이 필요하므로 O(N)의 시간복잡도가 걸리는 반면, 연결 리스트의 중간에 삽입, 삭제 연산 시에는 해당 원소 앞뒤의 원소들의 포인터 값만 바꿔주면 되므로 O(1)의 시간복잡도로 빠르게 수행할 수 있습니다.

    이러한 특성으로 데이터의 개수가 한정되어 있고 탐색 연산이 주로 발생하며, 삽입, 삭제 연산은 배열의 마지막에 대해서만 발생하는 경우에는 배열을 사용하는 것이, 반면 데이터의 개수가 유동적이면서 탐색 연산은 거의 발생하지 않고 주로 삽입, 삭제 연산이 많이 발생하는 경우에는 연결 리스트를 사용하는 것이 좋습니다.

</details>

<details>
    <summary>백엔드 현업에서 ArrayList와 LinkedList 중 자주 사용되는 것과 그 이유는?</summary>

    현업에서 중간에 삽입/삭제하는 연산은 거의 없으며 마지막에 삽입/삭제하는 연산이 더 자주 발생, 또한 탐색 연산이 자주 발생하는데 인덱스를 통해 빨리 찾을 수 있는 장점이 더 크기 때문에 ArrayList를 주로 사용 (연결 리스트는 트리 구현에 주로 사용)

</details>

<details>
    <summary>스택과 큐의 특징을 간략히 설명해주시고, 만약 직접 스택과 큐를 구현해야 한다면 저장 공간으로 어떤 자료구조를 사용할 것인지 이유와 함께 설명해주세요.</summary>
    <br/><code>스택 - 배열</code>, <code>큐 - 연결 리스트</code><br/><br/>

    스택은 마지막에 들어간 데이터를 먼저 꺼내는 LIFO 구조로, 스택의 가장 윗부분인 top에서만 데이터 삽입, 삭제 연산이 발생합니다. 반면 큐는 먼저 들어간 데이터를 먼저 꺼내는 FIFO 구조로, 큐의 가장 앞 부분인 front에서는 데이터 삭제 연산만, 가장 뒷 부분인 rear에서는 삽입 연산만 발생합니다.
    스택은 마지막 인덱스인 top에서만 삽입/삭제 연산이 발생하므로 배열을 사용하는 것이 적절합니다. (연결 리스트의 메모리량 > 배열의 메모리량)
    큐는 맨 앞 인덱스인 front에서 삭제 연산이 발생하는데 이때 배열을 사용하면 삭제 연산 시마다 매번 전체 데이터를 한 칸씩 앞으로 이동해주는 작업이 필요하기 때문에 삭제 연산에 O(1)의 시간복잡도가 걸리는 연결 리스트를 사용하는 것이 적절합니다.

</details>

<details>
    <summary>그래프 구현법 2가지에 대해 설멍해주세요. 그리고 두 방법의 장단점에 대해 비교해주세요.</summary>
    <br/><code>인접 행렬</code>, <code>인접 리스트</code><br/><br/>

    인접 행렬은 그래프의 노드를 2차원 배열로 만들고 배열의 데이터로 각 노드 간 연결 여부를 표현하는 방법입니다. (0 - 연결X, 1 - 연결O) 따라서 두 노드 간 연결 여부를 O(1)의 시간복잡도로 확인할 수 있습니다. 그러나 인접 행렬을 생성하기 위해서는 O(N^2)의 시간복잡도가 소요되며 인접하지 않는 관계 또한 저장하기 때문에 메모리 낭비가 발생합니다. (+ 간선이 얼마 없는 희소 그래프의 경우에도 메모리 낭비)

    인접 리스트는 각 노드가 자신과 인접한 모든 노드 목록을 리스트로 관리하는 방법입니다. 두 노드 간 연결 여부를 알아내기 위해 인접 리스트에 대한 순차 탐색으로 O(N)의 시간복잡도가 소요되는 반면 인접 관계에 있는 노드만을 저장하기 때문에 인접 행렬에 비해 사용되는 메모리 양이 적다는 장점이 있습니다.

    *어떤 경우에 인접 행렬, 어떤 경우에 인접 리스트 사용?
    : 그래프의 희소성에 따라, 그래프로 뭐 할건지에 따라(그래프 전체 탐색? 노드 간 연결 여부 질의?)

</details>

<details>
    <summary>트리 탐색법 2가지 중 1개에 대해 설명해주시고 어느 상황에서 사용하는 것이 적절한지 설명해주세요.</summary>
    <br/><code>DFS</code>, <code>BFS</code><br/><br/>

    트리 전체를 탐색하는 방법으로는 DFS와 BFS가 있습니다.

    먼저 BFS는 루트 노드에서 시작해 인접한 노드를 먼저 탐색하는 방법으로 트리의 레벨을 순차적으로 탐색한다는 특징이 있습니다.
    반면 DFS는 루트 노드에서 시작해 자식 노드를 먼저 탐색하고 리프 노드를 만나면 다시 상위 노드로 올라가 탐색하지 않은 자식 노드들을 탐색하는 방법입니다. (갈 수 있는 한 최대한 깊게 탐색)

    일반적으로 BFS는 큐를 이용해, DFS는 함수의 재귀호출을 사용하여 구현되며 보통 트리 전체 탐색 시 둘의 성능 상 차이는 거의 없지만, 트리의 깊이가 깊은 경우 깊은 재귀 호출로 스택 오버플로우가 발생할 수 있기 때문에 이 경우에는 BFS를 사용하는 것이 좋습니다.
    DFS는 재귀호출을 이용하기 때문에 주로 백트래킹 알고리즘에서 사용되며 BFS는 가중치가 같은 최단거리 알고리즘에서 주로 사용됩니다.

    *전위 순회는 트리 복사에 주로 사용 (트리는 부모 노드가 생성되어야 자식 노드가 생성되기 때문)

</details>
