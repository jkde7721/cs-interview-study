## 데이터베이스 면접 질문 리스트

<details>
    <summary>Index의 자료구조 대표적 예시 2가지를 설명하고 각각의 장단점을 말씀해주세요. / 인덱스 알고리즘 중 B-Tree와 B+Tree의 차이점을 설명해주세요.</summary>
    <br/><code>해시 테이블</code>, <code>B-Tree</code>, <code>B+Tree</code>, <code>데이터 포인터 저장 노드</code>, <code>리프 노드 연결</code><br/><br/>

    Index 구현을 위한 자료구조에는 대표적으로 B-Tree, B+Tree가 있습니다. B-Tree는 자식 노드가 2개 이상인 트리로 이진 탐색 트리에 비해 높이가 더 작아 보다 빠른 탐색이 가능합니다. B-Tree의 모든 노드는 실제 데이터의 물리적 위치를 가리키는 데이터 포인터를 가지고 있어 리프 노드까지 가지 않아도 원하는 데이터를 찾을 수 있습니다. 그러나 노드가 key를 기준으로 항상 정렬되어 있어야 하며 균형을 유지해야 하기 때문에 삽입/수정/삭제 연산 시에는 추가 작업으로 인해 실행 속도가 더 느려집니다.

    B+Tree는 B-Tree를 개선시킨 자료구조로 B-Tree와 다르게 오직 리프 노드의 Key만이 데이터 포인터를 가지고 있습니다. 따라서 원하는 데이터를 찾기 위해서는 리프 노드까지 항상 탐색해야 하지만 내부 노드에 더 많은 key를 저장할 수 있어 트리의 높이가 줄어들어 검색 효율을 향상시킬 수 있습니다. 반면 B+Tree의 모든 리프 노드는 Linked List 형태로 연결되어 있어 범위 검색 연산이 더 빠르고 효율적입니다.

</details>

<details>
    <summary>RDBMS와 NoSQL은 각각 어느 경우에 사용하기 적합한지에 대해 설명해주세요. / SQL vs NoSQL의 차이점과 어떤 상황에 어떤 데이터베이스가 적합한지 이유와 함께 설명해주세요. / RDBMS와 비교하였을 때, NoSQL의 장단점을 말해주세요.</summary>
    <br/><code>Schema</code>, <code>Relation</code>, <code>Scaling</code><br/><br/>

    SQL과 NoSQL은 크게 2가지 부분에서 차이점을 보입니다. 바로 Schema, Relation입니다. SQL의 테이블은 Schema, 즉 데이터의 구조가 정해져 있어 해당 구조를 따르는 데이터만을 저장할 수 있습니다. 반면 NoSQL의 콜렉션은 확정된 Schema가 존재하지 않아 어떤 구조의 데이터도 저장할수 있습니다. 다음으로 SQL은 테이블 간 관계를 맺을 수 있어 연관 데이터가 필요하면 조인을 통해 해당 데이터를 조회할 수 있습니다. 따라서 데이터가 테이블에 딱 한번만 저장된다는 특징이 있습니다. 반면 NoSQL은 연관된 데이터는 콜렉션에 모두 저장하기 때문에 콜렉션 간 데이터가 중복으로 저장된다는 특징이 있습니다.

    RDBMS의 테이블의 스키마를 변경하는 것은 어렵기 때문에 저장되는 데이터의 구조가 확정되었거나 변경될 가능성이 낮은 경우에 적합합니다. 또한 테이블 간 관계를 맺을 수 있어 데이터가 한 테이블에 오직 1번만 저장되어 변경이 쉬우므로 데이터에 대한 변경이 많이 발생하는 경우에도 RDBMS를 사용하는 것이 좋습니다.

    반대로 데이터의 구조를 파악하기 어렵거나 변경될 가능성이 높다면 RDBMS 보다는 NoSQL이 더 적합합니다. NoSQL은 하나의 콜렉션에 연관된 데이터를 모두 저장하고 있어 콜렉션 간 중복되는 데이터가 많습니다. 따라서 데이터 변경 연산이 여러 콜렉션에 대해 연쇄적으로 발생할 수 있습니다. 즉 데이터 변경 연산이 조회 연산 보다 무겁기 때문에 변경 연산은 적으면서 연관된 데이터에 대한 조회가 주로 발생하는 경우에도 NoSQL을 사용하는 것이 좋습니다.

    무엇보다 서버를 증설하여 처리량을 높이는 horizontal scaling은 NoSQL만 가능하기 때문에 대용량의 데이터를 처리하고 요청이 많이 발생하는 경우에는 RDBMS 보다는 NoSQL이 적합합니다.

    NoSQL은 어떤 구조의 데이터도 저장할 수 있어 데이터 구조에 대한 유연성이 있으며 연관된 데이터 조회 시에도 콜렉션들을 조인할 필요 없이 하나의 콜렉션에서 빠르게 조회할 수 있습니다. 또한 수평적 확장이 가능하기 때문에 처리량에 대한 한계 없이 대용량의 데이터를 처리할 수 있습니다.
    반면 데이터 구조가 확정되어 있지 않기 때문에 데이터 무결성이 깨질 수 있으며 콜렉션 간 중복되는 데이터가 많아 데이터 삽입/수정/삭제 시 여러 컬렉션이 영향을 받을 수 있습니다.

</details>

<details>
    <summary>정규화 과정에서 사용되는 함수 종속성이 무엇이며, 함수 종속성의 종류에 대해 설명해주세요</summary>
    <br/><code>릴레이션 내 속성 간 연관성</code>, <code>완전 함수 종속성</code>, <code>부분 함수 종속성</code>, <code>이행적 함수 종속성</code><br/><br/>

    함수 종속성은 특정 릴레이션 내에서 속성 간 연관 관계를 파악할 수 있도록 해주는 특성으로 이를 통해 관련 있는 속성들로만 릴레이션을 구성하여 정규화를 수행할 수 있습니다.
    릴레이션 내 특정 속성 집합 X에 대해 오직 하나의 속성 집합 Y가 대응된다면 X가 Y를 결정한다 또는 Y가 X에 종속된다 라고 표현할 수 있습니다. 함수 종속성의 종류에는 완전 함수 종속성, 부분 함수 종속성, 이행적 함수 종속성이 있는데, 먼저 완전 함수 종속성이란 속성 집합 Y가 X의 부분 속성에 대해 종속되지 않으면서 전체 속성 집합 X에만 종속되는 것을 의미합니다. 반면 부분 함수 종속성은 속성 집합 Y가 X의 부분 속성에도 종속되는 것을 말합니다. 마지막으로 X → Y 형태의 함수 종속성 관계가 존재할 때 Y → Z 함수 종속 관계도 존재한다면 Z가 Y를 통해 X에 이행적으로 종속된다고 표현할 수 있습니다.

</details>

<details>
    <summary>정규화는 무엇인지, 데이터베이스가 제1,2,3정규형에 속하기 위해 어떤 제약조건을 만족해야 하는지 간략히 설명해주세요.</summary>
    <br/><code>함수적 종속성</code>, <code>이상현상</code><br/><br/>

    먼저 정규화란 함수적 종속성을 바탕으로 연관된 속성들로만 릴레이션이 구성되도록 분해하여 이상 현상이 발생하지 않도록 릴레이션을 설계하는 것입니다.
    제1정규형에 속하기 위해서는 릴레이션의 모든 속성이 원자값으로 구성되어 있어야 합니다. 따라서 관계형 데이터베이스는 항상 제1정규형에 속합니다. 다음으로 제2정규형에 속하기 위해서는 기본키가 아닌 모든 속성이 기본키 속성에 완전 함수 종속되어야 합니다. 만약 기본키에 부분 함수 종속되는 속성이 있다면 릴레이션을 분해하여 해당 종속 관계를 제거해줍니다. 마지막으로 기본키가 아닌 속성이 기본키 속성에 이행적 함수 종속되지 않는다면 제3정규형에 속할 수 있습니다. 마찬가지로 이행적 함수 종속 관계가 존재한다면 종속 관계가 이행되지 않도록 릴레이션을 분해해줍니다.

</details>

<details>
    <summary>인덱스에 대해서 설명해주시고, 장단점에 대해 말해주세요.</summary>
    <br/><code>대량의 데이터 검색</code>, <code>검색 속도 향상</code>, <code>추가적인 저장공간</code>, <code>조회 fast, 삽입/삭제/수정 slow</code><br/><br/>

    인덱스란 추가적인 저장 공간에 미리 정렬된 정보를 저장함으로써 테이블 검색 속도를 향상시키기 위한 자료구조입니다. 만약 테이블에 1억개의 행이 존재하는 경우 해당 테이블에 대한 인덱스가 없는 조회 연산은 full table scan으로 매우 많은 시간을 걸릴 수 있습니다. 따라서 마치 책의 인덱스 처럼 자주 조회되는 컬럼을 기준으로 데이터의 위치를 별도의 공간에 저장함으로써 보다 빠르게 데이터를 조회할 수 있도록 해줍니다. 그러나 인덱스를 통해 조회 속도는 빨라질 수 있지만 잘못 사용할 경우 저장공간을 낭비할 수 있으며 또한 인덱스로 사용한 컬럼에 대한 삽입/수정/삭제 시에는 기존의 인덱스 구조를 모두 변경해야 하기 때문에 많은 시간이 소요될 수 있습니다.

</details>

<details>
    <summary>테이블의 어떤 컬럼을 인덱스로 사용하는 것이 효율적인지 이유와 함께 설명해주세요.</summary>
    <br/><code>카디널리티↑</code>, <code>변경↓</code>, <code>where, group by, order by</code><br/><br/>

    전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표인 카디널리티가 높은 컬럼을 우선적으로 인덱싱해야 합니다. 만약 중복 수치가 높은 컬럼에 대해 인덱싱하는 경우 full table scan과 비슷한 성능을 낼 수 있습니다. 또한 인덱스로 사용한 컬럼에 대한 삽입/수정/삭제 연산 시 인덱스 구조 또한 변경해주어야 하므로 데이터가 변경될 가능성이 낮은 컬럼을 우선적으로 인덱싱해야 합니다. 마지막으로 인덱스는 where, group by, order by 절에서 사용될 수 있으므로 해당 절의 조건문에 자주 사용되는 컬럼을 우선적으로 인덱싱해야 합니다.

</details>

<details>
    <summary>참조 무결성 제약 조건에 대해 설명해주세요.</summary>
    <br/><code>참조되는 테이블의 기본키</code>, <code>참조하는 테이블의 외래키</code><br/><br/>
    
    참조하는 테이블의 외래키 값은 참조되는 테이블의 기본키 값만을 참조할 수 있다는 것을 의미합니다. 따라서 만약 참조되는 테이블의 기본키 속성값을 수정하거나 행을 삭제하는 경우 참조 무결성 제약 조건을 위반하지 않도록 DDL을 통해 별도의 설정이 가능합니다.

</details>

<details>
    <summary>이상현상이란 무엇인지, 어떤 종류가 있는지 말씀해주세요.</summary>
    <br/><code>삽입 이상</code>, <code>갱신 이상</code>, <code>삭제 이상</code><br/><br/>

    이상현상은 잘못된 릴레이션의 설계로 인해 데이터 삽입/수정/삭제 시 발생하는 부작용입니다. 먼저 삽입 이상은 새로운 데이터 추가 시 불필요한 데이터도 함께 삽입해야 하는 문제를 의미하며, 갱신 이상은 중복되는 튜플 중 일부만 수정되어 데이터가 불일치하는 모순이 발생하는 것을, 삭제 이상은 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되어 데이터가 손실되는 것을 말합니다.

</details>

<hr/>

<details>
    <summary>트랜잭션과 ACID 원칙에 대해 간단히 설명해주세요.</summary>
    <br/><code>데이터베이스 연산들의 집합</code>, <code>논리적인 작업 단위</code>, <code>원자성(Actomicity)</code>, <code>일관성(Consistency)</code> <code>격리성(Isolation)</code>, <code>지속성(Durability)</code><br/><br/>

    트랜잭션은 하나의 작업을 수행하는데 필요한 데이터베이스 연산들의 집합으로 논리적인 작업 단위를 의미합니다. 이때 데이터베이스의 무결성과 일관성을 보장하기 위해 트랜잭션은 ACID라는 4가지 원칙을 준수해야 합니다.

    각각에 대해 설명하자면 먼저 원자성은 트랜잭션 내 연산은 모두 성공하거나 실패해야 한다는 원칙입니다. 즉 트랜잭션의 일부 연산만 수행된 결과를 데이터베이스에 반영해서는 안됩니다. 다음으로 일관성은 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야한다는 속성입니다. 이때 일관된 상태는 데이터베이스의 제약조건을 일관되게 준수한다는 데이터베이스 관점에서의 정의 뿐만아니라 어플리케이션 관점에서 데이터의 일관성을 정의내릴 수 있습니다. 다음으로 격리성은 특정 트랜잭션의 중간 연산 결과에 다른 트랜잭션이 접근할 수 없다는 속성입니다. 즉 각 트랜잭션은 독립적으로 수행되어야 한다는 의미로, 동시 처리 성능을 위해 해당 속성은 지켜지지 않을 수 있습니다. 마지막으로 지속성은 성공적인 트랜잭션 수행 결과는 데이터베이스에 영구적으로 저장되어야 한다는 속성업니다. 이를 위해 트랜잭션의 모든 연산 결과를 로깅하여 데이터베이스 장애 발생 시 데이터를 복구할 수 있습니다.

</details>

<details>
    <summary>SQL 표준으로 정의된 트랜잭션 격리 수준 <code>READ COMMITED</code>와 <code>REPEATABLE READ</code>의 차이점에 대해 설명해주세요.</summary>
    <br/><code>Dirty Read</code>, <code>Non-Repeatable Read</code>, <code>Phantom Read</code><br/><br/>

    두 격리 수준 모두 커밋되지 않은 데이터에 대해서는 접근 불가하여 유효하지 않은 데이터를 읽는 Dirty Read와 같은 데이터 부정합 문제는 발생하지 않습니다. 반면 READ COMMITED는 한 트랜잭션 내에서 처음 읽은 데이터를 다른 트랜잭션이 변경하고 커밋한 후 다시 읽으면 다른 데이터 값을 읽어와 데이터의 정합성이 깨집니다. 즉 Non-Repeatable Read 문제가 발생합니다. 반면 REPEATABLE READ에서는 한 트랜잭션 내에서 처음 읽은 데이터의 내용은 변경되지 않음을 보장하여 해당 부정합 문제가 발생하지 않습니다. 그러나 새로운 데이터가 추가된다면 처음 조회 결과에는 없던 행이 추가되어 조회되는 Phantom Read 문제는 여전히 발생할 수 있습니다.

</details>

<details>
    <summary>Redis를 캐시 서버로 사용할 때 가능한 사용 패턴 2가지와 각 패턴을 어떤 경우에 적용하는 것이 적절한지 설명해주세요.</summary>
    <br/><code>Look Aside Cache</code>, <code>Write Back</code><br/><br/>

    Look Aside Cache와 Write Back 패턴이 있습니다. 먼저 LAC는 데이터 조회 시 캐시를 먼저 조회하여 데이터가 없는 경우 데이터베이스를 조회하는 방식입니다. 자주 사용되는 데이터를 캐시에 올려놓아 조회 속도를 향상시킬 수 있습니다.
    반면 WB은 웹 서버의 모든 연산은 일정 시간 동안 캐시 서버를 대상으로 수행됩니다. 이후 캐시 서버에 있는 데이터를 데이터베이스에 한번에 저장하는 배치 작업울 수행합니다.
    LAC 패턴은 일반적인 어플리케이션에서 조회 성능 향상을 위해 주로 사용하며 WB은 데이터 손실이라는 단점이 있기 때문에 중요한 데이터 보다는 로그를 DB에 저장하기 위해서 또는 대량의 Write 작업이 발생하여 데이터베이스가 다운될 위험이 있을 떄 사용할 수 있습니다.

</details>

<details>
    <summary>Redis를 사용해본 적이 있다면 어떤 부분에 사용했는지 왜 Redis를 선택했는지 말씀해주세요.</summary>
</details>

<details>
    <summary>SQL Injection의 종류 중 Error based SQL Injection에 대해 설명해주세요.</summary>

    먼저 SQL Injection이란 임의의 SQL문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위를 말합니다. 그 중 Error based SQL Injection은 잘못된 문법이나 자료형이 일치하지 않는 SQL을 입력값으로 전달하여 의도적인 오류를 유발시킵니다. 이후 웹 브라우저에 표시되는 오류 메시지를 기반으로 데이터베이스, 테이블, 컬럼명 등을 파악하고 해당 정보를 이용해 민감한 정보들을 탈취하는 방법입니다.

</details>
