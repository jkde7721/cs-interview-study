## 데이터베이스 면접 질문 리스트

<details>
    <summary>Index의 자료구조 대표적 예시 2가지를 설명하고 각각의 장단점을 말씀해주세요. / 인덱스 알고리즘 중 B-Tree와 B+Tree의 차이점을 설명해주세요.</summary>
    <code>해시 테이블</code> <code>B-Tree</code> <code>B+Tree</code> <code>데이터 포인터 저장 노드</code> <code>리프 노드 연결</code>

    Index 구현을 위한 자료구조에는 대표적으로 B-Tree, B+Tree가 있습니다. B-Tree는 자식 노드가 2개 이상인 트리로 이진 탐색 트리에 비해 높이가 더 작아 보다 빠른 탐색이 가능합니다. B-Tree의 모든 노드는 실제 데이터의 물리적 위치를 가리키는 데이터 포인터를 가지고 있어 리프 노드까지 가지 않아도 원하는 데이터를 찾을 수 있습니다. 그러나 노드가 key를 기준으로 항상 정렬되어 있어야 하며 균형을 유지해야 하기 때문에 삽입/수정/삭제 연산 시에는 추가 작업으로 인해 실행 속도가 더 느려집니다.

    B+Tree는 B-Tree를 개선시킨 자료구조로 B-Tree와 다르게 오직 리프 노드의 Key만이 데이터 포인터를 가지고 있습니다. 따라서 원하는 데이터를 찾기 위해서는 리프 노드까지 항상 탐색해야 하지만 내부 노드에 더 많은 key를 저장할 수 있어 트리의 높이가 줄어들어 검색 효율을 향상시킬 수 있습니다. 반면 B+Tree의 모든 리프 노드는 Linked List 형태로 연결되어 있어 범위 검색 연산이 더 빠르고 효율적입니다.

</details>

<details>
    <summary>RDBMS와 NoSQL은 각각 어느 경우에 사용하기 적합한지에 대해 설명해주세요. / SQL vs NoSQL의 차이점과 어떤 상황에 어떤 데이터베이스가 적합한지 이유와 함께 설명해주세요. / RDBMS와 비교하였을 때, NoSQL의 장단점을 말해주세요.</summary>
    <code>Schema</code> <code>Relation</code> <code>Scaling</code>

    SQL과 NoSQL은 크게 2가지 부분에서 차이점을 보입니다. 바로 Schema, Relation입니다. SQL의 테이블은 Schema, 즉 데이터의 구조가 정해져 있어 해당 구조를 따르는 데이터만을 저장할 수 있습니다. 반면 NoSQL의 콜렉션은 확정된 Schema가 존재하지 않아 어떤 구조의 데이터도 저장할수 있습니다. 다음으로 SQL은 테이블 간 관계를 맺을 수 있어 연관 데이터가 필요하면 조인을 통해 해당 데이터를 조회할 수 있습니다. 따라서 데이터가 테이블에 딱 한번만 저장된다는 특징이 있습니다. 반면 NoSQL은 연관된 데이터는 콜렉션에 모두 저장하기 때문에 콜렉션 간 데이터가 중복으로 저장된다는 특징이 있습니다.

    RDBMS의 테이블의 스키마를 변경하는 것은 어렵기 때문에 저장되는 데이터의 구조가 확정되었거나 변경될 가능성이 낮은 경우에 적합합니다. 또한 테이블 간 관계를 맺을 수 있어 데이터가 한 테이블에 오직 1번만 저장되어 변경이 쉬우므로 데이터에 대한 변경이 많이 발생하는 경우에도 RDBMS를 사용하는 것이 좋습니다.

    반대로 데이터의 구조를 파악하기 어렵거나 변경될 가능성이 높다면 RDBMS 보다는 NoSQL이 더 적합합니다. NoSQL은 하나의 콜렉션에 연관된 데이터를 모두 저장하고 있어 콜렉션 간 중복되는 데이터가 많습니다. 따라서 데이터 변경 연산이 여러 콜렉션에 대해 연쇄적으로 발생할 수 있습니다. 즉 데이터 변경 연산이 조회 연산 보다 무겁기 때문에 변경 연산은 적으면서 연관된 데이터에 대한 조회가 주로 발생하는 경우에도 NoSQL을 사용하는 것이 좋습니다.

    무엇보다 서버를 증설하여 처리량을 높이는 horizontal scaling은 NoSQL만 가능하기 때문에 대용량의 데이터를 처리하고 요청이 많이 발생하는 경우에는 RDBMS 보다는 NoSQL이 적합합니다.

    NoSQL은 어떤 구조의 데이터도 저장할 수 있어 데이터 구조에 대한 유연성이 있으며 연관된 데이터 조회 시에도 콜렉션들을 조인할 필요 없이 하나의 콜렉션에서 빠르게 조회할 수 있습니다. 또한 수평적 확장이 가능하기 때문에 처리량에 대한 한계 없이 대용량의 데이터를 처리할 수 있습니다.
    반면 데이터 구조가 확정되어 있지 않기 때문에 데이터 무결성이 깨질 수 있으며 콜렉션 간 중복되는 데이터가 많아 데이터 삽입/수정/삭제 시 여러 컬렉션이 영향을 받을 수 있습니다.

</details>

<details>
    <summary>정규화 과정에서 사용되는 함수 종속성이 무엇이며, 함수 종속성의 종류에 대해 설명해주세요</summary>
    <code>릴레이션 내 속성 간 연관성</code> <code>완전 함수 종속성</code> <code>부분 함수 종속성</code> <code>이행적 함수 종속성</code>

    함수 종속성은 특정 릴레이션 내에서 속성 간 연관 관계를 파악할 수 있도록 해주는 특성으로 이를 통해 관련 있는 속성들로만 릴레이션을 구성하여 정규화를 수행할 수 있습니다.
    릴레이션 내 특정 속성 집합 X에 대해 오직 하나의 속성 집합 Y가 대응된다면 X가 Y를 결정한다 또는 Y가 X에 종속된다 라고 표현할 수 있습니다. 함수 종속성의 종류에는 완전 함수 종속성, 부분 함수 종속성, 이행적 함수 종속성이 있는데, 먼저 완전 함수 종속성이란 속성 집합 Y가 X의 부분 속성에 대해 종속되지 않으면서 전체 속성 집합 X에만 종속되는 것을 의미합니다. 반면 부분 함수 종속성은 속성 집합 Y가 X의 부분 속성에도 종속되는 것을 말합니다. 마지막으로 X → Y 형태의 함수 종속성 관계가 존재할 때 Y → Z 함수 종속 관계도 존재한다면 Z가 Y를 통해 X에 이행적으로 종속된다고 표현할 수 있습니다.

</details>

<details>
    <summary>정규화는 무엇인지, 데이터베이스가 제1,2,3정규형에 속하기 위해 어떤 제약조건을 만족해야 하는지 간략히 설명해주세요.</summary>
    <code>함수적 종속성</code> <code>이상현상</code>

    먼저 정규화란 함수적 종속성을 바탕으로 연관된 속성들로만 릴레이션이 구성되도록 분해하여 이상 현상이 발생하지 않도록 릴레이션을 설계하는 것입니다.
    제1정규형에 속하기 위해서는 릴레이션의 모든 속성이 원자값으로 구성되어 있어야 합니다. 따라서 관계형 데이터베이스는 항상 제1정규형에 속합니다. 다음으로 제2정규형에 속하기 위해서는 기본키가 아닌 모든 속성이 기본키 속성에 완전 함수 종속되어야 합니다. 만약 기본키에 부분 함수 종속되는 속성이 있다면 릴레이션을 분해하여 해당 종속 관계를 제거해줍니다. 마지막으로 기본키가 아닌 속성이 기본키 속성에 이행적 함수 종속되지 않는다면 제3정규형에 속할 수 있습니다. 마찬가지로 이행적 함수 종속 관계가 존재한다면 종속 관계가 이행되지 않도록 릴레이션을 분해해줍니다.

</details>

<details>
    <summary>인덱스에 대해서 설명해주시고, 장단점에 대해 말해주세요.</summary>
    <code>대량의 데이터 검색</code> <code>검색 속도 향상</code> <code>추가적인 저장공간</code> <code>조회 fast, 삽입/삭제/수정 slow</code>

    인덱스란 추가적인 저장 공간에 미리 정렬된 정보를 저장함으로써 테이블 검색 속도를 향상시키기 위한 자료구조입니다. 만약 테이블에 1억개의 행이 존재하는 경우 해당 테이블에 대한 인덱스가 없는 조회 연산은 full table scan으로 매우 많은 시간을 걸릴 수 있습니다. 따라서 마치 책의 인덱스 처럼 자주 조회되는 컬럼을 기준으로 데이터의 위치를 별도의 공간에 저장함으로써 보다 빠르게 데이터를 조회할 수 있도록 해줍니다. 그러나 인덱스를 통해 조회 속도는 빨라질 수 있지만 잘못 사용할 경우 저장공간을 낭비할 수 있으며 또한 인덱스로 사용한 컬럼에 대한 삽입/수정/삭제 시에는 기존의 인덱스 구조를 모두 변경해야 하기 때문에 많은 시간이 소요될 수 있습니다.

</details>

<details>
    <summary>테이블의 어떤 컬럼을 인덱스로 사용하는 것이 효율적인지 이유와 함께 설명해주세요.</summary>
    <code>카디널리티↑</code> <code>변경↓</code> <code>where, group by, order by</code>

    전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표인 카디널리티가 높은 컬럼을 우선적으로 인덱싱해야 합니다. 만약 중복 수치가 높은 컬럼에 대해 인덱싱하는 경우 full table scan과 비슷한 성능을 낼 수 있습니다. 또한 인덱스로 사용한 컬럼에 대한 삽입/수정/삭제 연산 시 인덱스 구조 또한 변경해주어야 하므로 데이터가 변경될 가능성이 낮은 컬럼을 우선적으로 인덱싱해야 합니다. 마지막으로 인덱스는 where, group by, order by 절에서 사용될 수 있으므로 해당 절의 조건문에 자주 사용되는 컬럼을 우선적으로 인덱싱해야 합니다.

</details>

<details>
    <summary>참조 무결성 제약 조건에 대해 설명해주세요.</summary>
    <code>참조되는 테이블의 기본키</code> <code>참조하는 테이블의 외래키</code>
    
    참조하는 테이블의 외래키 값은 참조되는 테이블의 기본키 값만을 참조할 수 있다는 것을 의미합니다. 따라서 만약 참조되는 테이블의 기본키 속성값을 수정하거나 행을 삭제하는 경우 참조 무결성 제약 조건을 위반하지 않도록 DDL을 통해 별도의 설정이 가능합니다.

</details>

<details>
    <summary>이상현상이란 무엇인지, 어떤 종류가 있는지 말씀해주세요.</summary>
    <code>삽입 이상</code> <code>갱신 이상</code> <code>삭제 이상</code>

    이상현상은 잘못된 릴레이션의 설계로 인해 데이터 삽입/수정/삭제 시 발생하는 부작용입니다. 먼저 삽입 이상은 새로운 데이터 추가 시 불필요한 데이터도 함께 삽입해야 하는 문제를 의미하며, 갱신 이상은 중복되는 튜플 중 일부만 수정되어 데이터가 불일치하는 모순이 발생하는 것을, 삭제 이상은 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되어 데이터가 손실되는 것을 말합니다.

</details>
