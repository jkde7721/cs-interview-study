## 웹 면접 질문 리스트

<details>
    <summary>GET/POST 또는 POST/PUT 메소드의 차이점을 메소드 속성(안전, 멱등성, 캐시 가능)을 중심으로 설명해주세요.</summary>
    <br/><code>안전</code>, <code>멱등성</code>, <code>캐시 가능</code><br/><br/>
    
    GET은 주로 리소스 조회 시 사용하는 메소드로, 요청 시 메시지 바디로는 데이터를 전달할 수 없어 쿼리 파라미터나 경로 변수를 통해 서버에 데이터를 전달합니다.
    POST는 리소스를 생성하거나 변경하기 위해 데이터를 전달하는 경우 주로 사용되며 GET과 달리 메시지 바디를 통해 서버에 데이터를 전달할 수 있습니다.

    GET은 호출해도 리소스가 변경되지 않아 안전하고 동일한 요청을 여러번 보내도 한 번 보내는 것과 반환된 결과가 같아 멱등합니다. 또한 응답 결과를 클라이언트에 캐시해서 사용할 수 있습니다. 그러나 요청 데이터를 URL에 포함하여 전달하기 때문에 보안성이 낮아 비밀번호나 민감한 정보 전달 시에는 GET을 사용할 수 없습니다.
    반면 POST는 호출 시 리소스를 변경하여 안전하지 않으며 동일한 요청을 여러번 보내면 매번 새로운 리소스를 중복적으로 생성하므로 멱등하지 않습니다. 또한 응답 결과를 캐시하지 않습니다. GET과 달리 데이터를 메시지 바디에 포함하여 전달하기 때문에 보다 민감한 데이터를 서버에 전송할 수 있습니다.

    PUT 또한 주로 리소스를 생성하거나 변경하기 위해 서버에 데이터를 전달하는 경우 사용되며 POST와 달리 해당 리소스가 이미 존재한다면 새로운 리소스를 생성하지 않고 기존 리소스를 덮어쓰는 방식으로 동작합니다. 따라서 같은 요청을 여러번 보내도 매번 새로운 리소스를 생성하지 않고 기존 리소스를 덮어써 PUT은 POST와 달리 멱등합니다.

</details>

<details>
    <summary>동일 출처 정책이나 CORS에서의 출처란 무엇인지 말씀해주세요.</summary>
    <br/><code>Protocol</code>, <code>Host</code>, <code>Port</code><br/><br/>

    먼저 출처란 URL의 Protocol, Host, Port를 의미합니다. 동일한 출처는 이 3개의 값이 모두 같아야 합니다.
    동일 출처 정책은 다른 출처로부터 조회된 자원들에 대한 접근을 막아 다른 출처로부터의 공격을 예방합니다. 즉 이 정책에서는 동일한 출처로부터의 리소스에만 접근할 수 있습니다. 그러나 웹 서비스에서는 불가피하게 다른 출처의 리소스를 요청해야 하는 경우가 발생하는데 이때 다른 출처의 리소스에 대한 접근성을 높이기 위해 CORS 정책이 등장하게 되었습니다. 따라서 동일 출처 정책을 위반해도 CORS 정책을 따른다면 다른 출처의 리소스이더라도 접근이 허용됩니다.

</details>

<details>
    <summary>브라우저의 기본 동작 과정에 대해 말씀해주시고 CORS 작동 방식 3가지 시나리오 중 1가지에 대해 자세히 말씀해주세요.</summary> 
    <br/><code>클라이언트의 Origin 헤더</code>, <code>서버의 Access-Control-Allow-Origin 헤더</code>, <code>예비 요청(Preflight Request)</code>, <code>단순 요청(Simple Request)</code>, <code>인증된 요청(Credentialed Request)</code><br/><br/>

    브라우저는 먼저 요청 헤더 Origin에 자신의 출처를 담아 서버에 전달합니다. 이후 서버는 응답 헤더 Access-Control-Allow-Origin에 서버의 리소스 접근을 허용하는 출처 URL 값을 담아 클라이언트에 보내게 됩니다. 다시 클라이언트는 자신이 보낸 Origin 헤더 값과 응답으로 받은 Access-Control-Allow-Origin 헤더 값을 비교하여 값이 다른 경우에는 응답을 차단하여 CORS 에러가 발생하게 됩니다.

    CORS 작동 방식의 3가지 시나리오에는 예비 요청, 단순 요청, 인증된 요청이 있습니다. 먼저 예비 요청은 OPTIONS 메소드를 사용해 본 요청을 보내기 전 예비 요청을 보내봄으로써 CORS 정책을 위반하지 않는지 확인하는 것을 말합니다. 실제 요청을 보내기 전 매번 예비 요청을 보내 성능이나 비용적 측면에서 부정적인 영향이 있지만, 예비 요청을 브라우저에 캐싱하여 캐싱이 유효한 시간 동안은 예비 요청 없이 바로 본 요청을 전송함으로써 효율적인 통신이 가능합니다. (서버 응답의 Access-Control-Max-Age 헤더로 캐시 유효 시간 명시)

    단순 요청은 예비 요청을 생략하고 바로 서버에 본 요청을 보내면 서버가 이에 대한 응답으로 Access-Control-Allow-Origin 헤더를 보내주어 브라우저가 CORS 정책 위반 여부를 검사하는 방식을 말합니다. 심플한 방식인 만큼 특정 조건을 만족하는 경우에만 예비 요청을 생략할 수 있습니다.

    인증된 요청은 클라이언트에서 서버에게 자격 인증 정보를 실어 요청할 때 사용되는 방식으로, 기본적으로 브라우저의 요청 API는 별도의 옵션 없이 인증 관련 데이터를 함부로 요청 데이터에 담을 수 없기 때문에 인증된 요청을 하기 위해서는 클라이언트, 서버 단에서 별도의 설정이 필요합니다.

</details>

<details>
    <summary>웹소켓과 HTTP의 차이점은 무엇인가요?</summary>
    <br/><code>단방향/양방향</code>, <code>Stateless/Stateful</code><br/><br/>

    HTTP 프로토콜은 단방향 통신으로 클라이언트에서 서버로의 요청으로 생성된 연결에서 서버만이 클라이언트에게 데이터를 전송할 수 있습니다. 반면 WebSocket은 클라이언트-서버 간 연결 생성 후 서로에게 데이터를 전송하는 양방향 통신이 가능합니다. 또한 WebSocket은 HTTP와 달리 최초 접속 시에만 헤더 정보를 전달하여 네트워크 비용이 더 낮으며 stateful하여 HTTP 사용 시 계속해서 발생하는 TCP/IP 연결 트래픽을 줄일 수 있습니다.

    웹 소캣 연결은 먼저 HTTP 프로토콜로 시작하며 websocket opening handshake 과정을 통해 WebSocket 프로토콜로 변경되어 통신을 수행합니다.

</details>

<details>
    <summary>REST에서 URI가 무엇인지 설명해주세요.</summary>
    <br/><code>Uniform Resource Identifier</code>, <code>리소스 식별</code>, <code>리소스 위치</code><br/><br/>

    URI는 Uniform Resource Identifier의 약자로 인터넷 상의 리소스를 식별하기 위한 고유한 문자열을 의미합니다. URI의 하위 개념으로 인터넷 상에서 리소스의 위치를 나타내는 URL 이라는 개념이 있습니다. 즉 URL에 포함된 해당 리소스의 주소와 프로토콜 정보를 기반으로 리소스에 접근할 수 있습니다. 이때 이 주소 정보를 통해 리소스를 유일하게 식별할 수도 있으므로 URL은 URI라 할 수 있습니다.

    W3C가 URI와 URL을 교차하여 사용해도 된다는 URI 문서 발행 → URI를 URL, URN 등과 엄격하게 구분할 필요X
    *URI 문서: https://www.w3.org/TR/uri-clarification/

</details>

<details>
    <summary>REST의 설계 규칙에 대해 간단하게 말씀해주세요.</summary>
    <br/><code>서버-클라이언트</code>, <code>무상태</code>, <code>캐시 처리 가능</code>, <code>계층화</code>, <code>인터페이스 일관성</code>, <code>자체 표현</code><br/><br/>

    자원을 관리하는 서버와 자원을 요청하는 클라이어트로 분리하여 각각이 서로 독립적으로 동작할 수 있어야 합니다.

    클라이언트의 세션, 쿠키와 같은 컨텍스트를 서버에 저장하지 않아야 합니다. 이를 통해 서버는 각 요청들을 완전히 별개의 것으로 인식하여 단순 처리함으로써 서버의 부담을 줄일 수 있습니다.

    HTTP 프로토콜을 그대로 사용하여 캐시 처리가 가능해야 합니다. 이를 통해 요청에 대한 응답 시간과 서버에 대한 부하를 줄일 수 있습니다.

    서버가 보안, 로드밸런싱 등의 다중 계층으로 구성되더라도 클라이언트는 REST API 요청만으로 올바른 응답을 전달받을 수 있어야 합니다.

    URI로 지정한 자원을 통일되고 한정된 인터페이스를 통해 조작할 수 있어야 합니다.

    요청 메시지만 보고도 쉽게 이해할 수 있는 자체 표현 구조이어야 합니다.

</details>

<details>
    <summary>REST API와 RESTful API의 차이점과 궁극적으로 RESTful API의 목적이 무엇인지에 대해 말씀해주세요.</summary>

    REST의 6가지 설계 규칙을 따르는 API를 RESTful API라 지칭할 수 있습니다. RESTful API의 목적은 이해하기 쉽고 사용하기 쉬운 API를 만드는 것 즉 일관된 컨벤션을 통해 API의 이해도 및 호환성을 높이는 것입니다.

</details>

<hr/>

<details>
    <summary>JWT Process에서 Refresh Token의 역할과 JWT의 어떤 단점을 어떻게 보완하는 지에 대해 말씀해주세요.</summary>
    <br/><code>access token</code>, <code>refresh token</code><br/><br/>

    먼저 서버에서 클라이언트의 인가를 위해 주로 JWT를 사용하는데요. 이때 특정 권한이 필요한 API 요청 시에는 클라이언트가 access token을 헤더에 포함하여 서버에 요청을 보냅니다.
    그러나 JWT는 토큰 탈취 시 해당 토큰이 만료될 때까지 서버가 이에 대처할 수 있는 방안이 없습니다. 따라서 보통 access token의 만료 시간을 짧게 가져가는 편인데 이 경우 사용자는 해당 토큰이 만료될 때마다 매번 재로그인해야 하는 수고로움이 발생합니다.
    이러한 불편을 막기 위해 refresh token을 사용하는데요. 이 refresh token은 access token에 비해 만료 기간이 비교적 길어 access token이 만료되었을 때 클라이언트가 refresh token을 서버에게 보내 재로그인 없이 새로운 토큰을 발급받을 수 있습니다.

</details>

<details>
    <summary>JWT를 활용한 적이 있다면 활용했던 경험에 대해 말씀해주시고 없다면 어떤 경우에 사용하는 것이 좋은 지 말씀해주세요.</summary>

    스프링 프레임워크에서 소셜 로그인으로 인증된 사용자에게 JWT를 발급하여 클라이언트가 API 요청 시 해당 access token을 헤더에 포함하도록 구현하였습니다. 그 당시 refresh token은 RDB에 저장하여 만료된 refresh token이더라도 DB에 남아있을 수 밖에 없었는데 Redis 같은 인메모리 DB는 일정 시간 이후 DB에서 자동으로 해당 데이터가 삭제되는 것이 가능하다고 하여 추후에 Redis를 이용해 인가 로직을 구현해볼 생각입니다.

</details>

<details>
    <summary>CSR이 무엇인지 그리고 장단점에 대해 말씀해주세요.</summary>
    <br/><code>클라이언트 측에서 렌더링</code>, <code>동적 렌더링</code><br/><br/>

    CSR은 서버에서 보내준 미완성된 HTML 파일에 링크된 각종 리소스들을 서버에 재요청하여 클라이언트 측에서 동적으로 웹페이지를 만드는 방식으로 하나의 페이지로만 어플리케이션이 구성된 SPA에 적합합니다.
    모든 리소스들을 받아와 렌더링해야 하기 때문에 최초 로딩은 오래 걸리지만 이후에는 원하는 내용만 업데이트할 수 있어 빠른 페이지 전환이 가능합니다. 또한 페이지 이동마다 서버에게 완성된 HTML을 요청하는 것이 아닌 필요한 데이터만 요청하기 때문에 서버의 부담이 적어집니다. 그러나 초기에 받아온 HTML에는 데이터가 포함되어 있지 않아 검색엔진이 해당 웹 페이지를 분석하기 어려워 SEO에 취약하다는 큰 단점이 있습니다.

</details>

<details>
    <summary>CSR과 SSR에 대해 서버 자원 사용과 SEO 관점에서 말씀해주세요.</summary>
    <br/><code>Search Engine Optimization</code><br/><br/>

    SSR은 서버에서 렌더링을 마친 완전한 HTML 파일을 클라이언트에게 보내주는 방식으로, 페이지 이동 시마다 서버에서 완전한 HTML을 만들어 응답하기 때문에 서버 부하가 많습니다.
    반면 CSR은 서버에서 비어있는 HTML 파일을 보내주면 클라이언트에서 해당 HTML에 포함된 각종 리소스들을 재요청하여 동적으로 렌더링하는 방식으로, 페이지 이동 시 업데이트가 필요한 부분만 서버에 요청하여 화면 전체를 다시 만들어야 하는 SSR에 비해 서버 부하가 적습니다.
    그러나 CSR의 초기 화면에는 데이터가 포함되어 있지 않아 검색엔진이 분석하기 어려워 웹 사이트가 빠르게 검색되도록 도와주는 검색 엔진 최적화 즉 SEO에 취약합니다. 반면 SSR은 초기 화면에도 데이터가 모두 포함되어 있어 CSR에 비해 SEO를 향상시킬 수 있습니다.

    *SEO: 각종 검색엔진에서 검색했을 때 검색결과 상위에 나타나도록 관리하여 잘 검색되게 만드는 법

</details>

<details>
    <summary>Cookie와 Session이 각각 무엇인지와 둘의 차이점에 대해 말씀해주세요.</summary>
    <br/><code>정보 저장 위치</code>, <code>저장 용량 제한</code>, <code>보안</code>, <code>처리 속도</code>, <code>라이프 사이클</code><br/><br/>

    쿠키는 사용자가 방문한 웹 사이트의 서버에서 브라우저(로컬 저장소)에 저장한 작은 정보 파일로 조작되거나 탈취돼도 문제 없는 정보들만을 저장합니다.
    세션은 일정 기간 동안 같은 사용자(클라이언트)로부터 들어오는 일련의 요청을 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술로 쿠키를 기반으로 하지만 쿠키와 달리 서버 측에서 저장하고 관리합니다.

    쿠키는 클라이언트의 로컬 저장소에 저장되어 저장 용량에 제한이 있고 서버의 자원을 전혀 사용하지 않는 반면 세션은 서버에 저장되어 저장 용량에 제한이 없습니다.
    쿠키는 클라이언트의 로컬에 저장되기 떄문에 변질되거나 요청 시 스니핑 당할 우려가 있어 보안에 취약한 반면 세션은 세션 ID 탈취가 의심된다면 서버에 저장된 해당 세션을 삭제하는 식으로 처리가 가능하여 비교적 보안성이 높습니다.
    또한 쿠키는 쿠키에 이미 정보가 포함되어 있기 때문에 서버 요청 시 처리 속도가 빠른 반면 세션은 정보가 서버에 있기 때문에 DB 조회 등 추가적인 처리가 요구되어 비교적 속도가 느립니다.
    쿠키는 파일로 저장되기 때문에 브라우저를 종료해도 유지되며 지정한 만료 기간 동안은 유효합니다. 세션도 만료 기간을 정할 수 있지만 브라우저가 종료되면 만료 기간에 상관없이 삭제됩니다.

</details>

<details>
    <summary>Cookie의 동작 순서에 대해 말씀해주세요.</summary>

    클라이언트가 요청을 보내면 서버는 해당 요청에 대한 적절한 쿠키를 생성하고 이를 HTTP 헤더에 포함시켜 응답합니다. 응답을 받은 클라이언트는 해당 쿠키를 브라우저에 저장하고 이후 동일한 도메인으로 재요청 시 HTTP 헤더에 해당 쿠키가 자동으로 포함되어 서버에 전달됩니다.

</details>

<details>
    <summary>Web Server와 WAS의 차이점에 대해 간략히 설명해주세요.</summary>
    <br/><code>정적 리소스</code>, <code>어플리케이션 로직</code><br/><br/>

    실제 둘의 용어도, 경계도 모호하지만 웹 서버는 주로 정적 리소스를 제공하는 반면 WAS는 프로그램 코드를 실행해 어플리케이션 로직과 같은 동적인 요청을 처리합니다.

</details>

<details>
    <summary>WAS가 Web Server의 역할을 할 수 있음에도 불구하고 Web Server와 WAS를 조합하여 시스템을 구축하는 이유와 이러한 시스템의 장점에 대해 설명해주세요.</summary>
    <br/><code>서버 과부하</code>, <code>장애 대응</code><br/><br/>

    WAS만으로 시스템을 구축하면 WAS가 너무 많은 역할을 담당하여 서버 과부하가 발생할 수 있습니다. 특히 정적 리소스 처리로 인해 WAS의 주요 역할인 어플리케이션 로직 수행이 어려워질 수 있으며 WAS 장애 시 서버가 아예 죽어버려 사용자에게 오류 화면을 보여주는 것 또한 불가능해집니다.

    반면 웹 서버와 WAS를 조합하여 시스템을 구축했을 때 웹 서버는 정적 리소스를 제공하고 애플리케이션 로직 같은 동적인 처리가 필요하면 웹 서버가 WAS에 요청을 위임하는 식으로 동작합니다. 이 경우 웹 서버와 WAS를 기능적으로 분리하여 서버의 부하를 방지할 수 있습니다. 또한 정적 리소스 요청이 많은 경우엔 웹 서버를, 어플리케이션 로직 요청이 많은 경우엔 WAS를 증설하는 등 효율적인 리소스 관리가 가능해집니다. 또한 두 서버를 물리적으로 분리하였기 때문에 웹 서버가 방화벽의 역할을 할 수 있어 보안이 강화됩니다. 마지막으로 WAS에 오류가 발생해도 웹 서버를 통해 클라이언트에게 오류 화면 제공이 가능하며 정상적으로 동작하는 WAS에만 웹 서버가 요청을 위임하도록 하여 장애 대응에 유리해집니다.

</details>
