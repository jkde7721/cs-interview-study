## 이상현상(Anomaly)
정규화되어있지 않은 테이블 설계로 인해(잘못된 DB 설계) 발생하는 부작용 

아래와 같은 잘못 설계된 테이블이 있다고 가정하자 
| <U>STUDENT ID</U> | STUDENT_NAME | DEPARTMENT | <U>COURSE_ID</U> | GRADE |
|:--:|:--:|:--:|:--:|:--:|
| 1 | A | a | 100 | A+ |
| 1 | A | a | 200 | B+ |
| 1 | A | a | 300 | B0 |
| 2 | B | b | 100 | A- |

<br>

1. **삽입이상(Insertion Anomaly)**
	현재, 학번과 과목코드가 NOT_NULL 컬럼으로 지정된 상태. 
	이 때, 미수강한 학생은 과목코드에 아무것도 적을 수 없기 때문에, 해당 테이블에 추가되지 못한다. 
=> **새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제**
	
2. **갱신이상(Update Anomaly)**
	A라는 학생이 b로 전공을 변경하기로 한 경우, A 학생이 속한 행을 모두 변경해주어야 함. 
	2개만 변경한 경우 A라는 학생의 전공은 더 이상 a, b중 어느 것인지 알 수 없게 됨. 
=> **중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제**
	
3. **삭제이상(Delete Anomaly)**
    B라는 학생의 경우, 현재 하나의 과목만 수강하고 있는 상태.
	이 때, 수강취소를 하는 경우, 해당 행이 모두 삭제되기 때문에 더 이상 B라는 학생에 대한 정보는 테이블에 남아있지 않게 됨.
=> **튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제**

<br>

정규화된 테이블을 설계하기 위해서는 속성들간의 관련성을 파악해야 함. 이것을 `함수적 종속성(Functional Dependency)`라 부름. 
하나의 릴레이션에는 하나의 함수적 종속성만이 존재하도록 정규화함. 

<br>

## 함수적 종속성 (Functional Dependency)

> X -> Y
- **X : 결정자** / **Y : 종속자** 
- X가 Y를 함수적으로 결정
- Y가 X에 함수적으로 종속 

<br>

| <U>STUDNET_ID</U> | <U>COURSE_ID</U> | GRADE | STUDENT_NAME |
|:--:|:--:|:--:|:--:|
| 1 | 100 | A+ | A |
| 1 | 200 | B+ | A |
| 2 | 100 | B- | B |
| 3 | 300 | A0 | C |

<br>

> *STUDENT_ID* -> *STUDENT_NAME*
> *{STUDENT_ID, COURSE_ID}* -> *GRADE*
> *{STUDENT_ID, COURSE_ID}* -> *STUDENT_NAME*

 - `학번`은 `이름`을 결정지음
 - `{학번, 과목코드}`는 `성적`을 결정지음
 - `{학번, 과목코드}`는 `이름`을 결정지음 

<br>

이 때, `이름` -> 함수적 종속성이 2개 

### 1. 부분 함수적 종속 (Partial Functional Dependency)

> *속성집합 Y 가 속성집합 X 의 전체가 아닌 일부분에도 함수적으로 종속됨*


**이름**
 => {학번, 과목코드} 에 함수적으로 종속
 => {학번, 과목코드} 의 일부인 학번에도 함수적으로 종속

<br>
 
### 2. 완전 함수적 종속 (Full Functional Dependency)
> *속성집합 Y 가 속성집합 X 전체에 대해서만 함수적으로 종속*

**성적**
=> {학번, 과목코드} 에 함수적으로 종속
=> {학번, 과목코드} 의 <U>어떤 부분집합에도</U> 함수적으로 종속되어있지 않음
학번만으로 성적을 결정지을 수 없고, 과목코드만으로도 성적을 결정지을 수 없음. 

<br>

## 정규화(Normalization)

관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스
-> 이상현상 발생하지 않도록 

<br>

### 정규형(Normal Form)이란? 
정규화 된 정도로 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF 존재
비공식적 표현으로는 3NF 가 되었으면 정규화 되었다고 말할 수 있음. 

3NF 테이블의 대부분이 삽입, 변경, 삭제 이상이 없으며, 3NF 테이블의 대부분이 BCNF, 4NF, 5NF이다.

<br>

### 제 1 정규형 (1NF)
릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성

**<예시1>**
| <U>STUDNET_ID</U> | <U>COURSE_ID</U> | GRADE | STUDENT_NAME |
|:--:|:--:|:--:|:--:|
|  1 | 100, 200, 300 | A+, A-, B- | a |
1NF를 만족하지 않음.

**<예시2>**
| <U>STUDNET_ID</U> | <U>COURSE_ID</U> | GRADE | STUDENT_NAME |
|:--:|:--:|:--:|:--:|
|  1 | 100 | A+ | a |
|  1 | 200 | A- | a |
|  1 | 300 | B- | a |

모든 속성이 원자값을 갖으므로 1NF 만족 

<br>

### 제 2 정규형 (2NF) 
제1정규형에 속하면서,  
기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 **제2정규형**이다.

하지만, 이행적 함수 종속이 존재하기 때문에, 아직 이상현상이 발생함. 

**이행적 함수 종속**이란?
X->Y 이고 Y->Z 이면 X->Z 가 성립한다. 이를 Z 가 X 에 이행적으로 함수 종속되었다 함. 


> 학번 -> 학부  
학부 -> 등록금  
학번 -> 등록금

학부에 따라 등록금이 결정되는 것이지 학번에 따라 결정되는 것은 아님

<br>

### 제 3 정규형 (3NF)
제 2 정규형에 속하면서,  
기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 **제 3 정규형**



X->Y, Y->Z 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 [X, Y], [Y, Z] 두 릴레이션으로 분해

하지만 후보키를 여러개 가지고 있는 릴레이션에서는 제3정규형을 만족하더라도 이상현상이 생길 수 있다.
이를 해결한 것이 BCNF 

<br>

### BCNF (Boyce-Codd Normal Form)
릴레이션 R에서 함수 종속성 X→Y가 성립할 때 모든 결정자 X가 후보키인 정규형

<br>

> ### 정규형의 장단점

-   장점
    -   이상현상들이 발생하는 문제점을 해결할 수 있다.
    -   정규화된 테이블들과 테이블들 간의 관계들을 사용자에게 제공할 수 있다.
-   단점
    -   릴레이션 간의 연산(JOIN)이 많아진다.
    -   이로 인해, 질의에 대한 응답시간이 느려질 수 있는 경우가 발생할 수도 있다.


> ### 반정규화(De-normalization, 비정규화)

-   정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 디스크 I/O량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 컬럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행한다. 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.
-   반정규화의 대상
    -   자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
    -   테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우,  **성능 상 이슈가 있을 경우**
    -   테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우
-   반정규화를 과도하게 적용하면 데이터의 무결성이 깨질 수 있고, 입력/수정/삭제의 질의문에 대한 응답시간이 늦어질 수 있다


<br>

[레퍼런스1](https://yaboong.github.io/database/2018/03/09/database-anomaly-and-functional-dependency/)
[레퍼런스2](https://yaboong.github.io/database/2018/03/10/database-normalization-2/)