## 데이터베이스 용어 정리

> 관계 데이터 모델에서는 한 개체(엔티티)에 대한 데이터를 하나의 릴레이션, 즉 테이블에 담아 데이터베이스에 저장

<br/>

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/bd0823a8-8a72-450a-9f0f-b1b8dc960b9f" width="60%"/>

<br/>

### Person 테이블

| id        | name    | age | birthday   |
| --------- | ------- | --- | ---------- |
| 1         | David   | 15  | 1999-12-20 |
| 2         | Amy     | 20  | 1994-11-07 |
| ...       | ...     | ... | ...        |
| 99999999  | Michael | 23  | 1991-05-21 |
| 100000000 | Alice   | 30  | 1984-02-11 |

<br/>

### 속성(Attribute)

- 저장하고자 하는 개체의 항목으로 `Person` 테이블 내 (`id`, `name`, `age`, `birthday`)
- 즉 테이블의 열(Column)로 각 속성의 이름은 고유
- 속성 값으로 더는 분해할 수 없는 원자 값만 지정 가능
- 속성 값을 모르거나, 적합한 값이 없는 경우 널(`NULL`)이라는 특별한 값 지정 가능

<br/>

### 튜플(Tuple)

- 릴레이션의 행, 즉 테이블의 레코드(Record)로 개체 인스턴스

<br/>

### 도메인(Domain)

- 속성 하나가 가질 수 있는 모든 값의 집합
- 특정 속성이 가질 수 있는 모든 원자 값의 모임
- 데이터 타입으로도 정의

<br/>

### 차수(Degree)

- 릴레이션의 속성 전체 개수로 `Person` 테이블의 차수는 4
- 모든 릴레이션은 최소 1 이상의 차수 유지
- 일반적으로 자주 변하지 않는 정적인 특징

<br/>

### 카디널리티(Cardinarity)

- 릴레이션의 튜플 전체 개수로 `Person` 테이블의 카디널리티는 1억
- 릴레이션의 카디널리티는 0일 수 있음
- 일반적으로 자주 변하는 동적인 특징
- '카디널리티는 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표'라는 정의도 존재

<br/>

> 릴레이션 = 릴레이션 스키마 + 릴레이션 인스턴스

### 릴레이션 스키마(Relation Schema)

- **릴레이션의 이름**과 릴레이션에 포홤된 **모든 속성의 이름**으로 정의된 릴레이션의 논리적 구조
- DBMS가 내부적으로 데이터 정의어(DDL)를 이용해 정의
- 자주 변하지 않는 정적인 특징

```
릴레이션 이름(PK 속성 이름, 속성 이름2, ... , 속성 이름n)
Person(id, name, age, birthday)
```

<br/>

### 릴레이션 인스턴스(Reltation Instance)

- 어느 한 시점에 릴레이션에 존재하는 튜플들의 집합
- 릴레이션 스키마에서 정의한 각 속성에 대응되는 실제 값으로 구성
- DBMS가 내부적으로 데이터 조작어(DML)를 이용해 튜플에 대한 조회/삽입/수정/삭제 연산 수행
- 튜플에 대한 삽입/수정/삭제가 자주 발생하는 등 동적인 특징

<br/>

### 데이터베이스 스키마

- 데이터베이스의 전체 구조
- 데이터베이스를 구성하는 모든 릴레이션들의 스키마 집합

<br/>

### 데이터베이스 인스턴스

- 어느 한 시점에 데이터베이스에 저장된 데이터들의 전체 집합
- 데이터베이스를 구성하는 모든 릴레이션들의 인스턴스 집합

<br/>

### 릴레이션의 특성

- **튜플의 유일성**: 하나의 릴레이션에는 동일한 튜플이 존재할 수 없음
  - 한 릴레이션 내에 똑같은 튜플 있으면 X
  - 한 개 또는 여러 개의 속성을 미리 선정해 이 속성 값을 튜플마다 다르게 지정하여 튜플의 유일성 판단
- **튜플의 무순서**: 하나의 릴레이션에서 튜플 사이의 순서는 무의미
  - 튜플 순서가 바뀌어도 다른 릴레이션이 될 수 없고, 순서와 상관없이 튜플 내용이 같으면 동일한 릴레이션
  - 데이터베이스는 위치가 아닌 내용으로 검색되므로 튜플 순서는 중요치 않음
- **속성의 무순서**: 하나의 릴레이션에서 속성 사이의 순서는 무의미
  - 속성의 순서가 바뀌어도 다른 릴레이션이 될 수 없고, 순서와 상관없이 속성 내용이 같으면 동일한 릴레이션
- **속성의 원자성**: 속성 값으로 원자 값만 사용 가능
  - 모든 속성 값은 더는 분해할 수 없는 하나의 값, 즉 원자 값만 가능
  - 하나의 속성은 여러 개의 값, 즉 다중 값을 가질 수 없음

<br/>
<hr/>

## 키(Key)

> 릴레이션 내 튜플들을 유일하게 구별해주는 역할을 하는 속성 또는 속성들의 집합

<br/>

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/0ca02f0c-2308-4f74-987c-5c7d6a7809f9" width="35%"/>

<br/>

### 슈퍼키(Super Key)

- **유일성**을 만족하는 속성 또는 속성들의 집합

  _유일성(uniqueness): 모든 키의 기본 특성, 한 릴레이션에서 키로 지정된 속성 값은 각 튜플마다 달라야 함_

- 튜플들을 유일하게 구별하기 위해 불필요한 속성까지 포함
  - `Person` 테이블 내 `id` 속성으로 모든 튜플 유일하게 구별 가능 → `id` 속성 슈퍼키로 사용 가능
  - `name` 속성으로는 모든 튜플 유일하게 구별 불가능 → `name` 속성 슈퍼키로 사용 불가능
  - (`id`, `name`) 속성 조합으로 모든 튜플 유일하게 구별 가능 → (`id`, `name`) 속성 슈퍼키로 사용 가능 (but 불필요한 `name` 속성 포함)

<br/>

### 후보키(Candidate Key)

- **유일성**과 **최소성**을 만족하는 속성 또는 속성들의 집합

  _최소성(Minimality): 꼭 필요한 최소한의 속성들로만 키를 구성하는 특성_

- 튜플들을 유일하게 구별하기 위해 꼭 필요한 최소한의 속성들로만 이루어지므로 슈퍼키 중 최소성을 만족하는 것이 후보키
  - `Person` 테이블 내 (`id`, `name`) 속성 조합에서 `id` 속성만으로도 모든 튜플 유일하게 구별 가능하므로 (`id`, `name`) 속성 조합은 후보키로 사용 불가능
- 튜플 삽입/수정 연산 시에도 후보키의 유일성과 최소성은 유지 → 속성의 본래 의미를 정확히 이해한 후 키 지정 필요
  - 현재 `Person` 테이블 내 `name` 속성 값이 모두 다르다고 `name`을 키로 사용할 수 없음

<br/>

### 기본키(Primary Key)

- 여러 개의 후보키 중 각 튜플을 구별하기 위해 기본적으로 사용하는 키
- 만약 `Person` 테이블에 `address` 속성이 추가된다면, (`id`) 뿐만 아니라 (`name`, `address`) 속성 조합도 후보키로 사용 가능 → 어떤 후보키를 기본키로 사용?
- 기본키 선택 기준
  - 널 값을 가질 수 있는 속성이 포함된 후보키는 부적합
  - 값이 자주 변경될 수 있는 속성이 포함된 후보키는 부적합: 기본키는 다른 튜플과 구별되는 값을 가지고 널 값을 허용하지 않으므로 이를 확인하는 추가 작업 필요 → 속성 값이 바뀔 때마다 기본키 값으로 적합한지 매번 확인이 필요
  - 단순한 후보키를 선택: 구성하는 속성의 개수가 적거나 값이 단순한 후보키

<br/>

### 대체키(Alternate Key)

- 기본키로 선택되지 못한 후보키들
- 기본키를 대신할 순 있지만 완전한 기본키로서 기능X

<br/>

### 외래키(Foreign Key)

- 테이블 간 관계를 표현하기 위해 다른 테이블의 기본키를 그대로 참조하는 속성 또는 속성들의 집합
  - 외래키를 통해 고객 릴레이션과 주문 릴레이션이 관계를 맺어 주문 릴레이션의 특정 튜플과 연관 있는 고객 릴레이션의 특정 튜플 연결 가능
- 외래키를 가진 릴레이션을 **참조하는 릴레이션** / 기본키를 가진 릴레이션을 **참조되는 릴레이션**
- `외래키 속성의 이름 ≠ 참조되는 기본키 속성의 이름` 가능
- `외래키 속성의 도메인 ≠ 참조되는 기본키 속성의 도메인` 불가능
- 한 릴레이션에 외래키 여러 개 존재 가능
- 외래키를 포함하여 기본키를 구성하거나 외래키 자체를 기본키로 사용 가능
- 외래키가 기본키로 사용되지 않는다면 널 값을 가질 수 있으며 다른 튜플과 중복되는 값도 가질 수 있음

<br/>

## 무결성 제약조건(Integrity Constraint)

> 무결성: 데이터에 결함이 없는 상태, 즉 데이터가 정확하고 유효하게 유지된 상태

- 데이터베이스에 저장된 데이터의 무결성을 보장 + 데이터베이스의 상태를 일관되게 유지하기 위해
- 데이터베이스가 삽입/삭제/수정 연산으로 상태가 변하더라도 무결성 제약조건은 항상 지켜져야 함

<br/>

### 개체 무결성 제약조건(Entity Integrity Constraint)

> 기본키를 구성하는 모든 속성은 널 값을 가지면 안된다.

- 기본키를 구성하는 속성 전체나 일부가 널 값이 되면 튜플의 유일성을 판단할 수 없어 기본키의 본래 목적을 상실
- 새로운 레코드가 삽입되는 연산이나 기존 레코드의 기본키 속성 값이 변경되는 연산 발생 시 기본키에 널 값이 포함되면 연산 수행 불가 (by. DBMS)

<br/>

### 참조 무결성 제약조건(Referential Integrity Constraint)

> 외래키는 참조할 수 없는 값을 가질 수 없다.

- 외래키에 대한 규칙으로 연관된 릴레이션들에만 적용
- 외래키가 자신이 참조하는 릴레이션의 기본키와 상관없는 값을 가지게 되면 두 릴레이션을 연관시킬 수 없어 외래키 본래 의미 퇴색 → 자신이 참조하는 릴레이션에 기본키 값으로 존재하는 값, 즉 참조 가능한 값만 가능

|                   | 삽입                                                                                          | 수정                                                                                                                                                                                               | 삭제                                                                                                                                                                                          |
| ----------------- | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 참조되는 릴레이션 | 참조 무결성 제약조건 위반X                                                                    | 기본키가 아닌 속성 값을 변경하는 연산은 어떠한 제약조건도 위반X<br/><br/>기본키 속성 값 변경 시 참조하는 릴레이션에 연관된 튜플이 남아있으면<br/>1. 수정 연산 수행X<br/>2. 새로운 값으로 함께 수정 | 참조하는 릴레이션에 연관된 튜플이 남아있으면<br/>1. 삭제 연산 수행X<br/>2. 참조하는 릴레이션의 연관 튜플 함께 삭제<br/>3. 참조하는 릴레이션의 연관 튜플의 외래키 값을 널이나 기본 값으로 변경 |
| 참조하는 릴레이션 | 참조되는 릴레이션에 존재하지 않는 기본키 값을 외래키 값으로 지정 시 참조 무결성 제약조건 위반 | 외래키가 아닌 속성 값을 변경하는 연산은 어떠한 제약조건도 위반X <br/><br/>외래키 값을 참조되는 릴레이션에 존재하지 않는 기본키 값으로 변경하면 참조 무결성 제약조건 위반                           | 어떠한 제약조건도 위반X                                                                                                                                                                       |

<br/>

## 키 & 제약조건 관련 SQL

### 키 지정 SQL

- `CREATE TABLE` 문에서 테이블 정의 시 기본키, 대체키, 외래키 지정 가능
- `PRIMARY KEY`: 기본키로 지정

  한 테이블에서 기본키는 반드시 하나만 지정 가능, 여러 개의 속성으로 구성 가능

  ```sql
  CREATE TABLE Person (
    id int auto_increment,
    name varchar(50) not null,
    age int not null,
    birthday date not null,
    PRIMARY KEY(id)
  );
  ```

- `UNIQUE`: 대체키로 지정

  각 튜플을 유일하게 식별하는 특성, 기본키와 달리 널 값 가능, 한 테이블에서 여러 개 지정 가능

  ```sql
  CREATE TABLE Person (
    id int auto_increment,
    name varchar(50) not null,
    age int not null,
    birthday date not null,
    address varchar(100),
    PRIMARY KEY(id),
    UNIQUE(name, address)
  );
  ```

- `FOREIGN KEY`, `REFERENCES`: 외래키로 지정
  어떤 테이블의 어떤 속성을 참조하는지 `REFERENCES` 키워드 다음에 작성

  ```sql
  CREATE TABLE Job (
    id int auto_increment,
    name varchar(100) not null,
    PRIMARY KEY(id)
  );

  CREATE TABLE Person (
    id int auto_increment,
    job_id int,
    name varchar(50) not null,
    age int not null,
    birthday date not null,
    PRIMARY KEY(id),
    FOREIGN KEY(job_id) REFERENCES Job(id)
  );
  ```

<br/>

### 참조 무결성 제약조건 위반 시 처리 방법 지정 SQL

- 참조되는 테이블에서 연관된 튜플을 삭제하거나 변경 시 처리 방법 지정
- 참조하는 테이블 정의 시 `CREATE TABLE` 문 끝에 추가

```sql
ON DELETE NO ACTION --튜플을 삭제 불가 (기본 설정)
ON DELETE CASCADE --관련 튜플을 함께 삭제
ON DELETE SET NULL --관련 튜플의 외래키 값을 NULL로 변경
ON DELETE SET DEFAULT --관련 튜플의 외래키 값을 미리 지정한 기본 값으로 변경
```

```sql
ON UPDATE NO ACTION --튜플을 변경 불가 (기본 설정)
ON UPDATE CASCADE --관련 튜플에서 외래키 값을 함께 변경
ON UPDATE SET NULL --관련 튜플에서 외래키 값을 NULL로 변경
ON UPDATE SET DEFAULT --관련 튜플에서 외래키 값을 미리 지정한 기본 값으로 변경
```

<br/>

### 데이터 무결성 제약조건 정의 SQL

- `CHECK`: 테이블 정의 시 특정 속성에 대한 제약조건 지정

  테이블에 새로운 튜플 삽입 또는 기존 튜플 수정 시 항상 제약조건 검사

  ```sql
  CHECK(age >= 0 AND age <= 200)
  ```

- `CONSTRAINT`: `CHECK` 키워드로 지정한 제약조건에 고유 이름 부여

  제약조건 이름은 해당 데이터베이스 내에서 유일

  ```sql
  CONSTRAINT CHK_AGE CHECK(age >= 0 AND age <= 200)
  ```

<br/>

### 참고

[데이터베이스 용어](https://hoyeonkim795.github.io/posts/db-%EC%9A%A9%EC%96%B4/)

[책 데이터베이스 개론 2판](https://www.hanbit.co.kr/store/books/look.php?p_code=B8582604063)
