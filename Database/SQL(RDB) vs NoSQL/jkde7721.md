## SQL vs NoSQL

### SQL Database 특징 2가지

1. **Strict Schemas**

- 데이터는 데이터베이스 테이블에 레코드 형태로 저장
- 각 테이블은 확정된 스키마(구조)가 정의되어 있어 이를 따르는 데이터만을 저장
- 테이블의 스키마를 바꾸지 않는 이상 다른 구조의 데이터 저장 불가

2. **Relations**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/d1fec125-27a6-4e78-baa6-2d5349727c43" width="70%"/>

- 데이터는 관계에 의해 연결되는 다수의 테이블에 분산되어 저장
- 데이터가 각 테이블에 한 번만 저장되어 중복되지 않음
- 즉 주문 관련된 데이터를 `Orders` 테이블에 모두 다 저장하는 것이 아닌 `Users`, `Products`, `Orders` 각 테이블에 분리하여 저장
- 주문 관련 모든 데이터를 조회하는 경우 관계 있는 `Users`, `Products`, `Orders` 테이블을 연결하여(조인하여) 조회

<br/>

### NoSQL Database 특징 2가지

1. **No Schemas**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/ac845f9a-bd62-49b9-a731-d364f6b84cf4" width="70%"/>

- SQL의 tables → NoSQL의 collections / SQL의 records → NoSQL의 documents
- 한 컬렉션에 다른 구조를 가진 데이터 저장 가능 (JSON 형식으로 저장)

2. **No Relations**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/b2d47c2b-a98b-4005-a3a1-9dc451dc062c" width="70%"/>

- 관련된 데이터는 한 컬렉션에 모두 저장
- SQL에서는 `Users`, `Products`, `Orders` 테이블에 나누어 저장했던 것을, NoSQL에서는 `Orders` 컬렉션에 모두 저장
- 이미 `Orders` 컬렉션에 모든 데이터가 저장되어 있기 때문에, 주문 관련 모든 데이터를 조회하기 위해 관련 있는 `Users`, `Products` 컬렉션을 연결할 필요 없음 → 조인할 필요가 없어 빠른 데이터 조회 가능
- 관련된 모든 데이터를 한 컬렉션에 저장하기 때문에 컬렉션 간 데이터 중복 발생 → 한 컬렉션의 데이터 업데이트 시 해당 데이터를 중복으로 저장하고 있는 다른 컬렉션도 업데이트 해줘야 함 → 데이터 변경 작업 속도가 느려짐

<br/>

## 어떤 데이터베이스를 언제 선택?

> 정답은 없음, 처리하는 데이터와 개발하는 어플리케이션의 특성에 따라 적절한 데이터베이스 선택

<details>
    <summary>Vertical Scaling(수직적 확장) vs Horizontal Scaling(수평적 확장)</summary>
    <li>Scaling을 통해 데이터베이스의 처리 가능한 요청량, 데이터의 양을 업그레이드</li>
    <li><b>Vertical Scaling</b>: 서버 자체의 스펙(CPU, RAM 등)을 업그레이드하는 것</li>
    <li><b>Horizontal Scaling</b>: 서버의 수를 늘리고 하나의 큰 데이터베이스를 여러 개의 작은 단위(shard)로 분산하여 관리(sharding) → 각 서버의 데이터 조회 결과를 병합하는 과정이 필요</li>
    <blockquote>데이터가 저장되는 방식으로 인해 보통 horizontal scaling은 NoSQL 데이터베이스만 가능 (ex. 하나의 컬렉션을 여러 서버에 나누어 저장하는 것 가능)</blockquote>
</details>

<br/>

### SQL 장점 & 단점

**장점**

- 명확한 스키마가 정의되어 있어 데이터 무결성이 보장 (해당 스키마를 따르는 데이터만을 저장하므로)
- 데이터를 한 번만 저장하여 데이터 중복을 피함 (관계있는 테이블을 연결하여 데이터를 조회할 수 있으므로)

**단점**

- 데이터 구조에 대한 유연성 결여 (스키마 변경이 어렵기 때문에 스키마가 미리 확정되어야 함)
- 테이블 간 정의된 관계(Relations)로 많은 `JOIN` 절이 포함된 복잡한 쿼리가 수행될 수 있음
- 수직적 확장은 가능하지만 수평적 확장이 어려움(불가) → 성능 향상에 대한 한계O

**언제 사용?**

- 명확한 스키마가 중요하거나, 스키마가 확정되어 변경될 가능성이 적은 경우
- 데이터에 대한 변경이 자주 발생하는 경우

<br/>

### NoSQL 장점 & 단점

**장점**

- 데이터 구조에 대한 유연성 (저장된 데이터 구조를 언제든지 변경 가능)
- 데이터가 조회하고자 하는 형태로 저장되기 때문에 데이터 조회 속도가 빠름
- 수직적 & 수평적 확장 모두 가능 → 성능 향상 언제든지 가능

**단점**

- 데이터 구조에 대한 유연성으로 데이터 구조를 결정하는 것을 미룰 수 있음
- 중복 저장된 데이터로 데이터 변경 시 여러 컬렉션을 업데이트 해줘야 함

**언제 사용?**

- 명확한 데이터 구조를 알 수 없거나 변경될 가능성이 높은 경우
- 빠른 데이터 조회가 중요한 경우
- 데이터 변경 보다 조회 요청이 훨씬 많은 경우
- 매우 많은 양의 데이터를 저장하고 처리하기 위해 데이터베이스를 수평적으로 확장해야 하는 경우

<br/>

### 추가로 더 공부하면 좋을 내용

- Sharding

### 참고

[SQL vs NoSQL](https://academind.com/tutorials/sql-vs-nosql)
