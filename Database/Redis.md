## Redis(Remote Dictionary Server)

> Key-Value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터베이스 관리 시스템(DBMS)으로, 데이터베이스, 캐시, 메시지 브로커 등으로 사용되는 인메모리 데이터베이스

_인메모리(In-Memory) 데이터베이스: 기존 데이터베이스는 데이터 연산을 위해 I/O 작업 + 물리적 디스크에 대한 쓰기/읽기 작업이 필요하여 요청에 따라 처리 속도가 매우 느려질 수 있음. 따라서 기존 데이터베이스의 느린 처리 속도를 극복하고자 디스크(보조 기억 장치)가 아닌 주 메모리에 데이터를 저장하는 데이터베이스_

- 서비스 규모가 커질수록, 사용자가 많아질수록 데이터베이스에 대한 부하가 증가하여 처리 속도가 느려짐 → Redis를 캐시 서버로 사용
- 시스템 장애가 발생하면 기존 DB는 데이터 복구가 가능한 반면 Redis는 메모리의 휘발성으로 데이터가 손실될 수 있음. 따라서 Redis는 주로 전체 서비스 속도 향상을 위한 보조 데이터베이스로 사용
- 데이터에 만료 시간을 지정할 수 있어 지정된 만료시간이 지나면 해당 데이터는 Redis에서 삭제. 또한 데이터가 만료되진 않았지만 메모리가 찼을 때에도 LRU(Least Recently Used) 알고리즘에 의해 데이터가 삭제
- String, Hash, List, Set, Sorted Set 등 다양한 자료구조 지원

  <img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/3b78ff2c-5270-4c5f-9886-68ec1eae235c" width="55%"/>

  ex. 랭킹 서버 구현 시, RDB를 사용하면 물리적 디스크에 직접 접근하여 데이터를 조회하고 다시 정렬해야 하기 때문에 처리 속도가 느림, but Redis는 Sorted Set이라는 자료구조를 제공하기 때문에 미리 정렬되어 있는 데이터를 바로 읽어오기만 하면 됨

### 캐시(Cache) 서버

- **캐시**: 한 번 읽어온 데이터를 임의의 공간에 저장하여 다음에 다시 읽을 때 빠르게 결과값을 받을 수 있도록 도와주는 공간

**캐시 서버로 성능 향상하는 방법**

- 자주 조회되는 데이터를 Redis에 저장하여 빠르게 조회할 수 있도록 하고 만약 Redis에 해당 데이터가 없다면 데이터베이스에서 조회
- 길고 복잡한 쿼리의 실행 결과를 Redis에 저장해두고 해당 쿼리 결과가 바뀌는 이벤트가 발생할 때마다 Redis의 데이터를 업데이트

**캐시 서버 사용 패턴 2가지**

**Look Aside Cache**

1. 클라이언트가 데이터를 요청
2. 웹 서버는 캐시 서버에서 데이터 존재 여부 먼저 확인
3. 캐시 서버에 데이터가 있으면 DB에서 데이터를 조회하지 않고 캐시 서버에 있는 결과값을 클라이언트에게 바로 반환 (Cache Hit)
4. 캐시 서버에 데이터가 없으면 DB에서 데이터를 조회하여 캐시 서버에 저장하고 결과값을 클라이언트에게 반환 (Cache Miss)

**Write Back**

1. 웹서버는 모든 데이터를 캐시 서버에 저장
2. 특정 시간 동안은 캐시 서버에 데이터가 저장됨
3. 이후 캐시 서버에 있는 데이터를 DB에 저장
4. DB에 저장된 캐시 서버의 데이터는 삭제

- ex. 수강신청 시 강의시간표 테이블에 대한 대량의 `INSERT` 쿼리 요청이 발생 → 각 요청마다 I/O 작업 후 DB에 Write하면 과부하로 DB가 다운될 수 있음 → 해당 요청 내용들을 Redis에 저장해두었다가 일정 시간 이후 DB에 한번에 Write (배치 작업)

  _배치(Batch): 데이터를 실시간으로 처리하는 것이 아닌 일괄적으로 모아서 처리하는 작업, 즉 일정 시간 동안 쌓인 데이터를 배치 작업을 통해 특정 시간에 한꺼번에 처리_

- `INSERT` 요청 데이터들이 DB에 저장되기 전 메모리에 머무르는데 이때 서버에 장애가 발생하여 다운된다면 데이터 손실이 발생할 수 있음
- 로그를 DB에 저장하는 경우 또는 대용량의 Write가 발생하는 경우에 사용

<br/>

### Redis의 주요 특징

- 영속성을 지원하는 인메모리 데이터 저장소
- 읽기 성능 증대를 위한 서버 측 복제를 지원
- 쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding) 지원

  _샤딩(sharding): 하나의 거대한 데이터베이스 또는 네트워크 시스템을 여러 개의 작은 조각으로 나누어 분산 저장하여 관리하는 것_

- 문자열, 리스트, 해시, 셋, 정렬된 셋과 같은 다양한 데이터형을 지원
- Key-Value 구조로 쿼리를 사용할 필요X
- 메모리에서 데이터를 처리하기 때문에 속도가 빠름
- **싱글 쓰레드로 동작**: 한 번에 하나의 명령만 처리 가능 → 중간에 처리 시간이 긴 명령어가 들어오면 이후 명령어들은 모두 앞 명령어가 처리될 때까지 대기

<br/>

### Redis Persistence

> 데이터의 영속성을 보장하기 위해 데이터를 디스크에 저장(백업), 즉 서버가 다운되더라도 디스크에 저장된 데이터를 읽어서 메모리에 로딩

**데이터를 디스크에 저장하는 방식**

- **RDB(Redis Database Backup file, snapshotting) 방식**: 특정 조건이 만족되면 Redis의 전체 데이터를 스냅샷으로 저장하는 방식(실제 dump.rdb 파일로 저장) → 서버가 내려가도 Redis는 dump.rdb 파일을 이용하여 데이터를 복원

  ex. 최소 1000개의 키가 변경된 경우 60초마다 Redis의 전체 데이터를 디스크에 덤프

- **AOF(Append Only File) 방식**: Redis의 모든 write/update **연산 자체**를 모두 log 파일에 기록하는 방식(실제 appendonly.aof 파일로 저장) → 서버가 내려가고 재시작될 때 Redis는 해당 log 파일을 이용하여 연산들을 재수행함으로써 데이터를 복원

<br/>

### Redis 운영 시 주의할 점

- 메모리 관리가 중요: 메모리 여유 공간에 따라 Redis 성능이 좌우되기 때문 → 지속적인 모니터링 필요
- O(N) 관련 명령어(처리 시간이 긴 명령어) 주의: 싱글 스레드의 특성상 한 번에 하나의 명령어만 처리 가능하기 때문
- 서버 장애 발생 시 이에 대한 운영 플랜 필요: 인메모리 DB의 특성상 서버에 장애가 발생했을 경우 데이터 유실이 발생할 수 있기 때문

<br/>

### 참고

[Redis 1](https://devlog-wjdrbs96.tistory.com/374)

[Redis 2](https://seokhyun2.tistory.com/63)

[Redis 3](https://wildeveloperetrain.tistory.com/21)

[우아한 레디스](https://www.youtube.com/watch?v=mPB2CZiAkKM)
