# 시스템 콜(System Call)
### 운영체제란?
* 컴퓨터의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
* 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어로, 다른 응용프로그램이 유용한 작업을 할 수 있는 환경 제공
> 운영체제(OS) : Window, DOS, UNIX, Linux, Mac OS ..<br/>
> 응용프로그램 : 한글, 엑셀, 메모장 등 컴퓨터 내의 다양한 프로그램들 ..
<br/>

### 커널이란?
* 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분 (보통 '운영체제 == '커널')
* 소프트웨어가 컴퓨터 시스템에서 수행되기 위해선 메모리에 그 프로그램이 올라가 있어야 함 <br/>
  운영체제도 소프트웨어이기에 전윈이 켜짐과 동시에 메모리에 올라가야함 <br/>
  but, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라가면 메모리 공간 낭비가 심함.
* 그러므로 운영체제 중 **항상 필요한 부분만**을 전원 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때만 메모리에 올려서 사용<br/>
  이 때 전원 켜짐과 동시에 메모리에 올려지는 운영체제 중 항상 필요한 부분, 즉 메모리에 상주하는 운영체제 부분을 = 커널 이라 함!
<br/>

### CPU 모드
* 사용자 애플리케이션이 시스템을 손상시키는 것을 방지하기 위해 2가지 모드, '커널모드'와 '사용자모드'를 제공
* 커널 모드(Kernel Mode)
  * '0' Mode bit
  * OS가 CPU를 사용하는 모드
  * PC 레지스터가 운영체제가 존재하는 부분을 가리키고 있을 때
  * 운영체제의 코드가 실행되는 모드
  * 특권 명령 : 보안이 필요한 명령, 입출력 장치, 타이머 등 각종 장치에 접근하는 명령
  * 파일 읽기, 파일 쓰기, 메세지 화면 출력 등 많은 부분이 커널모드 사용
  * 시스템 콜을 통해 커널모드로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어(Privileged Instructions) 실행
* 사용자 모드(User Mode)
  * '1' Mode bit
  * PC 래지스터가 사용자 프로그램이 올라가 있는 메모리 위치를 가리키고 있을 때
  * 사용자 프로그램을 수행하는 모드
  * 일반 명령 : 메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 명령들, 모든 프로그램 수행 가능
  * 사용자가 접근할 수 있는 영역에 제한이 있기에 해당 모드에서는 하드웨어 접근 불가
  * -> 이 때, 접근하려면 **시스템 콜** 사용해야 함!
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7d1fW%2FbtrLwA292nm%2F3ldChPMmDQEO1fAQch2Vc0%2Fimg.png"><br/>
<br/>

## 시스템 콜( = 시스템 호출)이란?
* = 운영 체제의 커널이 제공하는 서비스들에 대해, 응용프로그램의 요청에 따라 커널에 접근하기 위해 OS가 제공하는 인터페이스
* = 응용프로그램에서 운영체제에게 어떠한 기능을 수행해달라고 하는 하나의 수단 : 응용프로그램은 시스템 콜을 사용해서 원하는 기능을 수행 가능
* 커널 영역의 기능을 사용자 모드에 있는 응용프로그램이 사용을 가능하게 함! => 프로세스가 하드웨어 직접 접근해서 필요한 기능을 할 수 있음 <br/>
  > * 사용자 프로그램이 디스크 파일을 접근하거나 화면에 결과를 출력하는 등의 작업이 필요한 경우
  > * 사용자 프로그램이 특권 명령의 수행을 필요로 하는 경우
* 사용자 모드에서 시스템 콜 호출 시, 커널 모드로 전환
* 커널 모드에서 에서 시스템 콜 호출 시, 사용자 모드로 돌아가 작업 이어감
* 보통 직접적으로 시스템 콜을 사용하기보단 API(라이브러리 함수)를 통해 사용
<img src ="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbR6eVn%2FbtrLzoAWyG7%2FkuPFQo2NrcnWpfrQideNzk%2Fimg.png"><br/>
* => OS가 제공하는 메모리에 프로그램 적재, I/O처리, 파일시스템 처리 등 여러 서비스들을 사용자 프로세스는 직접 접근하지 않고 시스템 콜 호출을 통해 서비스들을 제공받을 수 있음
<br/>

## 시스템 콜 특징
* 여러 종류의 기능으로 나누어짐
* 각 시스템 콜에는 번호가 할당됨
* 시스템 콜 인터페이스는 시스템 콜 테이블(시스템 콜 번호와 시스템 콜 핸들러 함수 주소로 구성) 유지
* OS는 자신의 커널 영역에서 해당 인덱스가 가리키는 주소에 저장되어 있는 루틴 수행
* 작업 완료 시, CPU에게 인터럽트 발생시켜 수행 완료되었음을 알림
* 예시1 : open() 호출
  <img src="https://velog.velcdn.com/images/nnnyeong/post/31ad75d1-20d8-4029-803b-924aec68a5e6/image.png"><br/>
  * open()이라는 시스템 콜의 인덱스가 가리키는 곳에 이에 대한 처리 과정이 저장되어 있음
* 시스템 콜 발생 시 추가적인 정보가 필요한 경우, OS에 필요한 정보가 담긴 매개변수들 전달 방법
  * 매개변수를 CPU 레지스터에 전달 - 전달해야하는 매개변수보다 래지스터의 수가 작을 수 있음
  * 매개변수를 메모리에 저장하고 해당 메모리의 주소를 레지스터에 전달 - 매개변수의 갯수나 길이 제한 X
  * 프로그램에 의해 스택(stack)에 매개변수 전달(push) - 매개변수의 갯수나 길이 제한 X
  * <img src="https://velog.velcdn.com/images/nnnyeong/post/32ef9d02-5b36-4172-bcc7-613a7f9429f1/image.png"><br/>
* 예시2 : "cp in.txt out.txt" in.txt 내용을 복사하여 같은 내용의 out.txt 파일 생성
  <img src="https://velog.velcdn.com/images/nnnyeong/post/44fa2da5-8eaa-40ce-8a90-a1ffd9ef1941/image.png"><br/>
  * 먼저 사용자로부터 입력 받음. 이 때, I/O **시스템 콜 호출** 필요
  * 이후 'cp' 프로그램 실행 시 'in.txt'파일이 현재 디렉토리에서의 접근 가능 여부를 확인하기 위한 **시스템 콜 호출**
    * 접근이 불가능하다면 **시스템 콜 호출**하며 에러 발생과 함께 프로그램 종료
  * 접근 가능할 경우, 복사한 파일 저장을 위해 'out.txt.' 파일명 존재 여부 검사를 위한 **시스템 콜 호출**
  * 이후 저장하고자 하는 파일 이름이 겹치지 않는다면, 파일을 저장해야 하는데 이 때도 **시스템 콜 호출**
<br/>

## 시스템 콜 필요 이유
* 사용자가 주로 사용하는 프로그램은 유저 레벨 프로그램의 '응용프로그램'으로, 유저 레벨의 함수들 이외의 많은 기능을 구현하기 위해서는 커널의 도움이 필연적임!
* 유저 프로세스(응용프로그램)에서는 유저 모드를 수행할 수 없기 때문에 kernel 관련 사항들은 커널모드로 전환해야 해당 작업을 수행할 권한이 생김
* 여기서 권한이 필요한 이유?!
* 
  > 그 이유는 만약 권한이 없을 때, 해커가 피해를 입히기 위해 악의적으로 시스템 콜을 사용하는 경우나 초보 사용자가 하드웨어 명령어를 잘 몰라서 아무렇게 함수를 호출했을 경우에 시스템 전체를 망가뜨릴 수도 있기 때문이다.<br>
  > 따라서 이러한 명령어들은 특별하게 커널 모드에서만 실행할 수 있도록 설계되었고, 만약 유저 모드에서 시스템 콜을 호출할 경우에는 운영체제에서 불법적인 접근이라 여기고 trap을 발생시킨다.

## 시스템 콜 유형
1. 프로세스 제어 (Process Control)
    * 프로세스 생성(create process)과 종료(end) 및 중지(abort)
    * 메모리에 적재(load) 및 실행(execute)
    * 프로세스 속성 획득과 설정(get process attribute and set process attribute)
    * 시간 대기(wait time)
    * 사건 대기(wait 이벤트), 사건 알림(signal 이벤트)
    * 메모리 할당 및 해제 :  malloc, free
2. 파일 관리 (File Manipulation)
    * 파일 생성(create file) 및 삭제(delete file)
    * 파일 열기(open) 및 닫기(close)
    * 파일 읽기(read), 쓰기(wirte), 위치 변경(reposition)
    * 파일 속성 값 확인 및 지정(get file attribute and set file attribute)
3. 장치 관리 (Device Manipulation)
    * 디바이스 요청(request devices) 및 해제(release device)
    * 읽기, 쓰기, 위치 변경
    * 디바이스 속성 확인 및 지정
    * 비 물리적인 디바이스 해제 및 장착 (장치의 논리적 부착 및 분리)
4. 정보 유지 (Information Maintenance)
    * 시간과 날짜 확인 및 지정(time)
    * 시스템 데이터 확인 및 지정(date)
    * 프로세스, 파일, 디바이스 속성 가져오기 및 설정
5. 통신 (Communication) 
    * 커뮤니케이션 연결 생성 및 삭제
    * 메시지 송수신
    * 상태 정보 전달
    * 원경 장치 부착 및 분리
6. 보호 (Protection)
    * Permission 획득
    * Permission 설정
<br/>

## 시스템 콜 종류
* 프로세스 와 관련된 시스템 호출
  * 프로세스 제어용
    * exec : 자신을 수행 가능한 다른 프로세스로 대치 수행
    * fork : 현재의 프로세스 이미지를 복사하고 child 프로세스를 만듬
    * wait
  * pipe : 파이프
  * signal : 소프트웨어 인터럽트 또는 시그널
  * exit : 프로세스 종료
  * getuid, setuid ... : 사용자 및 그룹 id 접근
* 표준 화일 (장치)에 대한 입출력 시스템 호출
  * open( ), create( ), close( ), read( ), write( ), lseek( ), ...
* 소켓 기반의 입출력 시스템 호출
  * socket( ), bind( ), listen( ), accept( ), connect( ), ...
<br/>
* [시스템 콜 래퍼런스](https://whitesnake1004.tistory.com/2)<br/>
<br/>

## 참고
[[OS] 시스템 콜, System Call](https://velog.io/@nnnyeong/OS-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C-System-Call)<br/>
[시스템 호출(System Call)](https://whitesnake1004.tistory.com/2)<br/>
[[Operating System] (iOS) System Call (시스템콜, 시스템 호출이란?)](https://didu-story.tistory.com/311)<br/>

