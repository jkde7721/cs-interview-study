
#  인터럽트

인터럽트는 CPU가 프로그램을 실행하는 도중에 예외 상황이 발생하여 처리가 필요할 경우 CPU에게 알려 처리할 수 있도록 하는 것이다.

***

**인터럽트가 필요한 이유?**

운영체제는 동시에 여러 작업을 처리할 수 없다. 즉, 한 순간에는 하나의 일만 처리할 수 있다.

 그렇다면 한 번에 여러 작업을 처리하게 하여 처리기의 처리율을 향상 시킬 순 없을까? 이걸 가능하게 해주는 기능이 인터럽트이다.

대표적인 예로 대부분의 I/O 디바이스는 CPU보다 느린데, 이걸 처리하는 동안 CPU가 기다리면 엄청난 낭비이다. 따라서 인터럽트를 이용한다.

지금 실행중인 일보다 더 중요한 일이 발생하면 그 일을 먼저 처리해주고 나서 하던 일을 계속하게 하는 것을 가능하게 해주는 게 인터럽트이다.

***

**인터럽트 종류**

각자마다 종류는 나누는 방식이 다양한데, 크게 외부 인터럽트와 내부 인터럽트로 나누도록 하겠다.

1. 외부 인터럽트 = 하드웨어 인터럽트
하드웨어 인터럽트는 외부 장치 또는 하드웨어에서 생성되는 인터럽트입니다.

-   입출력 인터럽트(I/O interrupt)
입출력 작업의 종료나 입출력의 오류에 의해 CPU의 기능이 요청되는 경우
-   정전,전원이상 인터럽트(Power fail interrupt)
정전이나 전원공급의 이상이 생길 경우, CPU에 인터럽트를 걸어 현재 작업 중이던 프로세스를 대피 시킬 수 있는 신호를 주는 인터럽트
-   외부 신호 인터럽트(External interrupt)
 I/O 장치가 아닌 오퍼레이터나 타이머에 의해 의도적으로 프로그램이 중단된 경우


2. 내부 인터럽트 = Exception
CPU 내부에서 실행하면서 인터럽트에 걸리는 경우입니다.

-   프로그램 검사 인터럽트(Program check interrupt)
0 으로 나누기, OverFlow / UnderFlow 발생, 프로그램에서 명령어를 잘못 사용한 경우, 존재하지 않는 메모리 주소에 접근하는 경우 등 CPU가 처리할 수 없는 예외가 발생할 경우 자신을 인터럽트 걸어서 커널의 처리루틴으로 간다.

-   SVC(Supervisor Call : 감시 프로그램 호출) 인터럽트
사용자가 프로그램을 실행시키거나 Supervisor(감시프로그램)을 호출하는 동작을 수행하는 경우.
supervisor(= 운영체제) 에게 제어권을 넘겨서 해결한다. application에서 직접 내부에 접근하는 것이 아니라 인터럽트를 걸고 커널 모드로 전환한다.

***

**인터럽트 처리**

처리 과정을 보기 전에 용어를 설명하고 가겠다.
 | 용어 | 설명 |
|--|--|
| 프로세스 제어 블록(PCB) | 커널의 데이터 영역에 존재하며 각각의 프로세스마다 고유의 PCB가 있다.  인터럽트 발생 시 수행중이던 memory 주소, 레지스터값, 하드웨어 상태 등등 프로세스의 어느 부분이 수행중이었는지를 저장한다. |
| 프로그램 카운터(PC) | CPU가 수행해야 할 메모리 주소를 담고있는 레지스터로, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다.  |
| 인터럽트 벡터 | 여러가지 인터럽트에 대해 해당 인터럽트 발생 시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다. |  
| 인터럽트 처리 루틴(ISR) |  실질적인 인터럽트 처리 작업을 한다. |

<br>
처리 과정은 크게 [요청 -> 중단 -> 보관 -> 인터럽트 처리 -> 재개] 순이다.

1. 장치가 인터럽트 시그널을 CPU로 보낸다.
2. 인터럽트에 응답하기 전 CPU는 우선 현재 수행 중인 명령어까지는 완료한다.
3. 그 후 대기 중인 인터럽트 요청이 있는지 확인하고, 있을 경우 이제 CPU가 제어를 인터럽트 루틴으로 넘기기 위한 준비를 한다. 처리하던 작업에 대한 정보를 PCB에 저장한다.
4. 인터럽트 벡터를 읽고 ISR주소 값을 얻어서
5. 해당 주소로 가서 인터럽트 서비스 루틴을 실행한다.
6. 처리가 완료되면, PCB를 참고하여 인터럽트 발생 이전으로 복구 시킨 후 하던 일을 한다.
