# 교착상태(DeadLock) vs 기아상태(Starvation)
<details>
  <summary>프로세스의 자원 사용 순서</summary>
  
  * 요청 : 프로세스가 필요한 자원을 요청 -> 요청 수락 시, 자원 할당받음 || 요청 즉시 수락X시, 다른 프로세스가 해당 자원을 사용 중이므로 할당받을 때까지 대기
  * 사용 : 프로세스가 요청한 자원을 점유하여 사용
  * 해제 : 프로세스가 자원 사용을 마친 후에 자원 반납
</details>
<br/>

## 교착상태(DeadLock)
### 교착상태(DeadLock)이란?
* = 무한 대기 상태.
* 2개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있어 다음 단계로 넘어가지 못해 결과적으로 아무것도 완료되지 못하는 상태
* 결코 일어나지 않을 사건(이벤트)에 대해서 프로세스가 기다리고 있는 것
<img src="https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F9009d13f-0296-4219-b82c-d7e30c42bf91%2Fimage.png"><br/>
* 교착 상태 발생하면?
  * 프로세스에 할당된 자원들은 유휴 상태가 되고, 교착 상태에 연관된 프로세스 수가 점점 증가
  * -> 프로세스가 유휴 상태가 되면 CPU가 작업 진행 불가 -> CPU 이용률 하락
<br/>
<br/>

### 교착상태 발생 조건
1. 상호 배제(mutual exclusion) : 1번에 1개의 프로세스만 해당 자원을 사용할 수 있다.
2. 점유 대기(hold and wait) : 프로세스가 최소 1개의 자원을 점유하고 있으면서, 추가로 다른 프로세스에 할당되어 있는 자원을 점유하기 위해 대기하는 프로세스가 존재한다.
3. 비선점(no-preemption) : 다른 프로세스의 어떤 자원에 대한 사용이 끝날 때까지 강제로 그 자원을 빼앗을 수 없다.
4. 순환 대기(circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
   * 순환 대기의 예시 : 점유-대기 사이클<br/>
  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FchXjdy%2FbtrhVs68MoG%2FiyYcbfXAxujQIeKKnqV1ok%2Fimg.png"><br/>
   * 프로세스 집합 = {P0, P1, P2, P3} / 자원 집합 = {R0, R1, R2, R3}
   * 대기 프로세스 집합이 있을 때, P0은 P1이 점유하고 있는 자원을, P1은 P2가 점유하고 있는 자원을, 즉 Pn-1은 Pn이 점유하고 있는 자원을 대기함.
* => 위의 4가지 조건을 모두 만족해야만 교착 상태가 발생할 수 있다 !!
<br/>
<br/>

### 교착상태 예방
교착 상태의 발생 조건 중 하나를 제거하며 예방
1. 점유 대기 부정 
  * 프로세스가 자원을 점유한 채로 다른 자원을 기다리는 일을 없애는 방법
  * 각 프로세스는 실행 전에 필요한 모든 자원을 한 번에 요청해야하고 요청한 자원을 모두 할당받기 전까지는 작업 진행 불가능
  * 많은 자원이 사용되지 않으면서 오랜 시간 할당되어 있어야하므로 자원 효율성이 떨어짐
  * 자주 이용하는 자원이 다른 프로세스에 할당된 경우, 자원을 요청한 프로세스는 모든 자원이 동시에 빌 때까지 무기한 대기해야 하는 경우 발생할 수 있음
  * 적은 수의 자원을 요청한 프로세스가 유리하므로, 많은 수의 자원을 요청한 프로세스의 대기 시간이 길어질 수 있음
  * 기아 상태 발생 가능성이 있어 대화식 시스템에선 사용 불가
2. 비선점 부정
  * 프로세스가 점유한 자원을 강제로 해제할 수 있도록 하는 방법
  * 점유중인 자원을 다른 프로세스가 요구하는 경우, 해당 자원을 반납
  * 어떤 자원을 점유한 프로세스가 추가 자원 요청을 했을 때 기다려야 한다면 프로세스는 현재 점유한 자원을 모두 해제
  * 작업 상태를 쉽게 저장 및 복구 가능할 때 or 자원 해제가 필요한 상황이 빈번하게 발생하지 않을 때 이용 가능ㅇ
  * 프린터, 테이프 드라이브 같은 자원에는 적용X
3. 순환 대기 부정
  * 자원에 고유 번호를 할당한 후 특정 순서대로만 자원을 요청하게하는 방법
  * 자원 할당 그래프에 사이클이 형성되지 않게 함
  * 각 프로세스는 고유 번호의 오름차순으로만 자원 요청 가능(자신이 가지고 있는 자원보다 높은 값의 자원 사용X)
  * 주어진 순서와 다르게 자원을 필요로 하는 프로세스의 경우, 불필요한 자원을 미리 할당받게 되므로 자원 낭비 발생 가능
  * 고유 번호 할당 시, 실제로 사용하는 순서를 반영하여 할당해야 함
* 상호 배제 조건에 대한 방지법은 제외
  * 교착 상태 문제는 한순간에 프로세스를 하나만 사용할 수 있는 자원이기 떄문에 상호 배제 조건(1번에 1개의 프로세스만 자원 사용 가능) 방지는 사실상 불가능 및 무의미
<br/>
<br/>

### 교착상태 회피
* 교착상태 예방보다 덜 엄격한 조건 요구 -> 더 효율적인 자원 이용과 병행성 허용
* 교착 상태가 일어날 가능성을 인정하고 교착 상태가 일어나지 않도록 회피. 요청된 자원을 할당할 경우에 교착 상태가 발생할 위험이 있다면, 요청 겨절
* '사용 가능한 자원의 수 & 할당된 자원의 수 & 프로세스들의 최대 요구 수'에 의해 정의된 자원 할당 상태에 따라 다양한 교착 상태 회피 알고리즘 적용
* **자원 할당 그래프 알고리즘**
  * 프로세스들이 미리 필요한 자원의 요구를 알리는 알고리즘
  * 프로세스들의 자원 요구 사항을 허가했을 때, 사이클이 생성될 수 있는지를 판단 : 사이클 생성 시, 교착 상태 발생 가능성이 있으므로 요구 거부
    
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLS0zH%2FbtrhUXsY4vN%2FX7u5uSNg5CqCZkismgZbO1%2Fimg.png"><br/>

* **은행원 알고리즘**
  * 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 미리 검사하여 교착 상태를 회피.
  * 안정 상태로 남게 되는 경우에만 자원을 할당하고 그렇지 않은 경우에는 다른 프로세스들의 자원 해지시까지 대기함
  * 프로세스 수와 자원 수가 일정해야 사용 가능
<br/>
<br/>

### 교착상태 탐지
* 자원할당 그래프를 통해 교착상태 존재 여부를 알아내고 연관된 프로세스 및 자원을 알아내는 방법
* 순환 대기 존재 여부에 집중
* **자원 할당 그래프 소거 알고리즘**
  * 어떤 프로세스의 자원 요청을 수락할 수 있으면 그 프로세스에 의해 그래프가 소거될 수 있도록 하는 알고리즘
  * 해당 프로세스는 실행을 마치고 자원을 반납할 수 있는 프로세스
  * 그래프 소거 = 프로세스에서 자원으로 향한 화살표와 자원에서 프로세스로 향한 화살표, 모두 제거
  * 모든 프로세스에 의해 그래프가 소거될 수 있으면 교착 상태 발생X

* **쇼사니와 코프만의 교착 상태 탐지 알고리즘**
  * 현재 자원의 할당 상태에 관한 정보를 관리하고 이 상태 정보에 의해 교착 상태 여부를 판단할 수 있는 알고리즘
* 탐지 알고리즘 호출은 '교착 상태 발생 빈도 수 + 교착 상태 발생 시 영향 받는 프로세스의 수'에 따라 결정됨
* 호출하면 교착 상태의 문제점인 프로세스 수 증가를 해결할 수 있으나 시스템 부하 증가하므로 .. 적당히.. 하깅!.. 빈도 줄이기..!
<br/>
<br/>

### 교착상태 회복
* = 순환 대기 상태에서 벗어나는 것. 보통 수행한 작업을 잃긴 함
* **프로세스 중지**
  * : 스템이 중지된 프로세스에 할당된 모든 자원의 해제를 요구하는 방법
  * 교착상태의 프로세스 모두 중지
    * 교착 상태의 순환 대기를 확실하게 해결할 수 있음
    * But 자원 사용과 시간 부분에서 비용 多
  * 교착상태가 제거될 때까지 프로세스 1개씩 중지
    * 프로세스 1개가 중지될 때마다 교착 상태 탐지 알고리즘을 호출하여 프로세스의 교착 상태 여부 확인 : 교착 상태 탐지 알고리즘 호출 부담 多
    * 어느 프로세스를 중지할 지 다음의 기준을 바탕으로 신중하게 결정해야함
      * 프로세스 우선순위가 낮은 것부터 중지
      * 프로세스 수행 시간+종료하는데 필요한 시간이 낮은 것부터 중지
      * 중단 가능한 자원을 점유하고 있는 프로세스부터 중지
      * 프로세스 종료에 필요한 자원 수가 적은 프로세스부터 중지
      * 중지해야 할 프로세스 수가 적은 것부터 중지
      * 일괄식 프로세스부터 중지 

* **자원 선점**
  * : 교착 상태가 해결될 때까지 프로세스의 자원을 빼앗아 다른 프로세스에 할당해주는 방법
  * 교착상태의 프로세스가 점유하고 있는 자원을 빼앗아 다른 프로세스에게 할당
  * 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점
  * 자원 선점 위해선 아래의 3가지 해결 사항 존재
    * 선점 자원 선택
      * 비용 최소화위해 적절한 선점 순서를 결정해야 함
    * 복귀
      * 자원을 빼앗긴 프로세스는 정상 실행이 불가하므로 프로세스를 안전한 상태로 복귀시킨 후 재시작해야함
      * 시스템이 실행하는 모든 프로세스의 상태 정보를 유지해야 하는 부담 존재
    * 기아
      * 비용에 근거한 시스템에서는 동일 프로세스가 반복하여 희생자로 선택되기 쉬움
      * 프로세스가 짧은 시간 동안에만 희생자로 선택됨을 보장해야 함
      * 해결법 : 비용 요소에 복귀 횟수 포함
<br/>
<br/>

## 기아상태(Starvation)
### 기아상태(Starvation)란?
* = 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태
* 프로세스의 우선순위에 따라 할당할 경우, 우선순위가 낮은 프로세스들이 기아 상태에 빠질 수 있음
<br/>

### 기아상태 해결
* 프로세스 우선순위를 수시로 변경하여 각 프로세스들이 높은 우선순위를 가질 수 있는 기회 부여
* 오래 기다린 프로세스의 우선순위 높이기 = 에이징
* 우선순위가 아닌 요청 순대로 처리하는 요청큐 사용
<br/>

### 식사하는 철학자(Dining Philosophers)
* 병행 프로세스와 교착 상태, 기아 상태를 설명하는 프로세스 동기화 문제<br/>

Q. 5명의 철학자가 원탁에 앉아있다. 철학자들 사이에는 포크가 하나씩 놓여 있고 다음 과정을 통해 식사를 한다.<br/>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcmNqm1%2FbtrhVEsXXRR%2FcoiAaKkYWtkKBMIk7l0hTK%2Fimg.png"><br/>
1. 일정 시간 생각을 한다. 
2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다. 
5. 오른쪽 포크를 내려놓는다.
6. 왼쪽 포크를 내려놓는다.
7. 다시 1번으로 돌아간다. <br/>

만약 모든 철학자들이 자신의 왼쪽 포크를 잡는다면 모든 철학자들은 오른쪽 포크가 사용 가능해질 때까지 기다려야 한다. <br/>
<br/>
* **해결법**
1. 타임아웃 설정
    * 철학자가 포크를 집고 일정 시간 내에 다른 쪽 포크를 획득하는데 실패한다면, 포크를 반납하게 한다.
    * 가장 간단하지만 타임아웃에 따른 딜레이 존재
2. 철학자들 중 하나는 포크를 오른쪽부터 잡게 함
    * 예를 들어 1번 철학자는 왼쪽부터, 2번 철학자는 오른쪽부터 잡는다. 1번 철학자가 왼쪽 포크만 잡은 상태에서 행동권이 2번 철학자에게 넘어간다고 하더라도, 2번 철학자는 자신의 오른쪽 포크에 대해 현재 사용이 불가능하다.<br/>
    그러므로 2번 철학자는 첫번째 포크를 잡으려는 상황에서 멈춰 있게 된다. 이 상황에서 1번 철학자로 다시 행동권이 넘어오게 되면 1번 철학자는 자신의 오른쪽 포크를 잡고 다시 식사를 할 수 있게 된다. <br/>
3. 세마포어 이용
    * 포크를 세마포어로 표시하여 상호 배제(한 번에 한 개의 포크만 사용 가능)를 구현 + 포크는 양쪽 철학자 2명이 동시에 사용할 수 없으므로 각 포크에 대한 상호배제 필요
    * 각 세마포어(포크)는 1로 초기화
    * 철학자가 포크를 집으려면, 세마포어에 대한 P연산을 수행한다.
    * 철학자가 포크를 내려놓으려면, 세마포어에 대한 V 연산을 수행한다.<br/>
  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcj3w6X%2Fbtrh3qHdcC6%2FNJdWHfV7s2N94gLUrQoxO0%2Fimg.png"><br/>
      1. 철학자 2가 최초로 fork[2]와 fork[3]을 집어서 식사를 시작한다.
      2. 철학자 3이 식사를 시작하려면, fork[3]과 fork[4]를 집어야 한다.
      3. 철학자 3은 철학자 2가 이미 P연산을 통해 fork[3]을 집었으므로, 식사를 시작할 수 없다.
      4. 철학자 2가 V연산을 통해 fork[2]와 fork[3]을 내려놓으면, 철학자 3이 식사를 시작할 수 있다.
    <br/>
    
    ```sql
    // 세마포어 포크 배열을 1로 초기화
    semaphore fork[5] = {1};

    while (true) {
        // P 연산 //
        wait(fork[i]);       // 왼쪽 포크를 집음
        wait(fork[i+1]%5]);  // 오른쪽 포크를 집음
    
        /* 식사 한다 */
      
        // V 연산 //
        signal(fork[i]);      // 완쪽 포크를 내려둠
        signal(fork[i+1]%5);  // 오른쪽 포크를 내려둠
    
        /* 생각 한다 */
    }
    ```
    <br/>
  * 이 경우, 5명이 동시에 모두 왼쪽 포크를 먼저 집어 들고, 오른쪽 포크를 집으려고 하는 경우 발생하는 교착상태 해결법
    * 철학자 4명만 테이블에 동시에 앉도록 하는 방법 : 프로세스 1개를 강제로 줄임으로써, 사이클 형성 원인을 원천 차단
    * 철학자가 양쪽 모든 포크를 집을 수 있을 때만 포크를 집도록 허용하는 방법 : 양쪽 포크는 1번 잡을 때 무조건 동시에 잡을 수 있도록 제한하여 포크 1개만 집는 경우를 예방(양쪽 포크를 동시에 잡는 작업은 임계 영역 내에서 이루어져야 함)
    * 비대칭 해결법 : 홀수 번째 철학자는 왼쪽 포크를 집은 후에 오른쪽 포크를 집을 수 있고 짝수 번째 철학자는 오른쪽 포크를 집은 후에 왼쪽 포크를 집을 수 있음.
<br/>
<br/>

## 교착상태(DeadLock)와 기아상태(Starvation) 차이점
* 교착상태
  * 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태
  * 여러 프로세스가 동일 자원 점유를 요청할 때 발생
* 기아상태
  * 프로세스가 원하는 자원을 계속 할당 받지 못하는 상태
  * 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생
<br/>
<br/>

## 참고
[[운영체제] 교착상태 (Deadlock) 및 기아상태(Starvation)](https://excited-hyun.tistory.com/121)<br/>
[OS #24 교착상태와 기아상태](https://velog.io/@underlier12/OS-24-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%99%80-%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C)<br/>
[5. 교착 상태와 기아 상태](https://arainablog.tistory.com/276)<br/>
