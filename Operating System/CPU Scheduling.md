## CPU Scheduling

### 스케줄링(Scheduling)

> 프로세스 실행을 위해 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업

**프로세스 상태**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/c98d5c1b-97fd-44f6-80e8-caff08d40463" width="60%"/>

- `new`: 새로운 프로세스가 생성된 상태
- `ready`: 모든 실행 준비가 완료되어 CPU 할당을 기다리고 있는 상태
- `running`: CPU에서 프로세스가 실행되고 있는 상태
- `waiting`: I/O 작업 종료나 다른 이벤트 발생을 기다리고 있는 상태
- `terminated`: 프로세스 실행을 완료하고 종료된 상태

**스케줄링 큐(Scheduling Queue)**

- 스케줄링을 위한 큐, 즉 프로세스를 관리하기 위한 큐
- **Job-Queue**: 프로세스가 하드 디스크 → 메모리로 로드되기 위해 대기하는 공간, 하드 디스크에 존재
- **Ready-Queue**: 메모리에 로드된 후 CPU 할당을 위해 대기하는 공간, 메모리에 존재
- **Device-Queue**: I/O 작업을 위해 대기하는 공간, Device Controller(입출력 하드웨어 ex. 프린터)에 존재

<br/>

### 단계별 처리 스케줄링

**장기 스케줄링(Long-term Scheduling)**

- 어느 프로그램을 메모리에 먼저 적재할 것인가를 결정
- 하드 디스크에서 메모리로 프로세스를 load해서 ready 상태로 만들 프로세스를 선택하는 단계

  ex. 현재 수행해야 하는 프로그램이 10개이고 메모리에는 5개만 올리는 것이 가능할 때 10개의 프로그램 중 우선순위 등의 기준에 따라 5개를 선택해서 메모리에 올려주는 역할

- 메모리에 적재한 프로세스가 종료되어야 새로운 프로세스를 로드하기 때문에 자주 발생하지 않아 장기 스케줄링
- 현대의 OS는 일반적으로 장기 스케줄러X: 과거에는 적은 양의 메모리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 적어 장기 스케쥴러가 이를 조절하는 역할을 한 반면 현대의 OS는 장기 스케줄러 없이 프로세스를 바로 메모리에 적재 (가상메모리 기법으로 메모리 양에 대한 제한이 줄었기 때문)

**단기 스케줄링(Short-term Scheduling) = CPU Scheduling**

- OS가 여러 ready 상태 프로세스 중에서 CPU를 할당하여 실행시킬 프로세스를 선택하는 과정
- Ready-Queue의 프로세스 중 CPU를 차지할 프로세스들을 선택하는 단계
- CPU 스케줄링이라고도 하며 CPU 스케줄러는 프로세스들에 CPU를 배분하는 역할을 하므로 이를 **디스패처(Dispatcher)** 라고도 부름
- CPU는 비싼 자원으로 idle 상태의 CPU가 있을 때마다 다른 프로세스에 해당 CPU를 할당하는 스케줄링이 발생 → CPU 스케줄링은 짧은 텀으로 자주 수행되기 때문에 단기 스케줄링

**중기 스케줄링(Medium-term Scheduling)**

- 컴퓨터 자원 고갈 등의 이유로 메모리에 적재된 프로세스 중 일부에 대하여 상당 기간 동안 처리를 보류시켜야 할 때, 여러 가지 요인을 고려하여 보류 대상 프로세스를 선택하는 단계
- 운영체제는 처리가 보류된 프로세스들을 처리 재개가 가능할 때까지 메모리에서 하드 디스크로 옮기는데, 이 과정을 스왑 아웃(Swap out)이라고 부르고, 처리를 재개하여 해당 프로세스를 하드 디스크에서 메모리로 다시 옮기는 과정을 스왑 인(Swap In)이라 함
- 장기 스케줄링과 같은 이유로 요즘에는 잘 사용하지 않음

<br/>
<hr/>
<br/>

## CPU Scheduling Algorithm

- CPU 스케줄링: 여러 프로세스들의 실행 순서를 어떻게 정하고 얼만큼의 시간을 할당할 것인가를 결정하는 과정
- 스케줄링 성능 지표

  **사용자 관점**

  - 응답 시간(Response Time): 사용자 데이터 입력 후, 출력이 이루어질 때까지의 소요 시간
  - 반환 시간(Turnaround Time): 프로그램 제출(혹은 시작) 후, 끝날 때까지 소요되는 총 시간
  - 대기 시간(Waiting Time): 프로세스들이 준비(ready) 상태로 Ready-Queue에서 기다린 시간의 총합

  **시스템 관점**

  - CPU 이용률: 총 경과 시간 대비 CPU가 순수하게 사용자 프로세스를 수행한 시간의 비율
  - 처리율: 단위 시간당 처리된 프로세스의 개수

➡️ 사용자 관점과 시스템 관점에서의 CPU 스케줄링 성능 지표 사이에는 상호 배타적인 관계 존재 (짧은 응답 시간을 위해 프로세스들에게 CPU를 자주 골고루 할당해주게 되면 운영체제의 스케줄링이 빈번하게 실행되어 CPU 이용률과 처리율이 낮아짐 + context switching에 따른 오버헤드 증가)

<br/>

### CPU 스케줄링이 발생하는 시기

**프로세스가 입/출력을 요구할 때**

- **CPU 버스트(Burst)**: CPU가 할당되어 실행 중인 주기
- **I/O 버스트(Burst)**: 입/출력이 이뤄지는 주기, 입/출력이 완료될 때까지 해당 프로세스에 CPU 할당 불가
- `accept()`, `connect()`, `send()`, `recv()`, `open()`, `close()`, `fgets()`, `printf()` 등과 같은 운영체제의 입/출력 시스템 콜 실행 ~ 해당 입/출력이 완료될 때까지가 I/O 버스트이고, 그 외 부분은 모두 CPU 버스트
- I/O 버스트가 시작되면 운영체제는 CPU를 다른 프로세스에게 할당해주기 위해 CPU 스케줄링

**프로세스가 종료를 요구할 때**

- 프로세스가 `exit()` 종료 시스템 콜을 호출한 경우 운영체제는 CPU를 할당할 새로운 프로세스를 찾기 위해 CPU 스케줄링

**높은 우선순위의 프로세스가 나타났을 때**

- 프로세스 상태가 `waiting` → `ready`로 전이되면 해당 프로세스는 CPU 할당 대상에 새롭게 추가
- 입/출력 완료 인터럽트가 발생하면 CPU는 실행 중이던 프로세스에서 잠시 떠나 운영체제의 인터럽트 핸들러로 이동하여 준비 상태의 새로운 프로세스가 나타났음을 인식 → 만약 이 새로운 프로세스의 우선순위가 이전에 떠나왔던 프로세스보다 높다면 CPU 스케줄링에 따라 CPU 할당을 즉시 교체

**주어진 CPU 실행 시간을 초과했을 때**

- 대부분의 사용자 프로그램은 CPU 버스트와 I/O 버스터가 번갈아 섞여 있어 다수의 프로세스 사이에서 CPU가 골고루 할당
- but 어떤 프로그램은 CPU 버스트로만 구성되어 있을 수 있음, 즉 입/출력 작업은 극히 적고 CPU 연산으로만 구성된 경우 → 해당 프로세스가 CPU를 오랫동안 점유하고 있어 CPU의 고른 분배가 어려워짐
- 어느 한 프로세스가 연속해서 CPU를 사용할 수 있는 최대 시간을 초과한 경우 CPU를 다른 프로세스에게 할당

  _이때 설정된 최대 시간은 타임 퀸텀(Time Quantum) 또는 타임 슬라이스(Time Slice)라 부름_

<br/>

### CPU 스케줄링 전략 분류

- 프로세스 스스로의 요구에 의해 이루어지는 **자율적 CPU 반납**: 입/출력, 종료
- 외부 상황에 따라 CPU를 강제로 회수당하는 **타율적 CPU 반납**: 높은 우선순위 출현, 타임 퀀텀 초과

- CPU 반납 방식의 자율성 및 타율성 여부에 따라 크게 2가지로 분류

  - **비선점형 스케줄링(Non-preemptive Scheduling)**: 실행 중인 작업이 끝나야만 CPU 사용권을 넘겨주는 방식, 즉 실행 중인 프로세스가 자율적으로 CPU를 반납할 때까지 CPU를 계속 점유
  - **선점형 스케줄링(Preemptive Scheduling)**: 실행 중인 작업이 끝나지 않아도 운영체제에 의해 강제로 CPU 사용권을 빼앗는 방식 (자율적 + 타율적 CPU 반납), 어떤 프로세스도 일정 시간 이상 동안 연속해서 CPU 점유 불가능 → CPU 버스트 위주의 프로세스가 많이 적재되더라도 모든 프로세스의 응답 시간을 평균 이상으로 유지 가능

<br/>

### 선입 선처리(FCFS: First-Come First-Served) 스케줄링

> 프로세스가 대기열(Ready-Queue)에 도착하는 순서에 따라 CPU를 할당하는 전략

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/f8291b96-7d38-4db6-8f82-4f84a5e82a8f" width="70%"/>

- 가장 간단하면서도 구현이 쉬운 방법
- 먼저 온 프로세스의 실행 시간이 매우 길어 뒤에 실행 시간이 짧은 프로세스가 도착하더라도 먼저 온 프로세스가 완료될 때까지 기다려야 함 → 프로세스의 실행 순서에 따라 평균 대기 시간이 길어질 수 있음
- 호위 효과(Convoy Effect): 실행 시간이 긴 프로세스가 먼저 실행되어 전체적인 대기 시간이 증가하는 효과 → FCFS가 비선점형 스케줄링이기 때문에 발생하는 문제

<br/>

### 최단 작업 우선(SJF: Shortest-Job-First) 스케줄링

> CPU 버스트(CPU 작업 시간)가 가장 짧은 프로세스를 CPU에 먼저 할당하는 전략

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/18c95d17-1668-4943-a3e7-bbb8781e4861" width="70%"/>

- 평균 대기 시간과 평균 응답 시간이 FCFS에 비해 개선
- 프로세스의 CPU 작업 시간은 어떻게 알지? 이전의 CPU 작업 시간을 이용하여 다음 작업 시간을 예측 → 최근의 작업 시간과 전체 과거의 작업 시간을 따로 계산하고 두 값에 가중치를 부과하여 합함
- SJF는 비선점형이므로 계산 위주의 긴 프로세스에 CPU가 할당된 상태에서 다수의 입/출력 위주 짧은 프로세스들이 도착한다면 마찬가지로 호위 효과 발생 가능
- 짧은 프로세스들이 지속적으로 도착한다면, 상대적으로 긴 프로세스는 계속해서 실행이 지연되는 기아 상태(Starvation State) 발생

<br/>

### 최단 잔여 시간 우선(SRTF: Shortest-Remaining-Time-First) 스케줄링

> 비선점형인 SJF 스케줄링의 단점을 보완하기 위해 대기열에 새로운 프로세스가 도착하면, 현재 진행 중인 프로세스의 잔여 실행 시간과 새로운 프로세스의 CPU 버스트 시간을 비교하여 새 프로세스의 실행 시간이 더 짧으면 CPU를 강제 회수하여 새로운 프로세스에 할당하는 선점형 스케줄링

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/1d06c8f6-cc39-4775-8206-f3f75003c3ce" width="70%"/>

- ex. 2초에 P1 프로세스의 잔여 시간은 **13(= 15-2)초**, 새로 도착한 P2 프로세스의 CPU 버스트 시간은 **2초**로 P2의 실행 시간이 더 짧으므로 P1에 할당된 CPU를 강제 회수하여 P2에 할당
- ex. 3초에 P3 프로세스가 도착하지만 P2 프로세스의 잔여 시간은 **1(= 2-1)초**, P3 프로세스의 CPU 버스트 시간은 **4초**로 P2의 잔여 실행 시간이 더 짧으므로 P2 프로세스를 계속 실행
- 평균 대기 시간과 평균 응답 시간을 더욱 개선
- 여전히 기아 상태 발생 가능성↑

<br/>

### 우선순위(Priority) 스케줄링

> 우선순위가 높은 프로세스를 CPU에 먼저 할당하는 전략

- SJF 스케줄링은 CPU 작업 시간을 기준으로 우선순위를 부여한 우선순위 스케줄링의 한 종류
- 우선순위는 일반적으로 정수로 나타내며 작은 값이 높은 우선순위
- CPU 작업 시간, 메모리 할당량 등의 내부적 요인 또는 정치적 이유, 요금제 가격 등의 외부적 요인에 따라 프로세스의 우선순위가 결정
- 프로세스의 우선순위가 계속해서 밀려 프로세스의 실행이 지연되는 문제 발생 → 기아 상태 또는 무한 봉쇄(Indefinite Blocking)
- 노화(Aging): Ready-Queue에서 오래 대기할 수록 프로세스의 우선순위를 높여줘 기아 상태 해결

<br/>

### 라운드 로빈(RR: Round-Robin) 스케줄링

> 전형적인 선점형 스케줄링 전략으로, 모든 프로세스에 동일한 최대 CPU 점유 시간(타임 퀀텀)을 설정하고, 처리 중인 프로세스의 CPU 실행 시간이 타임 퀀텀을 초과하면 CPU를 강제로 회수하여 다음 프로세스에 할당하는 전략

- 모든 프로세스들에게 CPU가 할당될 기회가 동일하게 주어지므로 대화형 시스템 환경에 적합
- Time Quantum(= Time Slice): 프로세스에 CPU가 할당되는 일정한 시간
- 적절한 타임 퀀텀 설정이 매우 중요

  - 타임 퀀텀 값이 무한대에 가까워질 수록 FCFS와 동일
  - 타임 퀀텀 값이 0에 가까워질 수록 context switching이 자주 발생하여 시스템 오버헤드 증가, 전체적인 처리율 감소

<br/>

### 다단계 큐(MQ: Multi-level Queue) 스케줄링

> 프로세스 특성별로 준비 큐를 여러 개 두어 우선순위를 부여하고, 높은 우선순위 큐들이 모두 비었을 때만 다음 단계의 낮은 우선순위 큐의 프로세스들에게 CPU를 할당하는 전략

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/a6664fb7-c7f3-4941-874c-c260e89afd34" width="55%"/>

- 프로세스의 특성에 따라 여러 개의 큐를 계층적으로 분리

  - 시스템 프로세스 준비 큐 (우선순위 가장 높음)
  - 대화형(입/출력 위주) 프로세스 준비 큐
  - 계산 위주 프로세스 준비 큐
  - 후면처리 프로세스 준비 큐 (우선순위 가장 낮음)

- 모든 프로세스는 자신의 특성에 따라 한 개의 큐에 영구적으로 할당
- 각 준비 큐에는 해당 프로세스의 특성을 반영하는 타임 퀀텀을 설정
- 준비 큐 별로 FCFS, SJF, RR 등 다른 스케줄링 전략 적용 가능

<br/>

### 다단계 피드백 큐(MFQ: Multi-level Feedback Queue) 스케줄링

> 응용 프로그램은 대부분 계산 위주 단계(CPU 버스트)와 입/출력 위주 단계(I/O 버스트)를 반복하므로 프로세스 진행 과정에서 그 특성이 변하면 이를 인지하여 해당 프로세스를 적절한 준비 큐로 이동시켜주는 전략

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/6f6520ad-891d-4b99-a453-db0f3dcbdff5" width="55%"/>

- 모든 프로세스는 가장 상위의 큐로만 진입하고 CPU 작업 시간이 긴 프로세스는 하위 큐로 이동, 기아 상태가 발생하면 aging을 통해 우선순위가 높은 상위 큐로 이동 → 큐들 사이에서의 프로세스의 이동 허용
- 실행 중인 프로세스가 해당 큐의 타임 퀀텀을 소진하지 못하고 입/출력 등으로 CPU를 자진 반납하면, 이 프로세스는 입/출력 성향이 강해진 것으로 인식하여 상위 큐로 이동시킴
- 실행 중인 프로세스가 주어진 타임 퀀텀을 모두 소진한 후 CPU를 강제로 회수당하면, 이 프로세스는 계산 성향이 강해진 것으로 인식하여 하위 큐로 이동시킴
- 프로세스의 특성에 적합한 스케줄링 정책을 가진 큐로 점진적으로 이동, 이외 실행은 MQ 스케줄링과 유사

<br/>

### 참고

[프로세스 상태](https://jhnyang.tistory.com/7)

[스케줄링 큐](https://dkwjdi.tistory.com/241)

[CPU 스케줄링 1](https://resilient-923.tistory.com/366)

[CPU 스케줄링 2](https://boycoding.tistory.com/258)

[CPU 스케줄링 3](https://jooona.tistory.com/11)

[경성대 운영체제 강의](https://www.youtube.com/watch?v=QwBe0iYZBEg&list=PLK4xviZcdB9ieuusJ5j1UYZMFTuAgZCq8&index=6)
