## IPC(Inter Process Communication)

> 프로세스는 다른 프로세스에게 영향을 주지도 받지도 않는 독립적인 프로세스(Independent Process)와, 영향을 주고 받으며 자원을 공유하는 협력적인 프로세스(Cooperating Process)로 나눌 수 있음. 이때 협력적인 프로세스 간에 데이터를 주고 받는 행위 또는 이에 대한 방법이 IPC

- 하나의 프로그램을 실행하더라도 여러 프로세스 간 협력이 필요 ex. 하나의 task를 여러 개의 sub task로 나누어 더 빠르게 수행하는 경우, 동시에 여러 개의 task를 처리하는 경우
- 프로세스는 독립적인 실행 객체 → 자신에게 할당된 메모리 영역에 대해서만 접근 가능 → 다른 프로세스와 통신하기 위해서는 별도의 메모리 영역 필요
- 커널이 제공하는 IPC 설비를 이용해 프로세스 간 통신 가능
- 즉 IPC는 컴퓨터 내부에서 보다 효율적으로 정보를 주고 받는 통신의 일종으로 인터넷 통신을 IPC의 확장으로 이해할 수 있음 (프로세스 간 통신은 서버-클라이언트 간 통신과 유사)
- 대표적인 IPC 모델: **Shared Memory**, **Message Passing**

<br/>

### Shared Memory

> 프로세스 간 공유되는 메모리 영역을 통해 데이터를 주고 받음

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/1fc685d9-f76b-47a4-84ba-9095793414e0" width="65%"/>

- 다수의 프로세스들이 공유된 메모리 영역에 읽기/쓰기를 통해 통신 수행
- 프로세스가 공유 메모리 할당을 커널에 요청 → 커널이 메모리 영역을 생성하면 통신할 프로세스에 해당 메모리 영역을 첨부(attach) → 이후의 통신은 커널의 관여 없이 수행
- 보통 운영체제는 한 프로세스가 다른 프로세스의 주소 공간에 접근하는 것을 막음 → 프로세스 간 공유되는 메모리 영역은 운영체제에 의해 특별히 관리됨
- 생성된 공유 메모리는 컴퓨터를 다시 시작하거나 직접 공유 메모리 공간을 해제하지 않는 이상 이 영역을 공유하는 모든 프로세스가 종료되더라도 유지 (`shmctl()` 시스템 콜을 통해 공유 메모리 해제 가능)
- 공유될 메모리 영역이 커널에 의해 생성되면 이 영역은 `shmat()` 시스템 콜을 통해 각 프로세스 메모리의 데이터 영역에 attach 됨 (공유 메모리 영역을 프로세스 내에 첨부하여 마치 자신의 메모리처럼 사용)

**장점**

- 중개자(커널) 없이 바로 메모리에 접근할 수 있기 때문에 모든 IPC 중 가장 빠른 속도
- 대량의 정보를 다수의 프로세스에게 배포 가능
- 프로그램 레벨에서의 통신 기능을 제공하여 자유로운 통신 가능

**단점**

- 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 적절한 동기화가 필요
- 즉 동시에 같은 메모리 위치에 접근할 수 있음 → IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어(Semaphore)와 뮤텍스(Mutex) 사용 (공유 자원에 대한 프로세스의 접근을 제한하기 위해)

<br/>

### Message Passing

> 프로세스 간 교환되는 메시지를 통해 데이터를 주고 받음

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/688d7c22-433f-4599-a829-b3d2999c0bd8" width="27%"/>

- 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어 협력 프로세스 간에 메시지 형태로 데이터를 Send/Receive
- ex. 프로세스 P가 커널로 메시지를 보내면 커널이 프로세스 Q에게 메시지를 보내줌
- 커널을 통해 메시지를 주고 받으며 커널에서는 데이터를 버퍼링함
- 메시지 전달을 위해 프로세스 간 생성되는 링크 또는 채널인 Communication Link의 구현 방법에 따라 여러 종류로 나뉨: Direct or Indirect Communication / Synchronous or Asynchronous Communication / Automatic or Explicit Buffering
- Message Passing 모델의 예시: **파이프**, **메시지 큐**, **소켓**

**장점**

- 프로세스 간 메모리 공유 없이 통신 가능
- 커널에서 데이터를 주고 받는 것을 제어하기 때문에 별도의 동기화 로직 필요X

**단점**

- 커널을 통해 데이터를 주고 받기 때문에 Shared Memory 모델보다 느림

**Direct Communication**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/55386fc2-03af-4d75-9ae7-33599a7a0d85" width="55%"/>

- 통신하려는 프로세스의 이름을 명시적으로 표시하여 메시지를 직접 전달하는 방식
- 프로세스 간 링크는 유일하며 대부분 양방향으로 구성됨
- ex. 프로세스 P가 프로세스 Q에게 메시지를 전달하고자 할 때, 커널에게 프로세스 P가 직접 메시지를 전달하면 커널이 프로세스 Q에게 해당 메시지를 전달하는 방식

  `send(Q, message)`: 프로세스 Q에게 메시지를 전송

  `receive(P, message)`: 프로세스 P로부터 메시지를 수신

**Indirect Communication**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/b2bb2547-fbe0-4b3c-bede-76c18fa21f4f" width="55%"/>

- mailbox(또는 port)를 통해 메시지를 간접적으로 전달하는 방식
- port로만 전송하면 되기 때문에 복잡한 Communication Link 생성이 가능하며 상대 프로세스의 `pid`를 알 필요가 없음
- 프로세스 간 여러 개의 링크가 생성될 수 있음 (port가 여러 개)
- ex. 프로세스 P가 프로세스 Q에게 메시지를 전달하고자 할 때, 프로세스 P가 커널 내부 특정 포트에 메시지를 저장해놓으면 프로세스 Q가 해당 포트에 접근하여 메시지를 전달받는 방식

  `send(M, message)`: mailbox M으로 메시지를 전송

  `receive(M, message)`: mailbox M으로부터 메시지를 수신

<br/>

### Pipe(파이프)

> 2개의 프로세스를 파이프로 연결하여 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 하면서 통신하는 방식

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/de7695d7-78a0-432b-a289-73b673128dbe" width="55%"/>

- **파이프**: 여러 개의 프로세스가 공통으로 사용하는 임시 공간(파일 시스템에 생성되는 임시 파일), 프로세스에 속하는 자원이 아닌 운영체제에 속하는 자원으로 `fork`의 복사 대상이 아님 (\*`fork`: 자식 프로세스를 생성하는 시스템 콜)
- `int pipe(int filedes[2]);` 시스템 콜로 파이프를 생성하면 파이프의 출입구가 되는 파일 디스크립터를 얻을 수 있음

  - `fork` 호출로 자식 프로세스 생성 시 파이프가 복사되는 것이 아닌 파이프 생성 시 얻은 파일 디스크립터가 복사 → 부모, 자식 프로세스는 파일 디스크립터를 공유하여 동일한 파이프에 접근 가능
  - `filedes[0]`: 파이프의 읽기 전용 디스크립터 (파이프의 출구)
  - `filedes[1]`: 파이프의 쓰기 전용 디스크립터 (파이프의 입구)

- 파이프에 들어간 데이터는 수신자가 따로 지정된 것이 아닌 먼저 가져간(읽어간) 프로세스가 임자, 즉 발신자가 가져갈 수도 있음
- 1:1 통신으로 한 방향으로만 데이터가 이동 (반이중 통신) → 송수신을 모두 하기 위해서는(전이중 통신을 위해서는) 파이프 2개 필요
- 한 쪽 프로세스는 단지 쓰기만 하고 다른 프로세스는 단지 읽기만 하는 단순한 데이터 흐름에 적합

**익명 파이프(Anonymous Pipe)**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/ce79e85f-d86b-4909-8fa4-21a6bfa251bf" width="65%"/>

- 일반적인 파이프 방식으로 통신할 프로세스를 명확히 아는 경우 사용
- 주로 부모-자식 간의 단방향 통신에 사용되며 외부 프로세스와는 사용 불가
- 파이프에 접근하기 위한 FD(파일 디스크립터)는 부모, 자식 프로세스끼리만 공유되므로 다른 프로세스와는 해당 파이프를 사용하여 통신 불가능

**네임드 파이프(Named Pipe)**

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/1dd51b91-408a-4081-bb1c-8771adc91bd2" width="65%"/>

- 서로 관련 없는 프로세스들 간의 통신에 사용
- 익명 파이프의 확장으로 부모 프로세스와 무관한 다른 프로세스와도 통신 가능 → 외부 프로세스와 통신 가능 (다른 프로세스도 지정한 이름으로 파일 디스크립터를 열어 파이프에 접근 가능하기 때문)
- 프로세스 통신을 위해 이름이 있는 파일을 사용, 즉 `FIFO`라 불리는 특수 파일을 이용해 서로 관련 없는 프로세스 간 통신

<br/>

### Message Queue(메시지 큐)

> FIFO 자료구조를 가지는 큐를 이용하여 데이터를 송수신하는 방식

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/8939415c-440f-49fd-95c9-7acc63a810b9" width="50%"/> &nbsp;&nbsp;&nbsp; <img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/6cd9c0af-f0a7-4af2-9326-e3bf51c5048c" width="45%"/>

- 파이프가 스트림(데이터의 흐름) 기반으로 동작한다면, 메시지 큐는 메시지(또는 패킷) 단위로 동작
- 부모-자식 관계가 아니더라도 어느 프로세스 간에 데이터 송수신 가능
- 단방향 통신으로 다수의 프로세스 간 통신 가능
- 네임드 파이프와 비슷하게 동작하지만 여러 개의 프로세스가 하나의 큐에 대해 수신 가능하다는 차이 → 잘못된 수신자가 메시지를 채갈 수 있음 → 메시지 타입(`mtype`)을 지정하여 지정된 수신자만이 해당 메시지를 수신하도록 함
- 메시지 큐를 식별하기 위한 키(Key)가 존재 (서로 다른 프로세스가 하나의 메시지 큐를 공유하기 위해 반드시 필요)

<br/>

### Socket(소켓)

> IPC 소켓은 동일한 호스트 운영체제에서 실행되는 프로세스 간에 데이터를 교환하기 위한 데이터 통신 엔드 포인트로, 네트워크를 통한 프로세스 간 통신 방식

<img src="https://github.com/jkde7721/cs-interview-study/assets/65665065/37b9d5b7-2db6-4e59-8f9b-2bb4378bcf13" width="60%"/>

- **소켓 통신**: 네트워크 통신 기법 중 하나로, 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트 간의 통신을 통해 데이터를 주고 받는 방식
- 네트워크 소켓 통신을 이용하여 클라이언트-서버 구조의 데이터 통신을 하며, 원격에서 프로세스 간 데이터 공유 시 사용 (분산 시스템 구축에 용이)
- 다른 IPC와 달리 프로세스의 위치에 독립적으로 Local, Remote 통신 모두 가능
- 범용적인 IPC로서 양방향 통신이 가능
- 프로세스는 IP 주소와 포트 번호를 사용하여 통신하려는 상대 프로세스의 소켓을 찾아감
- 서버 단에서는 `bind`, `listen`, `accept`으로 클라이언트의 연결 요청을 수신하고, 클라이언트 단에서는 `connect`를 통해 서버에 연결을 요청, 연결이 수립되면 소켓을 통해 데이터 송수신

<br/>

### 참고

[프로세스 간 통신(IPC: Inter-Process Communication)](https://www.youtube.com/watch?v=Bgdii8FppOU)

[IPC 1](https://steady-coding.tistory.com/508)

[IPC 2](https://jhnyang.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-IPC%EB%A9%94%EC%84%B8%EC%A7%80-%EA%B5%90%ED%99%98Message-passing-vs-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0Shared-memory)

[IPC 3](https://dar0m.tistory.com/233)

[파이프(PIPE)](https://blog.naver.com/akj61300/80130589983)
