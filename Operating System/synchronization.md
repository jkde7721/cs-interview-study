
#  프로세스 동기화

### 프로세스 동기화란?
다수의 프로세스, 혹은 스레드에서 같은 공유 자원에 동시에 접근하는 경우가 있다. 이 때,  **여러 프로세스가 공유하는 자원의 일관성을 유지**하도록 하는 것이 동기화이다. 즉,  **공유 자원의 일관성을 유지**하는 것으로 볼 수 있다.


### 레이스 컨디션 (race condition)
**여러 프로세스들이 동시에 데이터에 접근하는 상황에서, 어떤 순서로 데이터에 접근하느냐에 따라 결과 값이 달라질 수 있는 상황**을 말한다.  임계 영역에 동시에 접근하면 레이스 컨디션이 발생할 수 있다.

### 임계 영역 (Critical Section)
 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역이다.

이 임계 영역으로 인해 발생하는 문제들을 해결하기 위해 아래 **세 가지 원칙**을 만족해야 한다.
1. 상호 배제 (mutual exclusion)
한 프로세스가 임계 영역에 진입했다면 다른 프로세스는 들어올 수 없다.
2. 진행 (progress)
임걔 영역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
3. 유한 대기 (bounded waiting)
한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 영역에 들어올 수 있어야 한다. 즉, 임계 영역에 진입하려는 프로세스가 무한정 기다려서는 안 된다.

## 동기화 기법

### 뮤텍스 락
임계영역에 들어갈 때는 `Lock`을 걸어서 다른 프로세스, 쓰레드가 접근하지 못하도록 하고 임계영역에서 나올 때 `Unlock`합니다.

**Mutex Lock의 두 연산과 변수**
두 연산와 변수를 이용해 구현한다. 두 연산은 다른 스레드들이 선점할 수 없도록 원자적으로 수행된다.
-  acquire() |: Lock을 얻는 연산, 임계 영역에 들어가기 전 호출
- release() : Lock을 해제하는 연산, 임계 영역에서의 작업이 끝나고 호출
- 변수 lock : lock을 얻을 수 있는지 없는지 나타내는 Boolean 변수

![image](https://github.com/jkde7721/cs-interview-study/assets/77728683/b85c16ba-e998-4a2a-a973-adcf59ce575b)

**바쁜 대기(Busy Waiting)**
acquire() 코드를 보면 임계 구역에 이미 프로세스가 있을 경우, 진입하려는 프로세스는 임계 구역이 잠겨 있는지 아닌지 반복적으로 확인한다. 이것이 바쁜 대기이다. 바쁜 대기는 임계 구역을 계속 체크하느라 다른 프로세스들이 생산적으로 사용할 수 있는 cpu를 낭비하게 된다.

### 세마포어
Busy Waiting이 필요 없는 동기화 도구이며, **여러 프로세스나 스레드**가 임계 영역에 진입할 수 있는 Signaling 메커니즘이다. 프로세스 간에 시그널을 주고 받으며 상호작용한다.

보통 아래와 같은 프로세스로 진행된다.

    1. 어떤 자원이 n개 있다면, 카운팅 세마포어의 초기값을 n으로 설정
    2. 이후에 자원을 사용하면, 세마포어 변수의 값을 1 감소
    만약 세마포어 변수의 값이 0인 경우에는 자원을 사용할 수 없으므로 대기 상태로 들어가게 됩니다.  
    3.  자원을 반납하면 세마포어 변수의 값을 1 증가
    => 공유 자원이 여러 개 있는 경우도 적용 가능

**세마포어의 두 연산과 변수**
두 연산와 변수를 이용해 구현한다. 두 연산은 다른 스레드들이 선점할 수 없도록 원자적으로 수행된다.

- 전역 변수 S : 임계 구역에 들어갈 수 있는 프로세스의 개수(사용 가능한 공유자원의 개수)
- wait() : 쓰레드가 임계구역에 들어가기 위해 호출하는 연산, 임계 구역에 들어가지 못한다면 대기한다.
- signal() : 쓰레드가 임계구역에 작업을 마치고 임계구역 앞에서 대기중 프로세스에 들어가도 된다는 신호를 보낸다.

```
wait(){
	while(S <= 0) // 이용가능한 세마포어가 없는 경우
	; //Busy Waiting
	S--; //임계 구역에 진입할 수 있으면 S를 1 감소시키고 임계 구역 진입
	 }

signal(){
	S++; //임계 구역에서 작업 마치고 S를 1증가
 }
```

하지만 위 경우도 똑같이 Busy Waiting이 발생한다. 이를 해결하기 위해 **Block & Wakeup**을 사용한다.
임계 영역으로의 진입에 실패한 프로세스를 Busy Waiting하게 하지 않고 Block 시킨 뒤 임계 영역에 자리가 나면 다시 깨워줌으로써 Busy waiting에서의 CPU 낭비 문제를 해결해준다.


- Block : block을 호출한 프로세스를 suspend 시키고 해당 프로세스의 PCB를 wait queue에 넣어준다.
- Wakeup : block 된 프로세스를 깨운 다음, 이 프로세스의 PCB를 Ready Queue로 이동시킨다.

**세마포어 종류**
- 바이너리 세마포어(Binary semaphore) : 세마포어의 값이 0과 1만 가능한 경우
- 카운팅 세마포어(Counting semaphore) : 정수 값의 범위가 0 이상으로 제한이 없다. 주로 자원의 개수를 세는 데 사용한다.

 **뮤텍스 vs  세마포어**

-   세마포어는 Counting Semaphore등을 사용하면 Semaphore의 변수 크기 만큼 프로세스, 쓰레드가 접근할 수 있으나 뮤텍스는 오직 1개의 프로세스, 쓰레드만 접근할 수 있습니다.

-   세마포어는 수행중인 프로세스가 아닌  다른 프로세스에서 세마포어 해제가 가능합니다.  하지만 뮤텍스는 직접  `Lock`을 건 프로세스만  `UnLock`을 할 수 있습니다.


### 모니터
이전 세마포어를 이용하여 올바른 프로그램을 만드는 것은 어렵다. wait과 signal같은 연산이 프로그램 전체에 산재해있고 또한 두 연산의 순서에 따라 Deadlock이 생기거나 Mutual Exclusion이 깨지는 등 전체적으로 수행에 어떠한 영향을 미치는지 파악하기 어렵다. 이러한 어려움의 해결방안이 모니터이다.

모니터는 프로세스 간의 상호 배제를 달성하기 위해 프로그래밍 언어 수준에서 지원되는 구성체로, 사용하기 쉽다는 장점이 있다.

![image](https://github.com/jkde7721/cs-interview-study/assets/77728683/d20002b6-7c64-4572-a795-a0c7a9530c1b)

모니터는 공유자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시켜준다. 공유 자원에 접근하려고 하는 프로세스는 반드시 특정 인터페이스를 통해서만 접근 가능하다. 입장 큐가 있어서 한 번에 하나의 프로세스만 모니터에 진입해서 공유 자원에 대한 연산을 할 수 있도록 되어있다.

모니터에 진입한 프로세스가 실행 조건 만족 때까지 대기하기 위해 조건 변수(Condition variable)가 사용된다. 조건 변수는 오직 wait와 signal 연산만으로 사용될 수 있다.
- wait() - 이 연산을 호출한 프로세스는 다른 프로세스가 signal()함수를 호출 할 때까지 중단되고  해당 조건과 관련된 조건 queue에서 대기하게 됩니다.
- signal() - 대기하고 있던 프로세스를 깨웁니다. 대기중인 프로세스가 없으면 아무 작업도 수행하지 않습니다.

세마포어 변수와 유사하지만 변수가 어떤 값을 가지진 않고, 자신의 큐에 프로세스를 매달아서 sleep 시키거나 큐에서 프로세스를 깨우는 역할만 한다.


***
참고자료
블로그 참고 자료 https://rebro.kr/176
동기화 기법 강의 https://www.youtube.com/watch?v=4u13f9Umq7Y
