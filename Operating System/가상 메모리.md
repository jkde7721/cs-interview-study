# 가상 메모리

> 운영체제에서 실제 물리 메모리(RAM)보다 큰 주소 공간을 프로세스에 제공하기 위해 사용되는 기술

> 실제 메모리와는 다르게 메모리를 추상화하여 사용자에게 더 큰 메모리로 보이게 하는 것

![enter image description here](https://velog.velcdn.com/images/gojaegaebal/post/138e0a76-3c87-42d5-b155-72ba47ac6b3b/image.png)

:point_right: 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법<br/>
:point_right: 모든 데이터를 주 기억장치에 올리지 않고 필요한 것들만 올려서 사용<br/>
:point_right: 남은 것들은 보조 기억장치(HDD, SDD)에 존재<br/>
:point_right: 필요할 때 보조 기억장치에서 주 기억장치로 옮겨서 사용
<br/>

여기서 **메모리**란?

> 프로세스 실행에 필요한 데이터 및 코드를 저장하는 장치

&rarr; 크게 내부 기억장치인 주 기억장치, 외부 기억장치인 보조 기억장치로 나눈다.

<br/>

### 가상 메모리의 장점

- 메인 메모리를 하드 디스크의 캐시로 처리하여 더 넓은 메모리 공간을 제공<br/>
  &rarr; 임시 데이터를 하드 디스크 드라이브에 저장하고 필요에 따라 기본 메모리로 가져올 수도 있음
- 메모리 크기의 제약으로부터 자유로워졌고 사용자 프로그램이 실행에 필요한 최소 크기의 메모리만 올라가져 있기 때문에 더 많은 프로그램을 동시 수행 가능해짐<br/>
  &rarr; 응답 시간은 늘어나지 않으면서도 CPU 이용률과 처리율이 높아짐
- 추가 권한 비트를 사용하여 각 프로세스에 메모리에 대한 제한된 액세스 권한을 부여하여 메모리를 보호<br/>
  &rarr; OS는 권한 비트를 확인하여 한 프로세스가 다른 프로세스의 메모리 공간을 손상시키지 않도록 할 수 있음

<br/>

## 가상 주소(Virtual Address)

> 프로세스가 참조하는 주소

:bulb: 가상 주소는 논리적인 주소

&rarr; 운영체제는 프로세스에게 연속된 가상 주소 공간을 제공하고 이를 필요한 크기의 물리 메모리 페이지로 매핑<br/>
&rarr; 해당 작업으로 메모리 공간의 낭비를 최소화할 수 있음

<br/>
:bulb: 프로세스마다 독립적으로 할당되며, 프로세스는 자신만의 가상 주소 공간을 가지고 있다고 생각함

&rarr; 프로세스마다 다른 가상 주소를 사용하면 같은 물리 주소 위치를 가리키고 있을 수 있지만, 읽고 쓰고 할 수 있는 공간은 가상 주소 공간에서만 제한되므로 실제 물리 주소의 데이터들이 수정되거나, 프로세스들이 동시에 접근해서 충돌하는 일은 없을 것

<br/>

## 물리 주소(Physical Address)

> 실제 메모리의 주소, 하드웨어에서 직접 접근 가능한 주소

:bulb: 시스템 전체적으로 공유되는 주소, 여러 프로세스가 공유 메모리 영역을 사용할 때 사용

:bulb: 프로세스가 물리 주소로 접근하려면, 물리 주소를 가르키고 있는 가상 주소를 물리 주소로 변환해야 함

<br/>

## 가상 메모리 동작 원리

:pencil: 프로세스는 생성될 때 메모리를 일정하게 할당받는다. 하지만 프로세스가 모든 메모리 공간을 사용하는 것이 아닌 처리해야 할 데이터나 작업에 따라 공간을 모두 사용할 수도 있고 공간이 남을 수 있다.

① 프로세스가 차지하는 실제 메모리 공간만 물리 메모리(RAM)에 넣고, 이 물리 메모리를 접근할 수 있는 가상 주소를 프로세스의 메모리에 저장<br/>

② 프로세스가 작업을 처리하기 위해 CPU를 호출하고 CPU는 작업을 처리하기 위해 특정 데이터를 조회할 수 있음 <br/>

③ 특정 데이터가 물리 메모리(RAM) 어디에 있는지는 데이터의 가상 주소를 통해 알 수 있음 &rarr; 프로세스는 CPU에게 작업을 요청할 때 데이터의 가상 주소를 넘김<br/>

④ 가상 주소를 물리 주소로 변환하는 작업 &rarr; **MMU**<br/>
<br/>

### MMU (Memory Management Unit)

> 가상 주소를 물리 주소로 변환하고 메모리를 보호하는 기능을 수행

- MMU는 굉장히 빈번하게 작업을 처리해야 하기 때문에 소프트웨어 코드만으로는 이 작업을 수행하기 벅차다. 따라서 메모리 관리 작업을 하는 특수한 하드웨어를 따로 컴퓨터에 설치해야 함

:point_right: MMU가 메모리를 일일이 가상 주소에서 물리 주소로 변환하게 되면, 작업 부하가 높아질 수 있다.<br/>
:point_right: MMU는 실제 물리 메모리 공간을 여러 페이지 단위로 나눠서 각 페이지 단위로 데이터를 처리

<br/>

## 요구 페이징 (Demand Paging)

> 운영체제에서 사용되는 가상 메모리 관리 기법 중 하나로 프로세스가 실행되는 동안 필요한 페이지만 메모리에 올리고, 필요하지 않은 페이지는 디스크에 저장하여 메모리를 절약하는 방법

&rarr; 이를 위해 페이지 테이블에 페이지의 위치 정보와 함께 각 페이지의 접근 여부를 표시하여 필요한 페이지만 메모리에 올리게 된다
![enter image description here](https://velog.velcdn.com/images/wngud4950/post/d0539ee6-2789-4d39-b8be-a7d0fc62705a/image.png)

### 요구 페이징의 장점

① **효율적인 메모리 사용** : 요구페이징은 물리적 메모리 공간을 아끼면서 프로세스가 필요한 페이지만 메모리에 적재하므로 메모리 사용이 효율적<br/>

② **빠른 프로세스 실행** : 요구 페이징은 필요한 페이지만 적재하므로 디스크에서 메모리로 페이지를 로드하는 작업이 빠름. 이는 프로세스 실행 속도를 높이는데에 도움이 됨 <br/>

③ **대용량 메모리 지원** : 요구페이징은 가상 메모리를 사용하므로 물리적 메모리보다 큰 용량의 메모리를 지원<br/>

④ **프로세스 독립성** : 각각의 프로세스는 독립된 가상 주소 공간을 가지므로 서로의 메모리에 영향을 미치지 않음. 이는 보안과 안정성 측면에서 중요<br/>

⑤ **유연한 메모리 할당** : 요구페이징은 페이지 단위로 메모리를 할당하므로 메모리 공간을 유연하게 할당할 수 있음<br/>

⑥ **높은 처리량** : 요구페이징은 필요한 페이지만 로드하기 때문에 디스크 I/O작업이 줄어들어 전반적인 처리량이 높아짐

<br/>

### 요구 페이징의 작동 원리

1.  **프로세스 실행 시점**

:arrow_right: 프로세스가 실행되면 운영체제는 해당 프로세스의 가상 주소 공간을 만든다. 이 가상 주소 공간은 물리적 메모리 공간과는 별도의 공간으로 존재하며, 필요한 페이지만 물리적 메모리에 적재된다.

2.  **페이지 부재(Page Fault) 발생 시**

:arrow_right: 프로세스가 실행 중인데 필요한 페이지가 메모리에 없으면 페이지 부재(Page Fault)가 발생한다. 이 때, 운영체제는 해당 페이지를 디스크에서 메모리로 로드한다.

3. **페이지 교체**

:arrow_right: 메모리 공간이 부족해져서 새로운 페이지를 로드해야 할 때, 운영체제는 메모리에 적재된 페이지 중에서 가장 오랫동안 사용되지 않은 페이지를 디스크로 옮기고, 새로운 페이지를 메모리에 적재한다. 이를 페이지 교체(Page Replacement)라고 한다.

4.  **페이지 교체 알고리즘**

:arrow_right: 페이지 교체 알고리즘은 페이지 교체 시 어떤 페이지를 교체할지 결정하는 알고리즘. 대표적인 페이지 교체 알고리즘으로는 LRU(Least Recently Used), FIFO(First-In, First-Out), LFU(Least Frequently Used) 등이 있다.

5.  **페이지 적재 시점**

:arrow_right: 페이지가 처음으로 적재될 때, 페이지 테이블에 해당 페이지가 메모리에 적재되었다는 정보를 저장한다. 이후에는 해당 페이지를 참조할 때마다 페이지 테이블을 검색하여 메모리에 적재되어 있는지 확인하고, 없으면 페이지 테이블을 검색하여 메모리에 적재되어 있는지 확인하고, 없으면 페이지 부재가 발생한다.

6.  **페이지 디스크에 저장**

:arrow_right: 요구페이징에서는 메모리에 적재되어 있지 않은 페이지는 디스크에 저장된다. 디스크에 저장되는 페이지는 스왑 파일(Swap File)이라는 특수한 파일에 저장된다.

<br/>

## 페이지 폴트(Page Fault)

> 프로세스가 실행되는 도중에 필요한 페이지가 물리 메모리에 존재하지 않아 디스크에서 해당 페이지를 가져와야 하는 경우

> 프로세스가 접근하려는 페이지가 물리적 메모리에 존재하지 않는 상태에서 발생하는 인터럽트

:pencil: 페이지 폴트가 발생하면 운영체제는 해당 페이지를 물리 메모리에 적재하여 프로세스가 접근할 수 있도록 해야 함

:pencil: 메모리에 빈 공간이 있다면 페이지 폴트를 처리하기 위해 디스크에서 해당 페이지를 읽어와 물리 메모리에 적재. 빈 공간이 없는 경우, 운영체제는 페이지 교체(Page Replacement) 알고리즘을 사용하여 더 이상 사용되지 않는 페이지를 디스크로 내보내고, 새로운 페이지를 메모리에 적재

:pencil: 페이지 폴트가 발생하는 빈도는 페이지 교체 알고리즘과 메모리의 크기 프로세스의 특성 등에 따라 달라짐. 페이지 폴트가 많이 발생하면 시스템의 성능이 저화되므로, 페이지 교체 알고리즘을 최적화하여 페이지 폴트를 최소화하는 것이 중요

<br/>

### 참고

[[OS] 가상 메모리 (Virtual Memory)](https://velog.io/@wngud4950/CS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-Virtual-Memory)

[[OS] 가상 메모리란?](https://jerryjerryjerry.tistory.com/186)

[[OS] 요구 페이징](https://superohinsung.tistory.com/127)
