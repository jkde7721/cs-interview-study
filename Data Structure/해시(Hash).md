# 해시(Hash)

해시(= 해시함수)는 임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 단방향 함수를 말한다.

-  해시 함수는 언제나 동일한 해시 값을 반환한다.
- 아무리 큰 숫자를 넣더라도 정해진 크기의 숫자가 나오는 함수이다.

## 해시테이블
해시테이블은 해시함수를 사용하여 키를 해시 값으로 매핑하고, 이 해시 값을 색인 또는 주소 삼아 데이터(value)를 key와 함께 저장하는 자료구조이다.  데이터가 저장되는 곳을  `버킷`  또는  `슬롯`이라고 한다.
해시 테이블의 기본 연산은 삽입, 삭제, 탐색이다.

 ### 해시테이블 구성

-   **key**
    -   고유한 값, hash function의 input이 된다.
    -   키값 그대로 저장소에 저장할 경우 다양한 키의 길이 만큼의 크기를 구성해두어야 하기 때문에 일정한 길이의 해시로 변경한다.
-   **hash function**
    -   key를  **고정된 길이**의  `hash`로 변경해주는 역할을 한다. 이 과정을  `hashing`이라고 한다.

-   **value**
    -   저장소(bucket, slot)에 최종적으로 저장되는 값으로, hash와 매칭되어 저장.

### 해시테이블 장단점
**장점**
- 해시테이블은 key-value가 1:1로 매핑되어 있기 때문에 삽입, 삭제, 검색의 과정에서 모두 평균적으로 `O(1)`의 시간복잡도를 가지고 있다.

**단점**
 -   해시 충돌이 발생
	-   순서가 있는 배열에는 어울리지 않는다 => 순서에 상관없이 key만을 가지고 삽입, 검색, 삭제하기 때문
	-   공간 효율성이 떨어짐 => 데이터가 저장되기 전에 미리 저장공간을 확보해야하기 때문. 공간이 부족하거나 아예 채워지지 않은 경우가 발생
	-   hash function의 의존도가 높다 => 평균 시간복잡도가  `O(1)`이지만 해시함수가 복잡해 연산이 오래 걸린다면 해시테이블의 연산 속도는 증가

### 해시테이블의 크기?
키가 100개 있다고 할 떼, 해시테이블의 크기를 100으로 설정한다고 하자. 어떤 장점이 있을까? 100개의 키가 충돌 없이 100개의 방에 잘 들어갈 것이다.

그러나 만약 실제로 사용하는 키가 10개 뿐이라면?  방은 10개만 사용할 것인데 100개의 방을 유지하고 있어 메모리 낭비이다.

따라서 보통의 경우 실제 사용하는 키 개수보다 적은 해시테이블을 운용한다고 한다. 이 경우 서로 다른 키에 해시 함수를 적용한 해시 값이 같을 수 있기 때문에 해시 충돌이 일어난다.

### 해시 충돌 해결방법

1. Chaining
![image](https://github.com/jkde7721/cs-interview-study/assets/77728683/ebdac439-9a9a-4d00-9c14-b5a967f64062)
충돌이 일어나면 기존 값과 새로운 값을 연결리스트를 이용해 연결시키는 방법이다.

충돌이 나면 그냥 연결해주면 되기 때문에 많은 공간을 미리 잡아둘 필요가 없다.
그러나 한 해시 값에 자료들이 많이 연결되면 검색 효율이 떨어지고 연결리스트를 저장하기 위해 외부 저장 공간을 사용 및 추가로 관리 해줘야 하는 단점이 있다.

2. Open Addressing (개방주소법)
![image](https://github.com/jkde7721/cs-interview-study/assets/77728683/724d2562-b425-4e6e-8147-f0dca3bdd444)
충돌이 일어나면 빈 방을 찾아 값을 저장한다. 빈 방을 찾는 방법은 여러가지가 있다.

| 규칙 | 설명 |
|--|--|
| 선형 탐색 | 해시 값에서 고정폭(1칸?)을 건너 뛰어 비어있응 해시에 저장, 특정 해시값 주변 버킷이 모두 채워져 있는 primary clustring 문제에 취약 |
| 제곱 탐색 | 충돌이 일어난 해시의 제곱을 한 해시에 데이터를 저장, 여러 개의 서로 다른 키들이 동일한 초기 해시 값을 갖는 secondary clustering에 취약  |
| 이중 해싱 | 다른 해시 함수를 한번 더 적용해 나온 해시에 데이터를 저장. 이중해싱을 하면 최초 해시 값이 달라지므로 탐사 이동폭이 달라지고, 탐사 이동폭이 같더라도 최초 해시값이 달라져 primary, secondary clustering을 완화 |

또 다른 저장 공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.

3. 리스트 크기 재배열
위처럼 충돌을 해결한다고 해도, 결과적으로 충돌로 인한 성능 저하를 막을 수 없다. 따라서 일정 수용량이 넘어가면 리스트 크기를 키우고 재배열한다. 비용이 많이 드는 과정이라 실시간으로 빠르게 처리되어야 하는 환경에서는 무리일 수 있다.

4. 해시 테이블 확장 방식
따로 큰 리스트를 하나 더 만들고 점진적으로 옮긴다. 메모리를 훨씬 더 많이 사용하게 된다.

5. 좋은 해시 함수를 쓰자!
충돌나지 않고 해시 값을 고르게 만들어내는 게 좋은 해시 함수이다.

	1. division method
숫자로 된 키를 해시테이블의 크기 m으로 나눈 나머지를 해시값으로 변환한다.  
간단하면서 빠른 연산이 가능한 것이 장점

	2. multiplication method
숫자 키 k, A는 0과 1 사이의 실수 일 때,  
`h(k)=(kA mod 1)×m`  
2진수 연산에 최적화된 컴퓨터구조를 고려한 해시함수라고 한다.  
나눗셈법보다는 다소느리다.

	3. univeral hashing
다수의 해시함수를 만들고, 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법  

***
https://namu.wiki/w/%ED%95%B4%EC%8B%9C
https://velog.io/@adam2/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94
