# 힙(Heap)
![image](https://github.com/jkde7721/cs-interview-study/assets/77728683/c78049cb-7837-4ef5-8abf-e413d6ab068c)

여러 개의 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위해 고안 완전 이진 트리이다. 부모의 값은 항상 자식(들)의 값보다 크거나(최대 힙), 작아야( 최소 힙)하는 규칙이 있다. 따라서 루트노드에는 항상 데이터들 중 가장 큰 값(혹은 가장 작은 값)이 저장되어 있기 때문에, 최댓값(혹은 최솟값)을 O(1)안에 찾을 수 있다.

## 구현

-   힙을 저장하는 표준적인 자료구조는  `배열`이다.
-   구현을 쉽게 하기 위해 배열의 첫번째 인덱스인 0은 사용되지 않는다.

```
왼쪽 자식 index = (부모 index) * 2
오른쪽 자식 index = (부모 index) * 2 + 1
부모 index = (자식 index) / 2
```

## 응용분야? => 우선순위 큐
우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조로 일반적으로 힙을 이용하여 구현한다.


## 데이터의 삽입과 삭제
삽입과 삭제는 모두 O(log N)이 소요된다. 자세히 말하자면 삽입과 삭제 자체는 O(1)이지만 재정렬하는 과정에서 O(log N)이 소요된다.

**삽입**
1.  힙에 새로운 요소가 들어오면, 일단 새로운 노드를  **힙의 마지막 노드에 삽입**한다.
3.  새로운 노드를 부모 노드들과 교환한다.
4.  규칙에 맞으면 그대로 두고, 그렇지 않으면 부모와 교환한다. (부모노드는 삽입된 위치의 인덱스 번호에서 /2를 하면 쉽게 구할 수 있다.)
5.  규칙에 맞을 때까지 3번 과정을 반복한다.

![image](https://github.com/jkde7721/cs-interview-study/assets/77728683/22de6b91-12d8-4a42-8bfa-f57428f64083)

<br>

**삭제**

1.  루트 노드를 제거한다.
3.  루트 자리에 가장 마지막 노드를 삽입한다.
4.  올라간 노드와 그의 자식 노드(들)와 비교한다.
5.  조건에 만족하면 그대로 두고, 그렇지 않으면 자식과 교환한다.


-   최대 힙

    1. 부모보다 더 큰 자식이 없으면 교환하지 않고 끝낸다.
    2.  부모보다 더 큰 자식이 하나만 있으면 그 자식하고 교환하면 된다.
    3.  부모보다 더 큰 자식이 둘 있으면 자식들 중 큰 값과 교환한다.


-   최소 힙
    1. 부모보다 더 작은 자식이 없으면 교환하지 않고 끝낸다.
    2.  부모보다 더 작은 자식이 하나만 있으면 그 자식하고 교환하면 된다.
    3.  부모보다 더 작은 자식이 둘 있으면 자식들 중 작은 값과 교환한다.


5. 조건을 만족할 때까지 4의 과정을 반복한다.

![image](https://github.com/jkde7721/cs-interview-study/assets/77728683/0953cb5a-a58a-4b50-9626-b70edd1a6b72)

***
https://namu.wiki/w/%ED%9E%99%20%ED%8A%B8%EB%A6%AC
https://velog.io/@yanghl98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Heap%ED%9E%99-%EA%B0%9C%EB%85%90-%EC%A2%85%EB%A5%98-%ED%99%9C%EC%9A%A9-%EC%98%88%EC%8B%9C-%EA%B5%AC%ED%98%84
