

## 버블 정렬 
인접한 두 수를 비교하며 정렬해나가는 방법. 
작은 숫자는 왼쪽으로, 큰 숫자는 오른쪽으로 이동 
<br>

<img src = "https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png" width = "500" ></img> 
<br>
- 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료 정렬
- 1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다
<br>

```
def bubbleSort(arr):
    
    arrLength = len(arr)
    
    for i in range(arrLength-1) :
        for j in range(arrLength-1-i):
            if (arr[j] > arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]
        
    return arr

```

<br>

### 버블 정렬(bubble sort) 알고리즘의 특징
장점
- 구현이 매우 간단하다.

단점
- 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
- 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
- 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.

일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.

<br>

### 버블 정렬(bubble sort)의 시간복잡도
시간복잡도를 계산한다면

- 비교 횟수
  - 최상, 평균, 최악 모두 일정
  - n-1, n-2, … , 2, 1 번 = n(n-1)/2

- 교환 횟수
  - 입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 (비교 횟수 * 3) 번 = 3n(n-1)/2
  - 입력 자료가 이미 정렬되어 있는 최상의 경우, 자료의 이동이 발생하지 않는다.

T(n) = O(n^2)


<br>

[레퍼런스](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)