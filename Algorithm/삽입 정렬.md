
## 삽입 정렬 
-   정렬된 데이터 그룹을 늘려가며 추가되는 데이터는 알맞은 자리에 삽입하는 방식
- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
- 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.
<br>

<img src = "https://gmlwjd9405.github.io/images/algorithm-insertion-sort/insertion-sort.png" width = "500" ></img> 

<br>

- 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
- 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.
- 처음 Key 값은 두 번째 자료부터 시작한다.

<br>


```
def insertionSort(arr):
    
    arrLength = len(arr)
    
    for i in range(1, arrLength):
        key, j = arr[i], i-1
        
        while j >= 0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        
        arr[j+1] = key
    return arr
```

### 삽입 정렬(insertion sort) 알고리즘의 특징
장점
- 안정한 정렬 방법
- 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
- 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.

단점
- 비교적 많은 레코드들의 이동을 포함한다.
- 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다

<br>

### 삽입 정렬(insertion sort)의 시간복잡도

최선의 경우
- 비교 횟수
  - 이동 없이 1번의 비교만 이루어진다.
  - 외부 루프: (n-1)번
- Best T(n) = O(n)

최악의 경우(입력 자료가 역순일 경우)
- 비교 횟수
  - 외부 루프 안의 각 반복마다 i번의 비교 수행
  - 외부 루프: (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = O(n^2)

- 교환 횟수
  - 외부 루프의 각 단계마다 (i+2)번의 이동 발생
  - n(n-1)/2 + 2(n-1) = (n^2+3n-4)/2 = O(n^2)

- Worst T(n) = O(n^2)



<br>

[레퍼런스](https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)