## HTTP Method & HTTP status code

### HTTP 메소드

> 주어진 리소스에 대해 서버가 수행해야 할 동작을 지정

**GET**

- 리소스 조회 시 사용
- 쿼리 파라미터(쿼리 스트링) 또는 경로 변수를 통해 서버에 데이터 전달 `/members?page=1&size=5`, `/members/100`
- 메시지 바디를 통해 데이터 전달 가능하지만 지원하지 않는 경우도 있기 때문에 권장X

**POST**

- 주로 리소스를 생성하거나 변경하기 위해 서버에 데이터를 전달하는 경우 사용
- 메시지 바디를 통해 서버에 데이터 전달

  ```
  POST /members HTTP/1.1
  content-type: application/json

  {
    "name": "kim",
    "age": 20
  }
  ```

- 서버는 메시지 바디를 통해 전달된 데이터를 처리하는 모든 기능을 수행
- 신규 리소스 생성 시 `201 Created` 상태 코드와 생성된 리소스의 URI 경로를 `Location` 헤더에 추가하여 응답으로 반환
- POST 사용 정리
  - 새 리소스 생성: 서버가 아직 식별하지 않은 새 리소스 생성
  - 요청 데이터 처리: 단순히 데이터를 생성하거나 변경하는 것을 넘어서 프로세스를 처리하는 경우 ex. 주문에서 **결제완료 → 배달시작 → 배달완료** 같은 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
  - 다른 메소드로 처리하기 애매한 경우: ex. JSON으로 조회 데이터를 넘겨야 하는데 GET 메서드를 사용하기 어려운 경우
- PRG(Post/Redirect/Get)

  - 웹 브라우저의 새로 고침은 서버에 전송한 마지막 요청을 재요청
  - 만약 POST 요청 후 새로 고침하면 같은 POST 요청을 서버에 다시 보내 리소스가 중복 생성
  - POST 요청에 대한 응답으로 상태 코드 `302 Found`를 전달하여 클라이언트가 자동으로 `Location` 헤더의 URL로 재요청하도록 함(Redirect) → 마지막 요청이 POST가 아닌 GET이기 때문에 새로 고침 문제 발생X

**PUT**

- 주로 리소스를 생성하거나 변경하기 위해 서버에 데이터를 전달하는 경우 사용
- 새로운 리소스를 생성하거나 만약 해당 리소스가 이미 존재한다면 기존 리소스를 덮어씀 (리소스를 완전히 대체 → 지정하지 않으면 일부 데이터 NULL 값으로 변경될 수 있음)
- POST와의 차이점

  - **PUT은 멱등**: PUT 요청을 여러번 호출해도 항상 같은 결과를 반환하는 반면, POST는 같은 요청을 여러번 호출하면 같은 리소스를 여러번 생성하는 등 반환되는 결과가 매번 달라짐
  - **클라이언트가 리소스의 위치를 앎**: PUT 요청 시 클라이언트는 리소스의 위치를 알고 URI에 지정 (프로세스 처리를 위해 POST 요청하는 경우에도 클라이언트가 리소스의 위치를 알고 지정할 수 있음, 즉 절대적인 차이점X)

    ex. `PUT /members/100` (아이디가 100인 멤버만을 변경), `POST /members` (새로운 멤버를 생성, 해당 멤버의 아이디는 모름)

**PATCH**

- 리소스를 부분적으로 변경 시 사용
- PUT과 달리 리소스를 완전히 대체하지 않고 일부만 대체

  ```
  POST /members HTTP/1.1
  content-type: application/json

  {
    "name": "kim",
    "age": 20
  }

  //name 필드를 지정하지 않았기 떄문에 아이디가 1인 멤버의 name 값이 NULL로 변경될 수 있음 (완전히 대체)
  PUT /members/1 HTTP/1.1
  content-type: application/json

  {
    "age": 20
  }

  //지정한 필드만을 변경하여 아이디가 1인 멤버의 age 값만 기존 20에서 25로 변경됨 (일부만 대체)
  PATCH /members/1 HTTP/1.1
  content-type: application/json

  {
    "age": 25
  }
  ```

**DELETE**

- 특정 리소스의 삭제 요청 시 사용

**기타 메소드**

- **HEAD**: GET과 거의 동일하나 응답 메시지에 바디 포함X (응답 상태 코드, 헤더만 반환)

  - `GET /members` 요청에 대한 응답 메시지 바디에는 멤버 리스트 데이터가 포함되어 있는 반면, `HEAD /members` 요청으로는 해당 멤버 리스트 데이터를 전달받을 수 없음
  - 주로 실제 GET 요청을 하기 전에 GET 요청으로 어떤 데이터를 전달받을 수 있는지 확인하는 용도로 사용 ex. 용량이 매우 큰 파일을 다운로드하기 전 해당 파일의 크기를 확인하기 위해

- **OPTIONS**: 대상 리소스에 대한 통신 가능 옵션을 설정하는데 사용 (주로 CORS에서 사용)
- **CONNECT**: 대상 리소스로 식별되는 서버에 대한 터널(양방향 통신)을 설정 (거의 사용X)
- **TRACE**: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행 (거의 사용X)

<br/>

### HTTP 메소드의 속성

| 메소드  | 안전 | 멱등 | 캐시 가능 |
| ------- | ---- | ---- | --------- |
| GET     | ⭕   | ⭕   | ⭕        |
| POST    | ❌   | ❌   | ⭕        |
| PUT     | ❌   | ⭕   | ❌        |
| PATCH   | ❌   | ❌   | ⭕        |
| DELETE  | ❌   | ⭕   | ❌        |
| HEAD    | ⭕   | ⭕   | ⭕        |
| OPTIONS | ⭕   | ⭕   | ❌        |
| CONNECT | ❌   | ❌   | ❌        |
| TRACE   | ⭕   | ⭕   | ❌        |

- **안전(Safe)**: 호출해도 리소스를 변경하지 않는 특성
- **멱등성(Idempotent)**: 동일한 요청을 여러번 보내도 한 번 보내는 것과 같은 특성

  - GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회
  - PUT: 같은 요청을 여러번 해도 최종 결과는 같음 (기존 요청 결과를 계속해서 덮어씀)
  - DELETE: 같은 요청을 여러번 해도 최종 삭제된 결과는 같음

    ex. `DELETE /members/100` (응답 `204 No Content`) → `DELETE /members/100` (응답 `404 Not Found`) ➡️ DELETE 여러번 호출 시 응답 코드는 달라질 수 있지만 아이디가 100인 멤버가 삭제된 것은 동일

  - POST: 두 번 호출하면 리소스가 중복 생성 → 멱등X ex. 같은 결제가 중복해서 발생
  - 올바르게 구현된 **GET**, **PUT**, **DELETE** 메소드는 멱등성을 지님
  - 자동 복구 메커니즘에 활용: 서버가 TIMEOUT 등으로 정상 응답을 주지 못했을 때(클라이언트는 서버가 요청 처리에 실패했는지 성공했는지 판단할 수 없음) 클라이언트가 같은 요청을 다시 보내도 되는가에 대한 판단 근거
  - 외부 요인(ex. 다른 요청에 의한 변경)으로 중간에 리소스가 변경되는 것은 고려하지 않고 현재 요청만을 기준으로 판단

- **캐시 가능(Cacheable)**: 응답 결과를 클라이언트에서 캐시해서 사용해도 되는 특성
  - GET, HEAD, POST, PATCH가 가능하지만 실무에서는 구현이 어렵기 때문에 주로 **GET**, **HEAD** 정도만 캐시하여 사용

<br/>

### GET vs POST 비교

|                       | GET                                                                                                        | POST                                                                                                                                     |
| --------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 여러번 요청 (멱등성)  | 항상 같은 결과 반환                                                                                        | 리소스가 중복 생성될 수 있음                                                                                                             |
| 북마크                | 가능                                                                                                       | 불가능                                                                                                                                   |
| 캐시                  | 가능                                                                                                       | 불가능                                                                                                                                   |
| 브라우저 사용 기록    | 요청 파라미터가 브라우저에 기록됨                                                                          | 요청 파라미터가 브라우저에 기록되지 않음                                                                                                 |
| 요청 데이터 길이 제한 | 데이터를 URL에 직접 추가하여 전달하기 때문에 제한O (URL 길이 제한: 최대 2048자)                            | 제한X                                                                                                                                    |
| 요청 데이터 타입 제한 | ASCII 코드만 가능                                                                                          | 제한X (binary 데이터도 가능)                                                                                                             |
| 보안                  | 데이터가 URL에 포함되어 전달되기 때문에 POST에 비해 보안성↓ (비밀번호나 민감한 정보 전달 시에는 GET 사용X) | 데이터가 메시지 바디에 포함되어 전달되며, 요청 파라미터 값이 브라우저 사용 기록이나 웹 서버 로그에도 남지 않기 때문에 GET에 비해 보안성↑ |

<br/>
<hr/>

### HTTP 상태 코드

> 클라이언트가 서버에게 보낸 특정 HTTP 요청의 성공/실패 여부, 실패 이유 등의 정보를 전달하는 일종의 약속 (100번대부터 500번대까지 5개의 그룹으로 나뉨)

- **1xx(정보)**: 요청을 받았으며 프로세스를 계속 진행 (거의 사용X)
- **2xx(성공)**: 클라이언트가 요청한 작업을 서버가 성공적으로 수행
- **3xx(리다이렉션)**: 클라이언트가 요청한 리소스가 옮겨졌거나 삭제되어 기존 URL로는 더 이상 해당 리소스에 접근할 수 없고 다른 URL을 통해서 그 리소스에 접근해야 하는 경우
- **4xx(클라이언트 에러)**: 클라이언트가 서버에게 보낸 요청이 잘못된 경우
- **5xx(서버 에러)**: 서버가 유효한 요청에 대한 처리에 실패한 경우

| 상태 코드                   | 설명                                                                                                                                                                                                                                                                  |
| --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `200 OK`                    | 요청이 성공적으로 완료                                                                                                                                                                                                                                                |
| `201 Created`               | 요청이 성공적으로 완료되었으며 그 결과 새로운 리소스가 생성됨 (일반적으로 POST 또는 일부 PUT 요청 시)                                                                                                                                                                 |
| `204 No Content`            | 요청이 성공적으로 완료되었으며 그 결과 요청과 관련되었던 컨텐츠가 삭제되어 존재하지 않음 (클라이언트는 해당 컨텐츠 더 이상 사용 불가)                                                                                                                                 |
| `301 Moved Permanently`     | 요청한 리소스의 URI가 변경되었음을 의미, HTTP 헤더의 `Location` 필드를 찾아보고 해당 필드가 존재할 경우 `Location` 필드에 담긴 URL로 자동 리다이렉션 수행                                                                                                             |
| `302 Found`                 | 요청한 리소스의 URI가 일시적으로 변경되었음을 의미, HTTP 헤더의 `Location` 필드를 찾아보고 해당 필드가 존재할 경우 `Location` 필드에 담긴 URL로 자동 리다이렉션 수행                                                                                                  |
| `304 Not Modified`          | 클라이언트가 요청한 리소스가 이전 요청에 대한 응답과 비교해보았을 때 바뀌지 않음, 서버로부터 요청한 리소스를 받는 것이 아닌 자신이 캐싱해놓았던 리소스로 리다이렉션 (암묵적인 리다이렉션)                                                                             |
| `400 Bad Request`           | 잘못된 문법으로 인해 서버가 요청을 이해할 수 없음                                                                                                                                                                                                                     |
| `401 Unauthorized`          | 인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우 ex. 로그인이 필요한 API를 비로그인 사용자가 호출한 경우                                                                                                                                                   |
| `403 Forbidden`             | 클라이언트가 접근이 금지된 리소스를 요청, `Unauthorized`과 다른 점은 서버는 클라이언트가 누구인지 알고 있음                                                                                                                                                           |
| `404 Not Found`             | 요청받은 리소스를 찾을 수 없음                                                                                                                                                                                                                                        |
| `405 Method Not Allowed`    | 현재 리소스에 맞지 않는 메소드를 사용함                                                                                                                                                                                                                               |
| `406 Not Acceptable`        | 클라이언트가 요청하는 컨텐츠 타입(요청 시 `Accept` 필드에 명시)의 리소스가 서버에 존재하지 않음 (서버가 응답으로 줄 수 있는 리소스 중 클라이언트가 원하는 타입 없음)                                                                                                  |
| `408 Request Timeout`       | 클라이언트와 서버의 연결은 생성, but 클라이언트가 보낸 요청 본문은 서버에 도착하지 않은 경우                                                                                                                                                                          |
| `429 Too Many Requests`     | 클라이언트가 서버에 너무 많은 요청을 보낸 경우 (응답 헤더 `Retry-After`를 통해 해당 시간 이후에 재요청할 수 있음을 지정)                                                                                                                                              |
| `500 Internal Server Error` | 서버에서 요청 처리 중 에러 발생 (에러의 원인은 클라이언트에게 알려주지 않음)                                                                                                                                                                                          |
| `502 Bad Gateway`           | 백엔드 어플리케이션이 죽은 경우                                                                                                                                                                                                                                       |
| `503 Service Unavailable`   | 서버가 요청을 처리할 준비가 되지 않은 경우 (`Bad Gateway`와 비슷하지만 보다 **일시적인 상황**을 의미하는 상태 코드), 일반적으로 서버에 부하가 심해 현재 요청을 처리할 여유가 없는 경우에 주로 사용 (`Too Many Requests`와 동일하게 응답 헤더 `Retry-After` 지정 가능) |
| `504 Gateway Timeout`       | `Request Timeout`과 마찬가지로 요청에 대한 타임아웃을 의미, but 클라이언트의 요청 지연 때문에 발생하는 것이 아닌 클라이언트 요청에 대한 처리 중에 서버끼리 주고 받는 요청에서 발생                                                                                    |

<br/>

### 참고

[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

[HTTP Method GET vs POST](https://www.w3schools.com/tags/ref_httpmethods.asp)

[HTTP 상태 코드 1](https://evan-moon.github.io/2020/03/15/about-http-status-code/)

[HTTP 상태 코드 2](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)
